<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ethernaut训练]]></title>
    <url>%2F2019%2F01%2F08%2Fethernautd%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[简介ethernaut包含有22道智能合约的训练题目，而最近有关智能合约的题也是在不断的出现，所以还是有必要了解一下的(顺便了解下这种题目怎么做) 题目链接 另外也放上大哥的writeup跟着学习一下链接 level 0 - Hello Ethernaut题目链接 第一步首先是简单的教程，先下载MetaMask插件并且注册账号，然后设置钱包并使用Ropsten测试网络 第二步打开控制台，然后会发现给了合约地址和help 其中level地址为 0xdf51a9e8ce57e7787e4a27dd19880fd7106b9a5c在Ropsten测试网络下还会有你的player地址和Ethernaut地址使用player指令可以直接获得player地址 第三步之后会让你使用getBalance函数获得你的以太坊的数量，并且让你使用help(),由于我们第二步使用过，就不再演示了PS:由于在Ropsten测试网络中可以直接通过Ether Faucet获得测试以太坊，所以我的数额为7 第四步使用ethernaut指令可以直接输出当前合约的有关信息，其中的abi可以理解为合约中的公共方法列表，当然在下面可以看见例如owner: f()之类的东西就是方法的具体信息 第五步与ABI互动，也就是可以调用上一步说的方法列表里的方法，系统让我们调用ethernaut.owner()，返回的是智能合约的拥有者 第六步这一步就是让我们通过上面提到的Ether Faucet获得测试以太坊，可以将MetaMask调至中文，然后点击存入-测试水管，之后点击request 1 ether from faucet就行 第七步生成合约实例，点击下面的蓝色按钮即可，需要等待一段时间 成功之后会显示下图 第八步题目告诉你生成的合约实例可以调用合约的ABI，也可以自己试试，用contract.方法就行 第九步从contract.info()入手跟着走下去就行 之后点击submit instance即可过关。 level 1 - Fallback题目链接 胜利条件1.获得合约的所有权2.收回合约的所有余额 tips1.如何用ABI发送ether2.如何用ABI以外的方法发送ether3.查看help()会有帮助4.Fallback方法 源码123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallback is Ownable &#123; mapping(address =&gt; uint) public contributions; function Fallback() public &#123; //构造函数，初始化owner的contributions为1000 contributions[msg.sender] = 1000 * (1 ether); &#125; function contribute() public payable &#123; //将合约拥有权交给贡献1000ETH以上的人 require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; //查询contribution return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; //owner收回合约的所有余额，只有owner可以调用 owner.transfer(this.balance); &#125; function() payable public &#123; //fallback函数，当满足发送的value大于1并且发送者的contributions的值大于1时将owner变为消息发送者 require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; FallBack函数回退函数(fallback function)1.每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。 2.此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。在此时，一般仅有少量的gas剩余，用于执行这个函数(准确的说，还剩2300gas)。所以应该尽量保证回退函数使用少的gas。 我们在这里要用到的就是第二点 解题思路最终目的是调用withdraw()方法将余额清零，也就是我们要成为ownercontribute里面虽然有可能称为owner，但是代价太过昂贵（1000ETH且每次只能发送小于0.001的ETH）在fallback中只要满足msg.value&gt;0且contributions[msg.sender]&gt;0即可成为owner其中msg.value我们可以直接发送过去，而contributions[msg.sender]我们需要调用contribute()这个函数，也就是参数满足value&lt;0.001的条件就行 具体步骤1.调用contribute函数，传入参数value=1其中value的单位是wei 11 eth = 1e9 Gwei = 1e18 wei 2.调用send函数，传入参数1(也可以在钱包里直接打钱，不过听说打钱会有bug，就直接用send了，当然也可以用contract.sendTransaction({value: 100}))， 由于send函数会调用fallback函数，我们便成为了owner 3.调用withdraw函数，将钱卷走 4.点击submit instance即可过关。 注意事项绝对不要操作太快了，每一步传值的时候都要等到右下弹出提示再继续,否则可能和我一样一个账号40多条操作在排队，过了一个小时都没反应,只能再开一个账号(:зゝ∠)]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Start这个博客主要用来记录一些有关ctf的知识因为自己太健忘了，不记录下会出事的而且搭个博客以后AWD就不用再坐着发呆了，起码有点东西可以看本博客主要分为web和crypto两个方向，也是我现在负责的两个方向希望自己多多加油把！ 最后来个常规操作 1$ ehco "Hello world"]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
